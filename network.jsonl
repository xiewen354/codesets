{"language": "c++", "domain": "network", "source": "gpt4+人工筛选；源文件地址/data/xw/c++dataset/network/already/187.cpp", "prompt": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n/* \n实现对MAC地址的各个部分进行操作的功能\nvoid mac_address_operator(const char *mac_str, unsigned char *mac_parts)\nmac_str是一个MAC地址，mac_parts是一个长度至少为6的字节数组，用来存放转化后的MAC地址的各个部分\n*/\n", "solution": "void mac_address_operator(const char *mac_str, unsigned char *mac_parts) {\n    int a[6];\n    int cnt=sscanf(mac_str, \"%x:%x:%x:%x:%x:%x\", &a[0], &a[1], &a[2],&a[3],&a[4],&a[5]);\n    if (cnt!=6) {\n        printf(\"Invalid MAC address\\n\");\n        exit(1);\n    }\n    for (int i=0; i<6; i++)\n        mac_parts[i]=(unsigned char)a[i];\n}\n", "test": "#include <assert.h>\n#include <string.h>\nint main(){\n    unsigned char mac_parts[6];\n    const char *mac_str1=\"00:0c:29:58:35:3e\";\n    mac_address_operator(mac_str1,mac_parts);\n    assert(mac_parts[0]==0x00 && mac_parts[1]==0x0c && mac_parts[2]==0x29 && mac_parts[3]==0x58 && mac_parts[4]==0x35 && mac_parts[5]==0x3e);\n    \n    const char *mac_str2=\"ff:ff:ff:ff:ff:ff\";\n    mac_address_operator(mac_str2,mac_parts);\n    assert(mac_parts[0]==0xff && mac_parts[1]==0xff && mac_parts[2]==0xff && mac_parts[3]==0xff && mac_parts[4]==0xff && mac_parts[5]==0xff);\n\n    const char *mac_str3=\"00:00:00:00:00:00\";\n    mac_address_operator(mac_str3,mac_parts);\n    assert(mac_parts[0]==0x00 && mac_parts[1]==0x00 && mac_parts[2]==0x00 && mac_parts[3]==0x00 && mac_parts[4]==0x00 && mac_parts[5]==0x00);\n\n    const char *mac_str4=\"3a:c2:15:5d:b1:47\";\n    mac_address_operator(mac_str4,mac_parts);\n    assert(mac_parts[0]==0x3a && mac_parts[1]==0xc2 && mac_parts[2]==0x15 && mac_parts[3]==0x5d && mac_parts[4]==0xb1 && mac_parts[5]==0x47);\n\n    const char *mac_str5=\"a9:4b:1d:5e:33:f1\";\n    mac_address_operator(mac_str5,mac_parts);\n    assert(mac_parts[0]==0xa9 && mac_parts[1]==0x4b && mac_parts[2]==0x1d && mac_parts[3]==0x5e && mac_parts[4]==0x33 && mac_parts[5]==0xf1);\n\n    return 0;\n}\n"}
{"language": "c++", "domain": "network", "source": "gpt4+人工筛选；源文件地址/data/xw/c++dataset/network/already/196.cpp", "prompt": "#include <iostream>\n#include <string>\n#include <bitset> \n/* \n实现一个IP地址转换函数，将点分十进制IP地址转换为32位二进制形式。\n函数定义为: std::string IpToBinary(std::string ip)\nip: 点分十进制的IP地址字符串\n返回值: 转换后的二进制字符串\n*/\n", "solution": "std::string IpToBinary(std::string ip) {\n    std::string binary_ip = \"\";\n    size_t pos = 0;\n    std::string token;\n    while ((pos = ip.find(\".\")) != std::string::npos) {\n        token = ip.substr(0, pos);\n        unsigned long int octet = std::stoul(token);\n        std::string binary_octet = std::bitset<8>(octet).to_string(); \n        binary_ip += binary_octet;\n        ip.erase(0, pos + 1);\n    }\n    unsigned long int octet = std::stoul(ip);\n    std::string binary_octet = std::bitset<8>(octet).to_string(); \n    binary_ip += binary_octet;\n    return binary_ip;\n}\n", "test": "#include<iostream>\n#include<string>\n#include<assert.h>\n\nint main(){\n    std::string ip = \"192.168.1.1\";\n    std::string binary_ip = \"11000000101010000000000100000001\";\n    assert(IpToBinary(ip)==binary_ip);\n\n    std::string ip2 = \"255.255.255.255\";\n    std::string binary_ip2 = \"11111111111111111111111111111111\";\n    assert(IpToBinary(ip2)==binary_ip2);\n    \n    std::string ip3 = \"0.0.0.0\";\n    std::string binary_ip3 = \"00000000000000000000000000000000\";\n    assert(IpToBinary(ip3)==binary_ip3);\n}\n"}
{"language": "c++", "domain": "network", "source": "gpt4+人工筛选；源文件地址/data/xw/c++dataset/network/already/292.cpp", "prompt": "#include <iostream>\n#include <string>\n\nusing namespace std;\n\n/*实现一个函数，用来检测MAC地址的有效性。\n函数的格式定义为：bool isValidMAC(string macAddress)\nmacAddress是输入的MAC地址（形式如\"XX-XX-XX-XX-XX-XX\"或\"XX:XX:XX:XX:XX:XX\"，每个XX是一个十六进制的数字，如A3，7F，1C等）\n返回一个bool值，表示MAC地址是否有效（有效返回true，无效返回false）。\n*/\n", "solution": "bool isValidMAC(string macAddress){\n    int len = macAddress.length();\n    \n    // 检查地址是否为12个十六进制字符组成，分隔符为\":\"或\"-\"\n    if (len != 17) {\n        return false;\n    }\n    for(int i=0; i<len; i++){\n        char c = macAddress[i];\n        if(i % 3 == 2){\n            if(c != ':' && c != '-'){\n                return false;\n            }\n        }else{\n            if(!((c >= '0' && c <= '9') || (c >= 'a' && c <= 'f') || (c >= 'A' && c <= 'F'))){\n                return false;\n            }\n        }\n    }\n    return true;\n}\n", "test": "#include<assert.h>\nint main() {\n    assert(isValidMAC(\"01-23-45-67-89-AB\")==true);\n    assert(isValidMAC(\"01:23:45:67:89:AB\")==true);\n    assert(isValidMAC(\"01-23-45-67-89-GH\")==false);\n    assert(isValidMAC(\"01:23:45:67:89:\")==false);\n    assert(isValidMAC(\"01:23:45:67:89:AB:CD\")==false);\n    return 0;\n}\n"}
{"language": "c++", "domain": "network", "source": "gpt4+人工筛选；源文件地址/data/xw/c++dataset/network/already/1.cpp", "prompt": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n/* \n实现转换为网络字节序\nvoid ip2nettobytes(const char *ip_str, unsigned char *netbytes)\nip_str是一个点分十进制的ip地址，netbytes是一个长度至少为4的字节数组，用来存放转化后的网际字节序的ip地址\n*/\n", "solution": "void ip2nettobytes(const char *ip_str, unsigned char *netbytes) {\n    int a[4];\n    int cnt=sscanf(ip_str, \"%d.%d.%d.%d\", &a[0], &a[1], &a[2],&a[3]);\n    if (cnt!=4) {\n        printf(\"Invalid IP address\\n\");\n        exit(1);\n    }\n    for (int i=0; i<4; i++)\n        netbytes[i]=(unsigned char)a[i];\n}\n", "test": "#include <assert.h>\n#include <string.h>\nint main(){\n    unsigned char netbytes[4];\n    const char *ip_str1=\"192.168.1.1\";\n    ip2nettobytes(ip_str1,netbytes);\n    assert(netbytes[0]==192 && netbytes[1]==168 && netbytes[2]==1 && netbytes[3]==1);\n    \n    const char *ip_str2=\"10.0.0.1\";\n    ip2nettobytes(ip_str2,netbytes);\n    assert(netbytes[0]==10 && netbytes[1]==0 && netbytes[2]==0 && netbytes[3]==1);\n\n    const char *ip_str3=\"255.255.255.0\";\n    ip2nettobytes(ip_str3,netbytes);\n    assert(netbytes[0]==255 && netbytes[1]==255 && netbytes[2]==255 && netbytes[3]==0);\n\n    const char *ip_str4=\"0.0.0.0\";\n    ip2nettobytes(ip_str4,netbytes);\n    assert(netbytes[0]==0 && netbytes[1]==0 && netbytes[2]==0 && netbytes[3]==0);\n\n    const char *ip_str5=\"127.0.0.1\";\n    ip2nettobytes(ip_str5,netbytes);\n    assert(netbytes[0]==127 && netbytes[1]==0 && netbytes[2]==0 && netbytes[3]==1);\n\n    return 0;\n}\n"}
{"language": "c++", "domain": "network", "source": "gpt4+人工筛选；源文件地址/data/xw/c++dataset/network/already/235.cpp", "prompt": "#include <sys/socket.h>\n#include <netinet/in.h>\n#include <arpa/inet.h>\n#include <cstring> \n/*函数名称：int ipToInt(char ip[])\n参数: ip[] 所转化的IPv4地址字符串，如\"192.168.1.1\"\n返回值： 返回转化后的整形ip\n功能：将 IPv4 地址转化为长整型数值\n*/\n", "solution": "int ipToInt(char ip[]){\n    in_addr_t addr = inet_addr(ip);\n    if(addr == INADDR_NONE){\n\t\treturn -1;\t\n    }\n    return (int)ntohl(addr);\n}\n", "test": "#include<assert.h>\nint main(){\n    char* ip1 = (char*)\"0.0.0.0\";\n    assert(ipToInt(ip1)==0);\n    char* ip2 = (char*)\"255.255.255.255\";\n    assert(ipToInt(ip2)==-1);\n    char* ip3 = (char*)\"192.168.1.1\";\n    assert(ipToInt(ip3)==-1062731519);\n    char* ip4 = (char*)\"1.0.0.1\";\n    assert(ipToInt(ip4)==16777217);\n    char* ip5 = (char*)\"error\";\n    assert(ipToInt(ip5)==-1);\n    return 0;\n}\n"}
{"language": "c++", "domain": "network", "source": "gpt4+人工筛选；源文件地址/data/xw/c++dataset/network/already/244.cpp", "prompt": "#include <iostream>\n#include <string>\n#include <vector>\n\nusing namespace std;\n\n/*实现IP地址的转换\n参数为一个字符串，表示十六进制的IP地址，如\"0AF50492\"\n函数的定义格式为： vector<int> convertIP(string hex)\n返回的是一个整型的容器，包含四个整数，表示十进制的IP地址。\n*/\n", "solution": "vector<int> convertIP(string hex) {\n    vector<int> res;\n    for (int i = 0; i < 4; ++i) {\n        int num = stoi(hex.substr(i * 2, 2), nullptr, 16);\n        res.push_back(num);\n    }\n    return res;\n}\n", "test": "#include <assert.h>\n\nint main(){\n    vector<int> test1 = {10, 245, 4, 146};\n    assert(convertIP(\"0AF50492\") == test1);\n    vector<int> test2 = {192, 168, 0, 1};\n    assert(convertIP(\"C0A80001\") == test2);\n    vector<int> test3 = {172, 16, 0, 2};\n    assert(convertIP(\"AC100002\") == test3);\n    vector<int> test4 = {127, 0, 0, 1};\n    assert(convertIP(\"7F000001\") == test4);\n    vector<int> test5 = {255, 255, 255, 0};\n    assert(convertIP(\"FFFFFF00\") == test5);\n    return 0;\n}\n"}
{"language": "c++", "domain": "network", "source": "gpt4+人工筛选；源文件地址/data/xw/c++dataset/network/already/4.cpp", "prompt": "#include <iostream>\n#include <cstring>\n#include <netdb.h>\n#include <arpa/inet.h>\n/*获取域名的ip地址\nstring getIPFromHostname(const char *hostname)\n输入域名输出对应IP地址\n*/\n", "solution": "std::string getIPFromHostname(const char *hostname) {\n    struct hostent *he;\n    struct in_addr **addr_list;\n    std::string ip_address;\n\n    if ((he = gethostbyname(hostname)) == NULL) {\n        return \"\"; // 返回空地址\n    }\n\n    addr_list = (struct in_addr **)he->h_addr_list;\n    //第一个地址\n    if (addr_list[0] != NULL) {\n        // inet_ntoa()将网络地址结构转换成点分十进制格式字符串\n        ip_address = inet_ntoa(*addr_list[0]);\n        return ip_address;\n    }\n\n    return \"\";\n}\n", "test": "#include<assert.h>\nint main() {\n    const char *hostname1=\"www.google.com\";\n    assert(!getIPFromHostname(hostname1).empty()); // google的域名应该能返回有效ip\n    const char *hostname2=\"abc.def.ghj\"; // IP地址应为\"\"\n    assert(getIPFromHostname(hostname2).empty());\n    const char *hostname3=\"localhost\";\n    assert(getIPFromHostname(hostname3) == \"127.0.0.1\"); // 本机的IP地址为127.0.0.1\n    const char *hostname4=\"127.0.0.1\";\n    assert(getIPFromHostname(hostname4) == \"127.0.0.1\"); // 本机的IP地址为127.0.0.1\n    const char *hostname5=\"www.baidu.com\";\n    assert(!getIPFromHostname(hostname5).empty()); // baidu的域名应该能返回有效ip\n    return 0;\n}\n"}
{"language": "c++", "domain": "network", "source": "gpt4+人工筛选；源文件地址/data/xw/c++dataset/network/already/3.cpp", "prompt": "#include <iostream>\n#include <cstring>\n#include <arpa/inet.h>\n/*调用inet.h实现从IPv4的点分十进制转换为32位网络字节序整数\nunsigned long convertToNetworkBytes(const char *ipAddress)\nipAddress是IP地址，返回转换后的网络字节序整数，错误返回-1\n*/\n", "solution": "unsigned long convertToNetworkBytes(const char *ipAddress) {\n    struct sockaddr_in sa;\n    if(inet_pton(AF_INET, ipAddress, &(sa.sin_addr)) != 1) {\n        return -1;\n    }\n    return sa.sin_addr.s_addr;\n}\n", "test": "#include<assert.h>\nint main() {\n    const char *ipAddress2=\"192.168.287.384sdsds\";\n    assert(convertToNetworkBytes(ipAddress2)==-1);\n    const char *ipAddress3=\"192.168.1\";\n    assert(convertToNetworkBytes(ipAddress3)==-1);\n    const char *ipAddress4=\"255.255.255.255\";\n    assert(convertToNetworkBytes(ipAddress4)==4294967295);//255*2^24+255*2^16+255*2^8+255=4294967295\n    const char *ipAddress5=\"0.0.0.0\";\n    assert(convertToNetworkBytes(ipAddress5)==0);\n    return 0;\n}\n"}
{"language": "c++", "domain": "network", "source": "gpt4+人工筛选；源文件地址/data/xw/c++dataset/network/already/250.cpp", "prompt": "#include <iostream>\n#include <regex>\n#include <string>\nusing namespace std;\n/*实现IP地址格式的校验的函数\n函数的定义：bool check_IP_Format(string IP);\n接收一个字符串作为输入参数，该字符串代表待校验的IP地址\n函数返回一个boolean值，如果字符串是有效的IPv4地址，则返回true，否则返回false\n*/\n", "solution": "bool check_IP_Format(string IP) {\n    regex ipPattern(\"((25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\\\\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)$\");\n\n    if (regex_match(IP, ipPattern))\n        return true;\n    else\n        return false;\n}\n", "test": "#include <assert.h>\nint main() {\n    assert(check_IP_Format(\"192.168.1.1\") == true);\n    assert(check_IP_Format(\"255.255.255.255\") == true);\n    assert(check_IP_Format(\"192.168.1.256\") == false);\n    assert(check_IP_Format(\"192.168.1.\") == false);\n    assert(check_IP_Format(\"abc.def.ghi.jkl\") == false);\n    return 0;\n}\n"}
{"language": "c++", "domain": "network", "source": "gpt4+人工筛选；源文件地址/data/xw/c++dataset/network/already/217.cpp", "prompt": "#include <iostream>\n#include <vector>\n/*\n获取子网掩码\nint[] subnetMask(int prefix)\nprefix是点击前缀长度，返回子网掩码的IP地址部分的数组\n*/\n", "solution": "std::vector<int> subnetMask(int prefix) {\n    std::vector<int> subnet_mask(4);\n    for (int i=0; i < 4; i++) {\n        if(prefix >= 8){\n            subnet_mask[i] = 255;\n            prefix -= 8;\n        }else{\n            subnet_mask[i] = 256 - (1 << (8 - prefix));\n            prefix = 0;\n        }\n    }\n    return subnet_mask;\n}\n", "test": "#include<assert.h>\nvoid check(std::vector<int> a, std::vector<int> b){\n    for(int i = 0; i<a.size(); i++)\n        assert(a[i]==b[i]);\n}\nint main() {\n    check(subnetMask(8), {255,0,0,0});\n    check(subnetMask(16), {255,255,0,0});\n    check(subnetMask(24), {255,255,255,0});\n    return 0;\n}\n"}
{"language": "c++", "domain": "network", "source": "gpt4+人工筛选；源文件地址/data/xw/c++dataset/network/already/322.cpp", "prompt": "#include <iostream>\n#include<netdb.h>\n#include<arpa/inet.h>\n#include<string.h>\n/* \n函数名：char* getIPFromHostname(char* hostname)\n功能：通过主机名(hostname)获取对应的IP地址\n参数：Char* hostname，表示网络中的主机名\n返回值：对应的IP地址，如果失败则返回NULL。\n注意：函数没有对输入进行检查，确保传入的是有效的主机名。\n*/\n", "solution": "char* getIPFromHostname(char* hostname){\n    struct hostent *he;\n    struct in_addr **addr_list;\n\n    if ((he = gethostbyname(hostname)) == NULL){\n        return NULL;\n    }\n\n    addr_list = (struct in_addr **) he->h_addr_list;\n    return inet_ntoa(*addr_list[0]);\n}\n", "test": "#include<assert.h>\nint main(){\n    char hostname2[] = \"www.baidu.com\";\n    assert(strcmp(getIPFromHostname(hostname2), \"120.232.145.144\") == 0);\n    char hostname6[] = \"non-existent.hostname\";\n    assert(getIPFromHostname(hostname6) == NULL);\n\n    return 0;\n}\n"}
{"language": "c++", "domain": "network", "source": "gpt4+人工筛选；源文件地址/data/xw/c++dataset/network/already/178.cpp", "prompt": "#include <string>\n\nusing namespace std;\n\n/*实现IP地址分类的函数\n输入字符串形式的IP地址，返回该IP地址的类别('A','B','C','D','E')。\n函数格式定义为：char IPclassify(string ip)\n输入值是一个字符串形式的IP地址（例如'192.168.1.1'）\n返回一个字符表示IP地址的类别\n*/\n", "solution": "char IPclassify(string ip) {\n    int pos1 = ip.find(\".\");\n    int pos2 = ip.find(\".\", pos1 + 1);\n    int pos3 = ip.find(\".\", pos2 + 1);\n\n    int firstPart = stoi(ip.substr(0, pos1)); \n\n    if (firstPart >= 1 && firstPart <= 126) {\n        return 'A';\n    } else if (firstPart >= 128 && firstPart <= 191) {\n        return 'B';\n    } else if (firstPart >= 192 && firstPart <= 223) {\n        return 'C';\n    } else if (firstPart >= 224 && firstPart <= 239) {\n        return 'D';\n    } else if (firstPart >= 240 && firstPart <= 255) {\n        return 'E';\n    }\n\n    return '0'; \n}\n", "test": "#include<assert.h>\nint main() {\n    assert(IPclassify(\"192.168.1.1\")=='C');\n    assert(IPclassify(\"10.0.0.1\")=='A');\n    assert(IPclassify(\"172.16.254.1\")=='B');\n    assert(IPclassify(\"2001:0db8:85a3:0000:0000:8a2e:0370:7334\")=='0');\n    assert(IPclassify(\"255.255.255.255\")=='E');\n\n    return 0;\n}\n"}
{"language": "c++", "domain": "network", "source": "gpt4+人工筛选；源文件地址/data/xw/c++dataset/network/already/139.cpp", "prompt": "#include<iostream>\n#include<string>\n\nusing namespace std;\n\n/*实现一个函数，用于验证IPv4地址的有效性。\n函数的定义为: bool verifyIP(string ip)\nip是一个字符串，代表输入的IPv4地址。\n返回一个布尔值(true/false)，表示输入的IPv4地址是否有效。*/\n", "solution": "bool verifyIP(string ip) {\n    int countDots = 0;\n    for(int i = 0; i < ip.size(); ++i) {\n        if(ip[i] == '.') {\n            countDots++;\n        } \n    }\n    if(countDots != 3) {\n        return false;\n    }\n\n    ip = ip + '.';\n    int countNum = 0;\n    string num = \"\";\n    for(int i = 0; i < ip.size(); ++i) {\n        if(ip[i] != '.') {\n            num += ip[i];\n            continue;\n        }\n        if(num.size() > 1 && num[0] == '0') {\n            return false;\n        }\n\n        int val = 0;\n        for(int j = 0; j < num.size(); ++j) {\n            if(num[j]<'0' || num[j]>'9')\n                return false; // check if there is non-numeric character in octet\n            val = val*10 + num[j] - '0';\n        }\n\n        if(val < 0 || val > 255) {\n            return false;\n        } \n\n        num = \"\";\n        countNum++;\n    }\n\n    return countNum == 4;\n}\n", "test": "#include<assert.h>\nint main() {\n    assert(verifyIP(\"192.168.0.1\") == true);\n    assert(verifyIP(\"0.0.0.0\") == true);\n    assert(verifyIP(\"255.255.255.255\") == true);\n    assert(verifyIP(\"256.1.1.1\") == false);\n    assert(verifyIP(\"123.45.67.89.0\") == false);\n    assert(verifyIP(\"123.045.067.089\") == false);\n  \n    return 0;\n}\n"}
{"language": "c++", "domain": "network", "source": "gpt4+人工筛选；源文件地址/data/xw/c++dataset/network/already/262.cpp", "prompt": "#include <stdio.h>\n#include <string.h>\n\n/*\n函数名称：void splitIP(char * ip, int * a, int * b, int * c, int * d);\n功能：将IP地址拆分为四个部分\n参数：\n    ip - 字符串形式的IP地址。 如：\"192.168.1.1\"\n    a、b、c、d - int类型的指针，用于保存拆分后的四个部分。如：192、168、1、1\n返回值：无\n注：该函数使用sscanf函数从字符串中获取四个整数。这四个整数是IP地址的四个部分，用圆点分隔。\n*/\n", "solution": "void splitIP(char * ip, int * a, int * b, int * c, int * d) {\n    sscanf(ip, \"%d.%d.%d.%d\", a, b, c, d);\n}\n", "test": "#include<assert.h>\n#include <stdio.h>\n#include <string.h>\n\nint main() \n{\n    char ip[16] = \"192.168.1.1\";\n    int a, b, c, d;\n    splitIP(ip, &a, &b, &c, &d);\n    assert(a == 192);\n    assert(b == 168);\n    assert(c == 1);\n    assert(d == 1);\n\n    char ip2[16] = \"10.0.0.1\";\n    splitIP(ip2, &a, &b, &c, &d);\n    assert(a == 10);\n    assert(b == 0);\n    assert(c == 0);\n    assert(d == 1);\n\n    char ip3[16] = \"255.255.255.0\";\n    splitIP(ip3, &a, &b, &c, &d);\n    assert(a == 255);\n    assert(b == 255);\n    assert(c == 255);\n    assert(d == 0);\n\n    char ip4[16] = \"127.0.0.1\";\n    splitIP(ip4, &a, &b, &c, &d);\n    assert(a == 127);\n    assert(b == 0);\n    assert(c == 0);\n    assert(d == 1);\n\n    char ip5[16] = \"255.255.255.255\";\n    splitIP(ip5, &a, &b, &c, &d);\n    assert(a == 255);\n    assert(b == 255);\n    assert(c == 255);\n    assert(d == 255);\n\n    return 0;\n}\n"}
{"language": "c++", "domain": "network", "source": "gpt4+人工筛选；源文件地址/data/xw/c++dataset/network/already/349.cpp", "prompt": "#include <cstring>\n#include <unistd.h>\n#include <arpa/inet.h>\n#include <iostream>\n#include <fcntl.h>\n/*\n测试本地网络连接，网络可通则返回1，否则返回-1.\nint testLocalNetwork(char *host)\nhost是要测试的服务器地址\n*/\n", "solution": "int testLocalNetwork(char *host)\n{\n\tstruct sockaddr_in sa;\n\tmemset(&sa, 0, sizeof(sa));\n\tsa.sin_family = AF_INET;\n\n\t//check for valid host\n\tif(inet_pton(AF_INET, host, &sa.sin_addr) == -1)\n\t\treturn -1;\n\n\t//create socket\n\tint s = socket(AF_INET, SOCK_STREAM, 0);\n\tif(s == -1)\n\t\treturn -1;\n\n\t//change socket to non-blocking mode\n\tfcntl(s, F_SETFL, O_NONBLOCK); \n\n\t//try to connect\n\tint c = connect(s, (struct sockaddr*)&sa, sizeof sa);\n\tif ((c == -1) && (errno == EINPROGRESS)) \n\t{\n\t\t//use select to wait up to 1 s for connect to complete\n\t\tfd_set sset;\n\t\tstruct timeval tv;\n\n\t\tFD_ZERO(&sset);\n\t\tFD_SET(s, &sset);\n\t\ttv.tv_sec = 1; \n\t\ttv.tv_usec = 0; \n\t\tif (select(s+1, NULL, &sset, NULL, &tv) != 1)\n\t\t{\n\t\t\tclose(s); \n\t\t\treturn -1;\n\t\t} \n\t} \n\telse if (c == -1) //failed to connect immediately\n\t{\n\t\tclose(s); \n\t\treturn -1;\n\t} \n\n\t//socket is connected\n\tclose(s); \n\treturn 1; \n} \n", "test": "#include<assert.h>\nint main() {\n    char host1[] = \"localhost\";\n    char host2[] = \"8.8.8.8\"; //Google Public DNS server\n    char host3[] = \"123.123.123.123\"; \n    \n    assert(testLocalNetwork(host1) == 1); \n    // assert(testLocalNetwork(host2) == 1);\n    assert(testLocalNetwork(host3) == -1);\n\n    return 0;\n}\n"}
{"language": "c++", "domain": "network", "source": "gpt4+人工筛选；源文件地址/data/xw/c++dataset/network/already/283.cpp", "prompt": "#include <iostream>\n#include <cstring>\n#include <bitset>\n/*\n将IP地址转化为二进制\nvoid ip2binary(const char* ip)\nip是IP地址，无返回值，将IP地址转化为二进制形式并在标准输出打印结果\n此函数不会改变ip指针指向的内容\n*/\n", "solution": "void ip2binary(const char* ip) {\n    int len = strlen(ip);\n    int dotCount = 0;\n    char buffer[4];\n    for(int i = 0; i < len; i++) {\n        char c = ip[i];\n        if (c == '.') {\n            buffer[dotCount] = '\\0';\n            int num = atoi(buffer);\n            std::cout << std::bitset<8>(num) << '.';\n            dotCount = 0;\n        } else {\n            buffer[dotCount++] = c;\n        }\n    }\n    buffer[dotCount] = '\\0';\n    int num = atoi(buffer);\n    std::cout << std::bitset<8>(num) << '\\n';\n}\n", "test": "#include<assert.h>\n#include<sstream>\nint main() {\n    std::stringstream ss;\n    // Backup the old streambuf\n    std::streambuf* old_buf = std::cout.rdbuf();\n    // Redirect cout to our stringstream buffer\n    std::cout.rdbuf(ss.rdbuf());\n    \n    ip2binary(\"192.168.1.1\");\n    assert(ss.str() ==  \"11000000.10101000.00000001.00000001\\n\");\n    ss.str(\"\");\n\n    ip2binary(\"255.255.255.0\");\n    assert(ss.str() ==  \"11111111.11111111.11111111.00000000\\n\");\n    ss.str(\"\");\n\n    ip2binary(\"0.0.0.0\");\n    assert(ss.str() ==  \"00000000.00000000.00000000.00000000\\n\");\n    ss.str(\"\");\n\n    std::cout.rdbuf(old_buf);\n    \n    return 0;\n}\n"}
{"language": "c++", "domain": "network", "source": "gpt4+人工筛选；源文件地址/data/xw/c++dataset/network/already/301.cpp", "prompt": "#include <iostream>\n#include <cstring>\n#include <sys/socket.h>\n#include <netinet/in.h>\n#include <arpa/inet.h>\n/*调用socket.h进行IP转数字\nunsigned long ipToNum(const char* ip)\nip是IP地址的字符串形式，如果成功返回对应的长整型数值，失败返回0\n*/\n", "solution": "unsigned long ipToNum(const char* ip){\n    unsigned long b1, b2, b3, b4;\n    unsigned long res;\n    if(sscanf(ip, \"%lu.%lu.%lu.%lu\", &b1, &b2, &b3, &b4)<4){\n        return 0;\n    }\n    if(b1>255 || b2>255 || b3>255 || b4>255){\n        return 0;\n    }\n    res = b1<<24 | b2<<16 | b3<<8 | b4;\n    return res;\n}\n", "test": "#include<assert.h>\nint main(){\n    assert(ipToNum(\"192.168.1.1\") == 3232235777UL);\n    assert(ipToNum(\"255.255.255.255\") == 4294967295UL);\n    assert(ipToNum(\"0.0.0.0\") == 0UL);\n    assert(ipToNum(\"256.1.1.1\") == 0UL);\n    return 0;\n}\n"}
{"language": "c++", "domain": "network", "source": "gpt4+人工筛选；源文件地址/data/xw/c++dataset/network/already/358.cpp", "prompt": "#include <iostream>\n#include <string>\n\nusing namespace std;\n\n/* 实现IP地址转化为二进制的函数。 \n函数的格式定义为：string ipToBinary(string ip)\nip是IP地址的字符串表示形式\n返回一个表示IP地址的二进制字符串表示形式\n*/\n", "solution": "string ipToBinary(string ip)\n{\n    string binaryIP = \"\";\n    for (int i = 0; i < ip.size(); i++){\n        int number = 0;\n        while (i < ip.size() && ip[i] != '.'){\n            number = number * 10 + (ip[i] - '0');\n            i++;\n        }\n        string binary = \"\";\n        for(int j = 0; j < 8 && number; ++j){\n            binary = (char)((number & 1) + '0') + binary;\n            number >>= 1;\n        }\n        binary.insert(binary.begin(), 8 - binary.size(), '0');\n        binaryIP += binary;\n        if (i != ip.size())\n            binaryIP += '.';\n    }\n    return binaryIP;\n}\n", "test": "#include<assert.h>\n\nint main() {\n    string str1 = \"192.168.1.1\";\n    assert(ipToBinary(str1)==\"11000000.10101000.00000001.00000001\");\n    string str2 = \"127.0.0.1\";\n    assert(ipToBinary(str2)==\"01111111.00000000.00000000.00000001\");\n    string str3 = \"255.255.255.0\";\n    assert(ipToBinary(str3)==\"11111111.11111111.11111111.00000000\");\n    string str4 = \"0.0.0.0\";\n    assert(ipToBinary(str4)==\"00000000.00000000.00000000.00000000\");\n    string str5 = \"1.1.1.1\";\n    assert(ipToBinary(str5)==\"00000001.00000001.00000001.00000001\");\n    return 0;\n}\n"}
{"language": "c++", "domain": "network", "source": "gpt4+人工筛选；源文件地址/data/xw/c++dataset/network/already/0.cpp", "prompt": "#include <iostream>\n#include <sys/socket.h>\n#include <netinet/in.h>\n#include <arpa/inet.h>\n/* 调用socket.h, netinet.h和inet.h实现将整数形式的ip地址转化为字符串形式\nchar* integerToStringIP(int ip)\nip是以整数形式表示的ip地址，返回以字符串形式表示的ip地址\n*/\n", "solution": "char* integerToStringIP(int ip) {\n    struct in_addr ip_addr;\n    ip_addr.s_addr = ip;\n    return inet_ntoa(ip_addr);\n}\n", "test": "#include<assert.h>\n#include<string.h>\nint main() {\n    int ip1 = htonl(3232235776);\n    assert(strcmp(integerToStringIP(ip1), \"192.168.1.0\") == 0);\n    int ip2 = htonl(167772160);\n    assert(strcmp(integerToStringIP(ip2), \"10.0.0.0\") == 0);\n    int ip3 = htonl(2887721770);\n    assert(strcmp(integerToStringIP(ip3), \"172.16.255.255\") == 0);\n    int ip4 = htonl(2851995647);\n    assert(strcmp(integerToStringIP(ip4), \"169.254.255.255\") == 0);\n    int ip5 = htonl(3232301055);\n    assert(strcmp(integerToStringIP(ip5), \"192.168.100.255\") == 0);\n    return 0;\n}\n"}
{"language": "c++", "domain": "network", "source": "gpt4+人工筛选；源文件地址/data/xw/c++dataset/network/already/9.cpp", "prompt": "#include <iostream>\n#include <cstdio>\n#include <sys/socket.h>\n#include <netinet/in.h>\n#include <arpa/inet.h>\n/*调用socket.h进行客户端的端口号的获取\nint getClientPort(int client_sockfd)\nclient_sockfd是客户端的套接字，如果成功返回port，失败返回-1\n*/\n", "solution": "int getClientPort(int client_sockfd){\n    struct sockaddr_in client_addr;\n    socklen_t client_addr_len = sizeof(client_addr);\n    if(getpeername(client_sockfd, (struct sockaddr*)&client_addr, &client_addr_len)<0){\n       return -1;\n    }\n    return ntohs(client_addr.sin_port);\n}\n", "test": "#include<assert.h>\nint main(){\n    int sockfd=socket(AF_INET,SOCK_STREAM,0);\n    assert(getClientPort(sockfd)==-1);//因为并未连接到任何端口，所以返回-1\n    return 0;\n}\n"}
{"language": "c++", "domain": "network", "source": "gpt4+人工筛选；源文件地址/data/xw/c++dataset/network/already/127.cpp", "prompt": "#include <stdio.h>\n#include<stdlib.h>\n#include <sys/socket.h>\n#include <arpa/inet.h>\n/* \n函数：创建一个扮演服务器角色的socket，然后将其绑定在特定的ip和端口号上。\nint setup_server(const char *ipAddress, int port)\n参数：\nipAddress:一个字符串，表示我们要绑定的ip地址。\nport:一个整数，表示我们打算绑定的端口号。\n返回值：\n成功创建并绑定socket后的文件描述符，失败返回-1。\n*/\n", "solution": "int setup_server(const char *ipAddress, int port)\n{\n    struct sockaddr_in server_addr;\n    int sockfd;\n\n    sockfd = socket(AF_INET, SOCK_STREAM, 0);\n    if(sockfd == -1)\n    {\n        perror(\"Socket creation failed\");\n        return -1;\n    }\n\n    server_addr.sin_family = AF_INET;\n    server_addr.sin_port = htons(port);\n    server_addr.sin_addr.s_addr = inet_addr(ipAddress);\n\n    if(bind(sockfd, (struct sockaddr *)&server_addr, sizeof(server_addr)) < 0)\n    {\n        perror(\"Bind failed\");\n        return -1;\n    }\n\n    if(listen(sockfd, 5) == -1)\n    {\n        perror(\"Listen failed\");\n        return -1;\n    }\n\n    return sockfd;\n}\n", "test": "#include<assert.h>\nint main()\n{\n    assert(setup_server(\"127.0.0.1\", 8000) != -1);\n    assert(setup_server(\"127.0.0.1\", 8001) != -1);\n    assert(setup_server(\"127.0.0.1\", 8002) != -1);\n    assert(setup_server(\"127.0.0.1\", 8003) != -1);\n    assert(setup_server(\"127.0.0.1\", 8004) != -1);\n    return 0;\n}\n"}
{"language": "c++", "domain": "network", "source": "gpt4+人工筛选；源文件地址/data/xw/c++dataset/network/already/367.cpp", "prompt": "#include <iostream>\n#include <cstdio>\n#include <string.h> \n#include <netdb.h>\n#include <arpa/inet.h>\n\n/*\n获取一个IP地址对应的主机名，输入是一个字符串形式的IP地址，如\"114.114.114.114\"\n函数会返回IP地址对应的主机名, 如果无法获取到主机名则返回空字符串\n*/ \n", "solution": "std::string getHostnameFromIP(std::string ip){\n    struct in_addr addr;\n    char host[1024];\n    if(!inet_aton(ip.c_str(), &addr)){\n        return \"\";\n    }\n    struct hostent *res=gethostbyaddr((const void *)&addr, sizeof(addr), AF_INET);\n    if(res==NULL){\n        return \"\";\n    }\n    strcpy(host, res->h_name);\n    return std::string(host);\n}\n", "test": "#include<assert.h>\nint main(){\n    assert(getHostnameFromIP(\"8.8.8.8\")==\"dns.google\");// Google's public DNS resolver\n    assert(getHostnameFromIP(\"127.0.0.1\")==\"localhost\");// localhost\n    assert(getHostnameFromIP(\"114.114.114.114\")==\"public1.114dns.com\");// 114 public DNS in China\n    assert(getHostnameFromIP(\"1.1.1.1\")==\"one.one.one.one\");// Cloudflare's public DNS resolver\n    return 0;\n}\n"}
{"language": "c++", "domain": "network", "source": "gpt4+人工筛选；源文件地址/data/xw/c++dataset/network/already/331.cpp", "prompt": "#include <iostream>\n#include <string>\n#include <cassert>\n\nusing namespace std;\n\n/*实现判断IP地址是否合法的函数\n输入是一个string类型的IP地址，比如\"192.168.1.1\"\n函数的格式定义为：bool isValidIP(string ip);\n返回一个bool值，表示输入的IP地址是否合法，合法IP地址是由4个0-255的数字，加3个'.'构成\n*/\n", "solution": "bool isValidIP(string ip) {\n    int dots = 0; // 统计'.'的数量，正确的IP地址应该有3个'.'\n    int nums = 0; // 统计数字的数量，正确的IP地址每个部分应有1-3个数字\n    int value = -1; // 统计每部分的值，正确的IP地址每个部分的值应在0-255范围内\n\n    for (char c : ip) {\n        if (c == '.') {\n            if (value == -1 || value > 255) {\n                return false;\n            }\n            dots++;\n            nums = 0;\n            value = -1;\n        } else if (c >= '0' && c <= '9') {\n            if (nums == 0 && value == 0) {\n                return false;\n            }\n            if (value == -1) {\n                value = 0;\n            }\n            value = value*10 + (c-'0');\n            nums++;\n        } else {\n            return false;\n        }\n    }\n\n    if (dots != 3 || nums < 1 || nums > 3 || value > 255 || value == -1) {\n        return false;\n    }\n\n    return true;\n}\n", "test": "int main() {\n    assert(isValidIP(\"192.168.1.1\")==true);\n    assert(isValidIP(\"0.0.0.0\")==true);\n    assert(isValidIP(\"255.255.255.255\")==true);\n    assert(isValidIP(\"256.256.256.256\")==false);\n    assert(isValidIP(\"192.168.1.1.1\")==false);\n\n    return 0;\n}\n"}
{"language": "c++", "domain": "network", "source": "gpt4+人工筛选；源文件地址/data/xw/c++dataset/network/already/40.cpp", "prompt": "#include<iostream>\n#include<string>\n#include<assert.h>\n\n// 校验给定字符串是否为有效的IPV4地址\nbool is_valid_ipv4(std::string ipv4);\n\n// 校验给定字符串是否为有效的IPV6地址\nbool is_valid_ipv6(std::string ipv6);\n// input_end\n\n", "solution": "    std::string::size_type start = 0;\n    std::string::size_type end = ipv4.find(\".\"); // find the position of the first \".\"\n    int count = 0;\n\n    while (end != std::string::npos) {\n        std::string block = ipv4.substr(start, end-start);\n        if (block.empty() || (block.size() > 1 && block[0] == '0') || block.size() > 3 || std::stoi(block) > 255) \n            return false;\n        start = end + 1;\n        end = ipv4.find(\".\", start);\n        count++;\n    }\n\n    std::string block = ipv4.substr(start, std::string::npos);\n    if (block.empty() || (block.size() > 1 && block[0] == '0') || block.size() > 3 || std::stoi(block) > 255) \n        return false;\n    count++;\n\n    return count == 4;\n}\n\nbool is_valid_ipv6(std::string ipv6) {\n    std::string::size_type start = 0;\n    std::string::size_type end = ipv6.find(\":\"); // find the position of the first \":\"\n    int count = 0;\n\n    while (end != std::string::npos) {\n        std::string block = ipv6.substr(start, end-start);\n        if (block.empty() || block.size() > 4) return false;\n        for(auto ch: block) {\n            if(!isdigit(ch) && (!isalpha(ch) || toupper(ch) > 'F')) return false;\n        }\n        start = end + 1;\n", "test": "\n    std::string block = ipv6.substr(start, std::string::npos);\n    if (block.empty() || block.size() > 4) return false;\n    for(auto ch: block) {\n        if(!isdigit(ch) && (!isalpha(ch) || toupper(ch) > 'F')) return false;\n    }\n    count++;\n\n    return count == 8;\n"}
{"language": "c++", "domain": "network", "source": "gpt4+人工筛选；源文件地址/data/xw/c++dataset/network/already/274.cpp", "prompt": "#include <iostream>\n\nusing namespace std;\n\n/* 实现将点分十进制IP地址转为二进制的函数\n函数定义为：string dec2binIP(string IP)\n输入是一个点分十进制的IP地址，例如\"192.168.1.1\"\n返回对应的二进制IP地址，例如\"11000000.10101000.00000001.00000001\"\n注意：每个二进制字段为8位，如果转换后不满8位，需要在前面补0，例如，\"1\"应转换为\"00000001\"\n */\n", "solution": "string dec2binIP(string IP) {\n    string result = \"\", tmp;\n    int pos = 0, pos2, n;\n    \n    for (int i = 0; i < 4; i++) {\n        pos2 = IP.find('.', pos);\n        if (pos2 == string::npos) pos2 = IP.size();\n        n = stoi(IP.substr(pos, pos2 - pos));\n        tmp = \"\";\n        while (n) {\n            tmp = to_string(n % 2) + tmp;\n            n /= 2;\n        }\n        while (tmp.size() < 8) tmp = '0' + tmp;\n        result += tmp;\n        if (i != 3) result += '.';\n        pos = pos2 + 1;\n    }\n    \n    return result;\n}\n", "test": "#include <cassert>\nint main() {\n    assert(dec2binIP(\"192.168.1.1\") == \"11000000.10101000.00000001.00000001\");\n    assert(dec2binIP(\"255.255.255.255\") == \"11111111.11111111.11111111.11111111\");\n    assert(dec2binIP(\"0.0.0.0\") == \"00000000.00000000.00000000.00000000\");\n    assert(dec2binIP(\"1.0.0.0\") == \"00000001.00000000.00000000.00000000\");\n    assert(dec2binIP(\"255.0.0.0\") == \"11111111.00000000.00000000.00000000\");\n    \n    return 0;\n}\n"}
{"language": "c++", "domain": "network", "source": "gpt4+人工筛选；源文件地址/data/xw/c++dataset/network/already/265.cpp", "prompt": "#include <iostream>\n#include <string>\n#include <cassert>\n\nusing namespace std;\n\n/*实现输入IP地址字符串，输出IP地址的网络类型（A类, B类, C类, D类, E类）的函数\n输入是一个字符串，表示需要判断的IP地址\n函数的格式定义为：string getIPClass(string ipAddr);\n返回一个字符串，表示这IP地址一般用于的网络类型\n*/\n\n", "solution": "\nstring getIPClass(string ipAddr) {\n    // 计算第一个点的位置\n    size_t pos = ipAddr.find('.');\n    // 获取第一段的IP值\n    int ip = stoi(ipAddr.substr(0, pos));\n\n    // 根据第一段的IP值判断所属网络类别\n    if (ip >=1 && ip <= 126)\n        return \"A\";\n    else if (ip >= 128 && ip <= 191)\n        return \"B\";\n    else if (ip >= 192 && ip <= 223)\n        return \"C\";\n    else if (ip >= 224 && ip <= 239)\n        return \"D\";\n    else if (ip >= 240 && ip <= 255)\n        return \"E\";\n\n    return \"Invalid IP\";\n}\n\n", "test": "int main() {\n    assert(getIPClass(\"10.0.0.1\")==\"A\");\n    assert(getIPClass(\"128.0.0.1\")==\"B\");\n    assert(getIPClass(\"192.168.1.1\")==\"C\");\n    assert(getIPClass(\"224.0.0.1\")==\"D\");\n    assert(getIPClass(\"240.0.0.1\")==\"E\");\n\n    return 0;\n}\n"}
{"language": "c++", "domain": "network", "source": "gpt4+人工筛选；源文件地址/data/xw/c++dataset/network/already/208.cpp", "prompt": "#include <string>\n\nusing namespace std;\n/* 实现一个函数，用于检查IP地址的格式是否正确，\n   函数定义格式为：bool checkIPAddress(string ipAddress)\n   ipAddress是用户在进行网络设置时输入的IP地址，\n   函数返回一个布尔值，如果IP地址的格式正确，返回真，否则返回假.\n   IP地址格式正确的话，需要满足以下条件：\n   每一部分在0-255之间，并且只包含数字和点，且没有连续的点\n*/\n\n", "solution": "bool checkIPAddress(string ipAddress) {\n    int dots = 0; \n    int len = ipAddress.length(); \n\n    if (ipAddress[len - 1] == '.')\n        return false; \n\n    ipAddress = ipAddress + \".\"; \n    int ldot = 0; \n\n    for (int i = 0; i < len + 1; i++) {\n        if (ipAddress[i] == '.') {\n            dots += 1; \n            string part = ipAddress.substr(ldot, i - ldot); \n            ldot = i + 1; \n\n            if (part.length() > 3 || part.length() == 0)\n                return false;\n            \n            if (part[0] == '0' && part.length() != 1)\n                return false;\n\n            for (int j = 0; j < part.length(); j++)\n                if (!(part[j] >= '0' && part[j] <= '9'))\n                    return false;\n            \n            if (stoi(part) < 0 || stoi(part) > 255)\n                return false; \n        }\n    }\n\n    if (dots != 4)\n        return false; \n    return true; \n}\n", "test": "#include<assert.h>\nint main() {\n    assert(checkIPAddress(\"192.168.1.1\")==true);\n    assert(checkIPAddress(\"1.0.0.1\")==true);\n    assert(checkIPAddress(\"0.0.0.0\")==true);\n    assert(checkIPAddress(\"256.168.1.1\")==false);\n    assert(checkIPAddress(\"192.168.1.1.1\")==false);\n\n    return 0;\n}\n"}
{"language": "c++", "domain": "network", "source": "gpt4+人工筛选；源文件地址/data/xw/c++dataset/network/already/256.cpp", "prompt": "#include <iostream>\n#include <sys/socket.h>\n#include <netinet/in.h>\n#include <netdb.h>\n#include <string.h>\n#include <arpa/inet.h>\n/* 调用socket.h, netinet.h, netdb.h实现转换主机名为IP地址函数\nchar* hostnameToIp(char* hostname)\nhostname是主机名，返回对应的IP地址\n*/\n", "solution": "char* hostnameToIp(char* hostname) {\n    struct hostent *he;\n    struct in_addr **addr_list;\n    if ((he = gethostbyname(hostname)) == NULL) {\n        herror(\"gethostbyname\");\n        return NULL;\n    }\n    addr_list = (struct in_addr **) he->h_addr_list;\n    return inet_ntoa(*addr_list[0]);\n}\n", "test": "#include<assert.h>\n#include<string.h>\nint main() {\n    char hostname1[] = \"localhost\";\n    assert(strcmp(hostnameToIp(hostname1), \"127.0.0.1\") == 0);\n    char hostname5[] = \"www.github.com\";\n    assert(strcmp(hostnameToIp(hostname5), \"20.205.243.166\") == 0);\n    return 0;\n}\n"}
{"language": "c++", "domain": "network", "source": "gpt4+人工筛选；源文件地址/data/xw/c++dataset/network/already/106.cpp", "prompt": "#include<iostream>\n#include<cstring>\n#include <arpa/inet.h>\n/*\n  检查一个IP地址是否为有效的IPv4或IPv6地址\n  bool isValidIPAddress(const char *ipAddress);\n  ipAddress是要检查的IP地址，返回结果表示是否为有效的IPv4或IPv6地址\n*/\n", "solution": "bool isValidIPAddress(const char* ipAddress) {\n    struct sockaddr_in sa;\n    struct sockaddr_in6 sa6;\n \n    // 尝试转换为IPv4\n    if (inet_pton(AF_INET, ipAddress, &(sa.sin_addr)) > 0)\n        return true;\n        \n    // 尝试转换为IPv6\n    if (inet_pton(AF_INET6, ipAddress, &(sa6.sin6_addr)) > 0)\n        return true;\n\n    // 如果都不匹配，则说明是无效的IP地址\n    return false;\n}\n", "test": "#include<assert.h>\nint main() {\n    assert(isValidIPAddress(\"192.168.1.1\") == true);\n    assert(isValidIPAddress(\"fe80::1ff:fe23:4567:890a\") == true);\n    assert(isValidIPAddress(\"2001:db8:3333:4444:5555:6666:7777:8888\") == true);\n    assert(isValidIPAddress(\"192.168.1.256\") == false); // Range exceeds: 256\n    assert(isValidIPAddress(\"2001::db8::1\") == false); // More than one '::'\n    return 0;\n}\n"}
{"language": "c++", "domain": "network", "source": "gpt4+人工筛选；源文件地址/data/xw/c++dataset/network/already/31.cpp", "prompt": "#include <iostream>\n#include <vector>\n#include <cassert>\n#include <string>\nusing namespace std;\n\n/*\n此程序主要用于实现计算机网络中简单的IP地址和子网掩码的相关操作\n", "solution": "  此函数处理输入的ip地址，将其转化为一个整数表示，并返回\n\n2. 子网掩码转为子网前缀长度\n  int MaskToPrefix(const string &mask)\n  此函数接收输入的子网掩码，将其转化为子网前缀长度并返回\n\n3. 根据IP地址和子网掩码获取网络地址\n  string GetNetworkAddress(const string &ip, int prefix_length)\n  此函数根据输入的IP地址和子网前缀长度，计算网络地址并返回\n*/\n// input_end\n\n// solution_start\n// Convert IP address to integer\nlong long IpToInteger(const string &ip) {\n", "test": "    for (int i = 0; i < ip.size(); i++) {\n        if (ip[i] == '.') {\n            ans = ans * 256 + tempNum;\n            tempNum = 0;\n        } else {\n            tempNum = tempNum * 10 + ip[i] - '0';\n        }\n    }\n    ans = ans * 256 + tempNum;\n"}
{"language": "c++", "domain": "network", "source": "gpt4+人工筛选；源文件地址/data/xw/c++dataset/network/already/361.cpp", "prompt": "#include <iostream>\n#include <string>\n\nusing namespace std;\n\n/*实现验证IPv4地址的函数\n 函数的格式定义为：bool validateIP(string ip)\n ip是一个表示待验证IPv4地址的字符串\n 返回一个代表验证结果的bool值（true表示合法，false表示非法）\n*/\n", "solution": "bool validateIP(string ip) {\n    int dots = 0;\n    int nums = 0;\n    string num = \"\";\n    for (int i = 0; i < ip.length(); i++) {\n        char c = ip[i];\n        if (isdigit(c)) {\n            num += c;\n            if (num.size() > 3) return false;\n        } else if (c == '.') {\n            dots++;\n            if (dots > 3) return false;\n            if (num.size() == 0) return false;\n            if (stoi(num) > 255) return false;\n            num = \"\";\n        } else {\n            return false;\n        }\n    }\n    if (dots != 3) return false;\n    if (num.size() == 0) return false;\n    if (stoi(num) > 255) return false;\n    return true;\n}\n", "test": "#include<assert.h>\nint main() {\n    assert(validateIP(\"172.16.254.1\") == true);\n    assert(validateIP(\"172.16.256.1\") == false);\n    assert(validateIP(\"172.16..1\") == false);\n    assert(validateIP(\"172.16.a.1\") == false);\n    assert(validateIP(\"172.16..\") == false);\n    return 0;\n}\n"}
{"language": "c++", "domain": "network", "source": "gpt4+人工筛选；源文件地址/data/xw/c++dataset/network/already/55.cpp", "prompt": "/*\n1. `getHostIP` 函数：用来获取主机的IP地址。\n2. `isValidIP` 函数：检查某个传入参数是否为一个有效的IP地址。\n*/\n#include <string>\n#include <iostream> \n#include <sstream>\nusing namespace std;\n\n// 获取主机IP地址\n", "solution": "// 验证一个字符串是否有效IP地址\nbool isValidIP(string ip);\n// input_end\n\n// solution_start\nstring getHostIP() {\n    // 为简洁起见，此处不实现具体代码\n    // 你可能需要使用操作系统的 API 或者一些第三方库来获取 IP 地址\n    return \"192.168.1.100\";\n}\n\nbool isValidIP(string ip) {\n    stringstream ss(ip);\n    string number;\n    int count = 0;\n    while (getline(ss, number, '.')) {\n        if (number.empty() || (number.size() > 1 && number[0] == '0') || number.size() > 3) {\n            return false;\n        }\n        for (char c : number) {\n            if (c < '0' || c > '9') {\n                return false;\n            }\n        }\n", "test": "            return false;\n        }\n        count++;\n    }\n    return count == 4;\n}\n// solution_end\n\n// test_start\n"}
{"language": "c++", "domain": "network", "source": "gpt4+人工筛选；源文件地址/data/xw/c++dataset/network/already/ip_correct.cpp", "prompt": "#include <iostream>\n#include <cstring>\n#include <arpa/inet.h>\n/*调用inet.h判断ip地址是否合法\nbool isValidIPAddress(const char *ipAddress)\nipAddress是IP地址，如果正确返回true，错误返回false\n*/\n", "solution": "bool isValidIPAddress(const char *ipAddress) {\n    struct sockaddr_in sa;\n    return inet_pton(AF_INET, ipAddress, &(sa.sin_addr)) != 0;\n}\n", "test": "#include<assert.h>\nint main() {\n    const char *ipAddress1=\"192.168.31.22\";\n    assert(isValidIPAddress(ipAddress1)==true);\n    const char *ipAddress2=\"192.168.31.28763r872t4ry384\";\n    assert(isValidIPAddress(ipAddress2)==false);\n    const char *ipAddress3=\"192.168.3\";\n    assert(isValidIPAddress(ipAddress3)==false);\n    const char *ipAddress4=\"168.31.28763r872t4ry384\";\n    assert(isValidIPAddress(ipAddress4)==false);\n    const char *ipAddress5=\"127.0.0.1\";\n    assert(isValidIPAddress(ipAddress5)==true);\n    return 0;\n}\n"}
{"language": "c++", "domain": "network", "source": "gpt4+人工筛选；源文件地址/data/xw/c++dataset/network/already/115.cpp", "prompt": "#include <string>\n#include <sstream>\n#include <vector>\n\nusing namespace std;\n\n/*实现将IP地址转换为二进制字符串的函数\n输入是一个表示IP地址的字符串\n函数的定义为：string ipToBinary(string ip)\nip - 表示IP地址的字符串，例如：\"192.168.0.1\"\n返回一个字符串，显示二进制的IP地址字符串，分割开的每部分占8位，例如：\"11000000.10101000.00000000.00000001\"\n*/\n", "solution": "vector<string> split(const string &s, char delim) {\n    vector<string> elems;\n    stringstream ss(s);\n    string item;\n    while (getline(ss, item, delim)) {\n        elems.push_back(item);\n    }\n    return elems;\n}\n\nstring intToBinaryString(int ipPart){\n    int mask = 0x80;\n    string binary = \"\";\n    for(int i = 7; i >= 0; i--){\n        if((ipPart & mask) != 0)\n            binary.append(\"1\");\n        else\n            binary.append(\"0\");\n\n        mask>>= 1;\n    }\n    return binary;\n}\n\nstring ipToBinary(string ip){\n    vector<string> ipParts = split(ip, '.');\n    string binaryIp = \"\";\n    for(int i = 0; i < 4; i++){\n        binaryIp.append(intToBinaryString(stoi(ipParts[i])));\n        if(i != 3)\n            binaryIp.append(\".\");\n    }\n    return binaryIp;\n}\n", "test": "#include<assert.h>\nint main() {\n    assert(ipToBinary(\"192.168.0.1\") == \"11000000.10101000.00000000.00000001\");\n    assert(ipToBinary(\"127.0.0.1\") == \"01111111.00000000.00000000.00000001\");\n    assert(ipToBinary(\"255.255.255.255\") == \"11111111.11111111.11111111.11111111\");\n    assert(ipToBinary(\"0.0.0.0\") == \"00000000.00000000.00000000.00000000\");\n    assert(ipToBinary(\"10.0.0.1\") == \"00001010.00000000.00000000.00000001\");\n\n    return 0;\n}\n"}
{"language": "c++", "domain": "network", "source": "gpt4+人工筛选；源文件地址/data/xw/c++dataset/network/already/310.cpp", "prompt": "#include <iostream>\n#include <string>\nusing namespace std;\n\n/* 实现IP地址分类的函数\n函数格式定义为：string checkIPAddress(string ip)\nip代表一个IPv4的地址，格式为xxx.xxx.xxx.xxx (0<=xxx<=255)\n返回IP地址对应的类别（A，B，C，D，E，Invalid）\n如果IP地址不合法，返回Invalid\n*/\n", "solution": "string checkIPAddress(string ip) {\n    int dots=0;  //计数点的数目\n    int nums[4]; //保存四段数值\n    for (int i=0; i<4; ++i)\n        nums[i] = 0;\n    for (int i=0; i<ip.size(); ++i) {\n        if (ip[i] == '.') {  //如果遇到点\n            if (dots>3 || nums[dots]>255) {\n                return \"Invalid\";\n            }\n            dots++;  //点的数目增加\n        } else if (ip[i]>='0' && ip[i]<='9') {\n            nums[dots] = nums[dots]*10 + ip[i]-'0';  //计算数值\n        } else {  //如果出现除点和数字之外的字符，返回Invalid\n            return \"Invalid\";\n        }\n    }\n    if (dots!=3 || nums[dots]>255) {  //如果点的数目不是3个，或最后一段数值超过255，返回Invalid\n        return \"Invalid\";\n    } \n    if (nums[0]>=1 && nums[0]<=126) {\n        return \"A\";\n    } else if (nums[0]>=128 && nums[0]<=191) {\n        return \"B\";\n    } else if (nums[0]>=192 && nums[0]<=223) {\n        return \"C\";\n    } else if (nums[0]>=224 && nums[0]<=239) {\n        return \"D\";\n    } else if (nums[0]>=240 && nums[0]<=255) {\n        return \"E\";\n    }\n    return \"Invalid\";\n}\n", "test": "#include<assert.h>\nint main() {\n    assert(checkIPAddress(\"10.0.0.1\") == \"A\");\n    assert(checkIPAddress(\"128.1.2.3\") == \"B\");\n    assert(checkIPAddress(\"192.10.20.30\") == \"C\");\n    assert(checkIPAddress(\"224.1.2.3\") == \"D\");\n    assert(checkIPAddress(\"240.4.2.2\") == \"E\");\n    assert(checkIPAddress(\"999.1.2.3\") == \"Invalid\");\n    return 0;\n}\n"}
{"language": "c++", "domain": "network", "source": "gpt4+人工筛选；源文件地址/data/xw/c++dataset/network/already/211.cpp", "prompt": "#include <iostream>\n#include <cstring>\n/*调用bits/stdc++.h实现MAC地址字符串到数组的转换\nvoid convertMACToArray(const char *macAddress, unsigned char *macAddressArray)\nmacAddress是MAC地址字符串，macAddressArray是返回的数组，MAC地址字符串不合法时macAddressArray全为0\n*/\n", "solution": "void convertMACToArray(const char *macAddress, unsigned char *macAddressArray) {\n    int values[6];\n    if( 6 == sscanf(macAddress, \"%x:%x:%x:%x:%x:%x\",  \n                    &values[0], &values[1], &values[2], &values[3], &values[4], &values[5]) ) {\n        for( int i = 0; i < 6; ++i ) {\n             macAddressArray[i] = (unsigned char) values[i];\n        }\n    } else {\n        for( int i = 0; i < 6; ++i ) {\n             macAddressArray[i] = 0;\n        }\n    }\n}\n", "test": "#include<assert.h>\nint main() {\n    unsigned char macAddressArray[6];\n    const char *macAddress=\"AA:BB:CC:DD:EE:FF\";\n    convertMACToArray(macAddress,macAddressArray);\n    assert(macAddressArray[0]==170);\n    assert(macAddressArray[1]==187);\n    assert(macAddressArray[2]==204);\n    assert(macAddressArray[3]==221);\n    assert(macAddressArray[4]==238);\n    assert(macAddressArray[5]==255);\n\n    const char *macAddress2=\"AA:BB:CCDD:EE:FF\"; //非合法MAC地址\n    convertMACToArray(macAddress2,macAddressArray);\n    for(int i=0;i<6;i++){\n        assert(macAddressArray[i]==0);\n    }\n\n    const char *macAddress3=\"AA:BB:CCRRRR:DD:EE:FZ\"; //非合法MAC地址\n    convertMACToArray(macAddress3,macAddressArray);\n    for(int i=0;i<6;i++){\n        assert(macAddressArray[i]==0);\n    }\n    return 0;\n}\n"}
{"language": "c++", "domain": "network", "source": "gpt4+人工筛选；源文件地址/data/xw/c++dataset/network/already/118.cpp", "prompt": "#include <iostream>\n#include <string>\n#include <regex>\n\nusing namespace std;\n\n/*实现IP地址验证的函数\n输入参数为一个字符串，表示待验证的IP地址\n函数的定义：bool isIPValid(string ipAddress);\n返回一个布尔值，如果字符串符合IP地址格式，返回true，否则返回false。\nIPv4地址是由四个数字组成，每个数字之间用一个点('.')分隔。每个数字的值范围是0-255。*/\n", "solution": "bool isIPValid(string ipAddress) {\n    regex ipPattern(\"^((25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\\\\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)$\");\n    if (regex_match(ipAddress, ipPattern)) {\n        return true;\n    } else {\n        return false;\n    }\n}\n", "test": "#include<assert.h>\nint main() {\n    assert(isIPValid(\"192.168.0.1\") == true);\n    assert(isIPValid(\"192.168.01\") == false);\n    assert(isIPValid(\"192.168.256.1\") == false);\n    assert(isIPValid(\"192.168..1\") == false);\n    assert(isIPValid(\"192.168.0.1.1\") == false);\n    return 0;\n}\n"}
{"language": "c++", "domain": "network", "source": "gpt4+人工筛选；源文件地址/data/xw/c++dataset/network/already/28.cpp", "prompt": "#include<cstring>\n/*\n此程序主要是IP地址格式校验，主要包含以下功能：\n1. IP地址格式校验函数\n    bool validateIPAddress(char *)\n    该函数接收一个字符串，若字符串符合IP地址格式则返回true，否则返回false。\n*/\n", "solution": "#include<iostream>\n#include<cstring>\nusing namespace std;\n\nbool validateIPAddress(char *ip) {\n    int dotCount = 0, numCount = 0;\n    int num = 0;\n    for(int i=0; ip[i]!='\\0'; i++) {\n        if(ip[i]=='.') {\n            if(numCount==0 or numCount>3 or num>255) \n                return false;\n            numCount = 0;\n            dotCount++;\n            num = 0;\n        } else if('0'<=ip[i] and ip[i]<='9') {\n            numCount++;\n            num = num*10 + ip[i]-'0';\n        } else {\n            return false;\n        }\n    }\n    if(dotCount!=3 or numCount==0 or numCount>3 or num>255) \n        return false;\n    return true;\n}\n", "test": "#include<assert.h>\n\nint main() {\n    assert(validateIPAddress(\"192.168.0.1\") == true);//合法ip\n    assert(validateIPAddress(\"255.255.255.255\") == true);//合法ip\n    assert(validateIPAddress(\"192.168..1\") == false);//不合法ip\n    assert(validateIPAddress(\"a.b.c.d\") == false);//不合法ip\n    assert(validateIPAddress(\"192.168.0\") == false);//不合法ip\n    return 0;\n}\n"}
{"language": "c++", "domain": "network", "source": "gpt4+人工筛选；源文件地址/data/xw/c++dataset/network/already/154.cpp", "prompt": "#include <string>\n#include <regex>\n\nusing namespace std;\n\n/*实现IP地址合法性检验\n给定字符串，判断是否为合法的IP地址。\n合法的IPv4地址由四个数字组成，每个数字的范围为0-255，数字间用'.'来分隔。\n如果是，返回true，否则返回false。\n*/\n", "solution": "bool isValidIP(string ip) {\n    regex pattern(\"^(\\\\d{1,2}|1\\\\d\\\\d|2[0-4]\\\\d|25[0-5])\\\\.(\\\\d{1,2}|1\\\\d\\\\d|2[0-4]\\\\d|25[0-5])\\\\.(\\\\d{1,2}|1\\\\d\\\\d|2[0-4]\\\\d|25[0-5])\\\\.(\\\\d{1,2}|1\\\\d\\\\d|2[0-4]\\\\d|25[0-5])$\");\n    return regex_match(ip, pattern);\n}\n", "test": "#include<assert.h>\nint main() {\n    assert(isValidIP(\"192.168.0.1\") == true);\n    assert(isValidIP(\"255.255.255.0\") == true);\n    assert(isValidIP(\"256.1.1.1\") == false);\n    assert(isValidIP(\"192.168.0.256\") == false);\n    assert(isValidIP(\"192.168.0\") == false);\n\n    return 0;\n}\n"}
{"language": "c++", "domain": "network", "source": "gpt4+人工筛选；源文件地址/data/xw/c++dataset/network/already/181.cpp", "prompt": "#include <iostream>\n#include <vector>\n#include <string>\n\nusing namespace std;\n\n/*实现一个函数，用于检验IPv4地址是否合法\nIPv4地址由四个数点分隔，每个数介于0-255之间\n函数定义: bool isValidIPv4(string ip)\nip - 输入的IP地址字符串\n如果IP地址合法，则返回true，否则返回false\n*/\n", "solution": "bool isValidIPv4(string ip) {\n    int dots = 0;\n    for(int i=0; i<ip.size(); i++) if(ip[i] == '.') dots++;\n    if(dots!=3) return false;\n    \n    dots = 0;\n    string number = \"\";\n    for(int i=0; i<ip.size(); i++) {\n        if(ip[i] == '.') {\n            if(number.size()==0 || stoi(number)>255) return false;\n            number = \"\";\n            dots++;\n        } else if(ip[i]<'0' || ip[i]>'9') return false;\n        else number += ip[i];\n    }\n    \n    if(number.size()==0 || stoi(number)>255) return false;\n    \n    return true;\n}\n", "test": "#include<assert.h>\nint main() {\n    assert(isValidIPv4(\"192.168.1.1\") == true);\n    assert(isValidIPv4(\"0.0.0.0\") == true);\n    assert(isValidIPv4(\"255.255.255.255\") == true);\n    assert(isValidIPv4(\"192.168.1.256\") == false);\n    assert(isValidIPv4(\"1.1.1\") == false);\n\n    return 0;\n}\n"}
{"language": "c++", "domain": "network", "source": "gpt4+人工筛选；源文件地址/data/xw/c++dataset/network/already/151.cpp", "prompt": "#include <iostream>\n#include <string>\n#include <sstream>\n/*\n计算给定的MAC地址的类别\nstd::string macAddressType(const std::string& address)\naddress是MAC地址，返回的是其类别:\n\"广播地址\" 如果是全FF\n\"多播地址\" 如果第一个字节的最低有效位为1\n\"单播地址\" 在所有其他情况下\n*/\n", "solution": "std::string macAddressType(const std::string& address) {\n    if (address == \"FF:FF:FF:FF:FF:FF\") {\n        return \"广播地址\";\n    }\n    \n    std::string firstByte = address.substr(0, 2);\n    int value;\n    std::stringstream ss;\n    ss << std::hex << firstByte;\n    ss >> value;\n    \n    if (value & 1) {\n        return \"多播地址\";\n    }\n\n    return \"单播地址\";\n}\n", "test": "#include<assert.h>\nint main() {\n    assert(macAddressType(\"FF:FF:FF:FF:FF:FF\") == \"广播地址\");\n    assert(macAddressType(\"01:00:5E:00:00:00\") == \"多播地址\");\n    assert(macAddressType(\"00:0a:95:9d:68:16\") == \"单播地址\");\n\n    return 0;\n}\n"}
{"language": "c++", "domain": "network", "source": "gpt4+人工筛选；源文件地址/data/xw/c++dataset/network/already/229.cpp", "prompt": "#include <iostream>\n#include <sstream>\n#include <bitset>\n\nusing namespace std;\n\n/* 实现IP地址转换的函数\n这个函数将一个点分十进制的IP地址(如：192.168.1.1)转为二进制格式。\n函数格式定义为：string IpToBinary(string ip)\nip是一个点分十进制的IP地址\n函数返回该IP的二进制表示形式\n*/\n", "solution": "std::string IpToBinary(std::string ip) {\n    std::stringstream ss(ip);\n    std::string segment;\n    std::string result;\n\n    while(getline(ss, segment, '.')) {\n        int num = std::stoi(segment);\n        std::string binary = std::bitset<8>(num).to_string();\n        result += binary + \".\";\n    }\n\n    // Remove the trailing \".\"\n    result = result.substr(0, result.size()-1);\n\n    return result;\n}\n", "test": "#include<assert.h>\nint main() {\n    assert(IpToBinary(\"192.168.0.1\") == \"11000000.10101000.00000000.00000001\");\n    assert(IpToBinary(\"127.0.0.1\") == \"01111111.00000000.00000000.00000001\");\n    assert(IpToBinary(\"255.255.255.255\") == \"11111111.11111111.11111111.11111111\");\n    assert(IpToBinary(\"0.0.0.0\") == \"00000000.00000000.00000000.00000000\");\n    assert(IpToBinary(\"10.0.0.1\") == \"00001010.00000000.00000000.00000001\");\n\n    return 0;\n}\n"}
{"language": "c++", "domain": "network", "source": "gpt4+人工筛选；源文件地址/data/xw/c++dataset/network/already/46.cpp", "prompt": "/*\n1. IP地址转换为二进制表示函数 IpToBinary：接收一个IP地址，将其转换为二进制表示形式。\n2. MAC地址转换为二进制表示函数 MacToBinary：接收一个MAC地址，将其转换为二进制表示形式。\n3. 判断是否是同一子网函数 IsSameSubnet：接收两个IP地址和子网掩码，判断它们是否属于同一子网。\n*/\n#include <iostream>\n#include <string>\n#include <bitset>\n\n// IP地址转换为二进制表示\nstd::bitset<32> IpToBinary(const std::string& ip);\n\n", "solution": "// 判断是否是同一子网\nbool IsSameSubnet(const std::string& ip1, const std::string& ip2, const std::string& mask);\n// input_end\n\n// solution_start\nstd::bitset<32> IpToBinary(const std::string& ip) {\n    int a, b, c, d;\n    sscanf(ip.c_str(), \"%d.%d.%d.%d\", &a, &b, &c, &d);\n    return (a << 24) + (b << 16) + (c << 8) + d;\n}\n\nstd::bitset<48> MacToBinary(const std::string& mac) {\n    int a, b, c, d, e, f;\n    sscanf(mac.c_str(), \"%x:%x:%x:%x:%x:%x\", &a, &b, &c, &d, &e, &f);\n    return ((long long)a << 40) + ((long long)b << 32) + (c << 24) + (d << 16) + (e << 8) + f;\n}\n", "test": "    std::bitset<32> binaryIp2 = IpToBinary(ip2);\n    std::bitset<32> binaryMask = IpToBinary(mask);\n\n    return (binaryIp1 & binaryMask) == (binaryIp2 & binaryMask);\n}\n// solution_end\n\n// test_start\n#include<assert.h>\nint main() {\n"}
{"language": "c++", "domain": "network", "source": "gpt4+人工筛选；源文件地址/data/xw/c++dataset/network/already/316.cpp", "prompt": "#include <iostream>\n#include <regex>\n#include <string>\n\nusing namespace std;\n\n/*实现IP地址检查的函数\n输入是一个字符串，该字符串是可能的IP地址\n函数的定义：bool validateIP(string IP);\n参数： string IP，想要检查的IP地址\n返回一个值，该值表示输入的字符串是否是有效的IP地址（true代表是有效的IP地址，假代表不是）\n*/\n", "solution": "bool validateIP(string IP) {\n    string regexString = \"^((25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\\\\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)$\";\n    return regex_match(IP, regex(regexString));\n}\n", "test": "#include<assert.h>\nint main() {\n    assert(validateIP(\"192.168.0.1\") == true);\n    assert(validateIP(\"255.255.255.255\") == true);\n    assert(validateIP(\"0.0.0.0\") == true);\n    assert(validateIP(\"192.168.0.256\") == false);\n    assert(validateIP(\"256.256.256.256\") == false);\n    return 0;\n}\n"}
{"language": "c++", "domain": "network", "source": "gpt4+人工筛选；源文件地址/data/xw/c++dataset/network/already/136.cpp", "prompt": "#include<iostream>\n#include<string>\n#include<regex>\n\nusing namespace std;\n/* 用于验证IP地址是否合法的函数，输入是一个字符串形式的IP地址（例如\"192.168.0.1\"），如果IP地址合法则返回true，否则返回false\n   函数格式定义为：bool isValidIP(string ip) */\n", "solution": "bool isValidIP(string ip) {\n    // 正则表达式用于匹配IP地址的格式，共有四部分，每部分为一个0-255的数字，部分之间以点分隔\n    regex ipPattern(\"^((25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\\\\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)$\");\n    return regex_match(ip, ipPattern);\n}\n", "test": "#include<assert.h>\nint main() {\n    assert(isValidIP(\"192.168.0.1\") == true);\n    assert(isValidIP(\"255.255.255.255\") == true);\n    assert(isValidIP(\"0.0.0.0\") == true);\n    assert(isValidIP(\"192.168.0.256\") == false);\n    assert(isValidIP(\"abc.def.ghi.jkl\") == false);\n    return 0;\n}\n"}
{"language": "c++", "domain": "network", "source": "gpt4+人工筛选；源文件地址/data/xw/c++dataset/network/already/334.cpp", "prompt": "#include <iostream>\n#include <string>\n#include <vector>\n/* 用于实现IPv4地址的验证，给定一个字符串，编写一个函数来验证它是不是一个有效的IPv4地址\n地址格式：被分成四个部分，通过点'.'\n每一部分的范围：0 - 255\n每一部分不能有前导0，如\"01\", \"010\"都是非法的\n函数定义为：bool validateIPv4(const string &ip) */\n", "solution": "bool validateIPv4(const std::string &ip) {\n    std::vector<std::string> nums;\n    std::string temp;\n    for (char c : ip) {\n        if (c == '.') {\n            if (temp.empty()) return false;\n            nums.push_back(temp);\n            temp.clear();\n        } else if (!isdigit(c) || (c == '0' && temp.size() == 1)) {\n            return false;\n        } else {\n            temp.push_back(c);\n        }\n    }\n    if (!temp.empty()) nums.push_back(temp);\n    if (nums.size() != 4) return false;\n    for (std::string num : nums) {\n        if (stoi(num) > 255) return false;\n    }\n    return true;\n}\n", "test": "#include <cassert>\nint main() {\n    assert(validateIPv4(\"192.168.1.1\") == true);\n    assert(validateIPv4(\"255.255.255.255\") == true);\n    assert(validateIPv4(\"192.168.1\") == false);\n    assert(validateIPv4(\"a.b.c.d\") == false);\n    return 0;\n}\n"}
{"language": "c++", "domain": "network", "source": "gpt4+人工筛选；源文件地址/data/xw/c++dataset/network/already/5.cpp", "prompt": "#include <stdio.h>\n#include<stdlib.h>\n#include <sys/types.h>\n#include <sys/socket.h>\n#include <netinet/in.h>\n#include <arpa/inet.h>\n\n/*创建套接字并设为非阻塞状态\nint setup_socket(const char *ipAddress, const char *port)\nipAddress是IP地址，port是端口号，成功返回套接字描述符，失败返回-1\n*/\n", "solution": "int setup_socket(const char *ipAddress, const char *port) \n{\n    struct sockaddr_in server_addr;\n    int sockfd;\n\n    sockfd = socket(AF_INET, SOCK_STREAM, 0);\n    if(sockfd == -1) \n    {\n        perror(\"Could not create socket\");\n        return -1;\n    }\n\n    server_addr.sin_family = AF_INET;\n    server_addr.sin_port = htons(atoi(port));\n    server_addr.sin_addr.s_addr = inet_addr(ipAddress);\n\n    if(bind(sockfd, (struct sockaddr *)&server_addr, sizeof(server_addr)) < 0)\n    {\n        perror(\"Bind failed\");\n        return -1;\n    }\n\n    if(listen(sockfd, 5) == -1)\n    {\n        perror(\"Listen failed\");\n        return -1;\n    }\n\n    return sockfd;\n}\n", "test": "#include<assert.h>\nint main() \n{\n    assert(setup_socket(\"127.0.0.1\", \"80\") != -1);\n    assert(setup_socket(\"127.0.0.1\", \"9999\") != -1);\n    assert(setup_socket(\"127.0.0.1\", \"81\") != -1);\n    return 0;\n}\n"}
{"language": "c++", "domain": "network", "source": "gpt4+人工筛选；源文件地址/data/xw/c++dataset/network/already/280.cpp", "prompt": "#include <iostream>\n#include <bitset>\n#include <math.h>\n/*调用bitset库将一个二进制字符串转换为十进制。 \nint BinaryToDecimal(std::string binaryString)\nbinaryString是二进制字符串，返回十进制整数。\n*/\n", "solution": "int BinaryToDecimal(std::string binaryString) {\n    size_t size = binaryString.size();\n    int decimal = 0;\n    for (size_t i = 0; i < size; i++) {\n        if (binaryString[i] == '1') {\n            decimal += pow(2, size - 1 - i);\n        }\n    }\n    return decimal;\n}\n", "test": "#include<assert.h>\nint main() {\n    assert(BinaryToDecimal(\"1101\")==13);\n    assert(BinaryToDecimal(\"1010\")==10);\n    assert(BinaryToDecimal(\"11111111\")==255);\n    assert(BinaryToDecimal(\"10000000\")==128);\n    assert(BinaryToDecimal(\"00000001\")==1);\n    return 0;\n}\n"}
{"language": "c++", "domain": "network", "source": "gpt4+人工筛选；源文件地址/data/xw/c++dataset/network/already/100.cpp", "prompt": "#include <arpa/inet.h>\n/*检查ip 地址是否是有效的 \nbool validIPAddress(const char *ipAddress) \n输入一个ip地址字符串，返回一个bool表示是否是一个有效的ip地址\n*/\n", "solution": "bool validIPAddress(const char *ipAddress) {\n    struct sockaddr_in sa;\n    // inet_pton函数能够处理ipv4和ipv6\n    int result = inet_pton(AF_INET, ipAddress, &(sa.sin_addr));\n    return result != 0;\n}\n", "test": "#include<assert.h>\nint main() {\n    const char *ipAddress1 = \"192.168.1.1\";\n    assert(validIPAddress(ipAddress1) == true); \n    const char *ipAddress2 = \"255.255.255.255\";\n    assert(validIPAddress(ipAddress2) == true); \n    const char *ipAddress3 = \"255.256.255.255\";\n    assert(validIPAddress(ipAddress3) == false); \n    const char *ipAddress4 = \"19216811\";\n    assert(validIPAddress(ipAddress4) == false); \n    const char *ipAddress5 = \"0.0.0.0\";\n    assert(validIPAddress(ipAddress5) == true); \n    return 0;\n}\n"}
{"language": "c++", "domain": "network", "source": "gpt4+人工筛选；源文件地址/data/xw/c++dataset/network/already/22.cpp", "prompt": "#include <iostream>\n#include <vector>\nusing namespace std;\n\n/* \n此程序通过向量方法模拟到一个数据包从源IP到目标IP的路由过程。\n函数包括：\n1. void insertRoute(vector<pair<int, int>>& routingTable, int sourceIP, int destinationIP)\n   这个函数将一条新的路由插入到路由表中。它接收一个路由表（作为一个整数对的向量表示），一个源IP和一个目标IP，所有的IP都是整数表示形式。\n\n2. int findRoute(vector<pair<int, int>>& routingTable, int sourceIP, int destinationIP)\n   这个函数用来在路由表中查找从源IP到目标IP的路由。它接收一个路由表（作为一个整数对的向量表示），一个源IP和一个目标IP，所有的IP都是整数表示形式。如果找到了相应的路由，它会返回目标IP，否则返回-1表示路由不存在。\n*/\n", "solution": "void insertRoute(vector<pair<int, int>>& routingTable, int sourceIP, int destinationIP) {\n    // 插入新的路由到路由表\n    routingTable.push_back(make_pair(sourceIP, destinationIP));\n}\n\nint findRoute(vector<pair<int, int>>& routingTable, int sourceIP, int destinationIP) {\n    // 查找路由\n    for (auto route : routingTable) {\n        if (route.first == sourceIP && route.second == destinationIP) {\n            // 找到路由，返回目标IP\n            return destinationIP;\n        }\n    }\n    // 没有找到路由，返回-1\n    return -1;\n}\n", "test": "#include<assert.h>\nint main() {\n    vector<pair<int, int>> routingTable;\n\n    // 插入路由\n    insertRoute(routingTable, 192, 168);\n    insertRoute(routingTable, 172, 16);\n\n    //先插入的路由，肯定被找到\n    assert(findRoute(routingTable, 192, 168) == 168);\n\n    //没有插入的路由，无法查找到\n    assert(findRoute(routingTable, 10, 0) == -1);\n    \n    //找到路由，返回目标IP\n    assert(findRoute(routingTable, 172, 16) == 16);\n    \n    //错误的源IP无法查找到路由\n    assert(findRoute(routingTable, 199, 168) == -1);\n    \n    //错误的目标IP无法查找到路由\n    assert(findRoute(routingTable, 192, 169) == -1);\n\n    return 0;\n}\n"}
{"language": "c++", "domain": "network", "source": "gpt4+人工筛选；源文件地址/data/xw/c++dataset/network/already/259.cpp", "prompt": "#include <stdio.h>\n#include <string.h>\n#include <sys/socket.h>\n#include <netinet/in.h>\n#include <arpa/inet.h>\n\n/* \n将IP地址从点数格式转换为二进制格式的函数\n函数原型：int ip_convert(const char *ip, struct in_addr *addr)\n其中，ip是点数格式的ip地址，addr是转换后存放ip地址的结构体\n如果成功返回1，失败返回0\n*/\n", "solution": "int ip_convert(const char *ip, struct in_addr *addr) \n{\n    if(inet_aton(ip, addr) == 0) \n    {\n        fprintf(stderr, \"Invalid IP address: %s\\n\", ip);\n        return 0;\n    }\n    return 1;\n}\n", "test": "#include<assert.h>\nint main() \n{\n    struct in_addr addr;\n    assert(ip_convert(\"127.0.0.1\", &addr) == 1);\n    assert(ip_convert(\"255.255.255.0\", &addr) == 1);\n    assert(ip_convert(\"192.168.1.1\", &addr) == 1);\n    assert(ip_convert(\"172.16.0.2\", &addr) == 1);\n    assert(ip_convert(\"10.0.0.1\", &addr) == 1);\n\n    return 0;\n}\n"}
{"language": "c++", "domain": "network", "source": "gpt4+人工筛选；源文件地址/data/xw/c++dataset/network/already/145.cpp", "prompt": "#include <iostream>\n#include <cstring>\n#include <arpa/inet.h>\n/*调用inet.h实现从32位网络字节序整数转换为IPv4的点分十进制\nconst char* convertToIPAddress(unsigned long networkBytes)\nnetworkBytes是网络字节序整数，返回转换后的IPv4地址，错误返回NULL\n*/\n", "solution": "const char* convertToIPAddress(unsigned long networkBytes) {\n    struct sockaddr_in sa;\n    sa.sin_addr.s_addr = networkBytes;\n    char *ipAddress = new char[INET_ADDRSTRLEN];\n    if(inet_ntop(AF_INET, &(sa.sin_addr), ipAddress, INET_ADDRSTRLEN) == NULL) {\n        return NULL;\n    }\n    return ipAddress;\n}\n", "test": "#include<assert.h>\n#include<cstring>\nint main() {\n    unsigned long networkBytes=4294967295;\n    assert(strcmp(convertToIPAddress(networkBytes), \"255.255.255.255\")==0);\n    networkBytes=0;\n    assert(strcmp(convertToIPAddress(networkBytes), \"0.0.0.0\")==0);\n    return 0;\n}\n"}
{"language": "c++", "domain": "network", "source": "gpt4+人工筛选；源文件地址/data/xw/c++dataset/network/already/289.cpp", "prompt": "#include <iostream>\n#include <string>\n#include <sstream>\n#include <vector>\n\nusing namespace std;\n\n/* 实现一个简单的IPv4地址验有效性函数\n函数的格式定义为：bool isValidIPv4(string str)\nstr 是一个字符串，用点分隔的四个整数表示的IPv4地址\n如果这个IPv4地址是有效的，则返回true，否则返回false\n有效的IPv4地址要求：\n1. 地址由四个数字组成，每个数字之间用“.”号隔开。\n2. 每个数字的范围为0-255。\n3. 不能有前导零，如\"01.0.0.0\"不是有效的IPv4地址。\n注意，本程序不判断特殊地址如回环地址或广播地址是否合法。\n*/\n", "solution": "bool isValidIPv4(string str) {\n    vector<string> nums;\n    stringstream ss(str);\n    string num;\n    while (getline(ss, num, '.')) {\n        nums.push_back(num);\n    }\n    if (nums.size() != 4) {\n        return false;\n    }\n    for (const auto &num : nums) {\n        if (num.empty() || (num.size() > 1 && num[0] == '0') || num.size() > 3) {\n            return false;\n        }\n        for (char c : num) {\n            if (!isdigit(c)) {\n                return false;\n            }\n        }\n        int val = stoi(num);\n        if (val < 0 || val > 255) {\n            return false;\n        }\n    }\n    return true;\n}\n", "test": "#include<assert.h>\nint main() {\n    assert(isValidIPv4(\"192.168.1.1\") == true);\n    assert(isValidIPv4(\"0.0.0.0\") == true);\n    assert(isValidIPv4(\"255.255.255.255\") == true);\n    assert(isValidIPv4(\"1.1.1.1\") == true);\n    assert(isValidIPv4(\"256.0.0.0\") == false);\n    assert(isValidIPv4(\"01.0.0.0\") == false);\n    assert(isValidIPv4(\"1.0.0\") == false);\n    assert(isValidIPv4(\"1.0.0.0.0\") == false);\n    assert(isValidIPv4(\".1.2.3.4\") == false);\n    assert(isValidIPv4(\"1.2.3.4.5\") == false);\n\n    return 0;\n}\n"}
{"language": "c++", "domain": "network", "source": "gpt4+人工筛选；源文件地址/data/xw/c++dataset/network/already/253.cpp", "prompt": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n/* \n检查IP地址是否合法\n定义一个函数check_ip,参数是一个点分十进制表示的字符串,函数返回1表示该ip是合法的，返回0表示ip地址不合法。\n*/\n\n", "solution": "int check_ip(const char *ip_str) {\n    int a[4];\n    int cnt=sscanf(ip_str, \"%d.%d.%d.%d\", &a[0], &a[1], &a[2],&a[3]);\n    if (cnt!=4) {\n        return 0;\n    }\n    for (int i=0; i<4; i++)\n        if(a[i]<0 || a[i]>255) return 0;\n    return 1;\n}\n", "test": "#include <assert.h>\n#include <string.h>\nint main(){\n    const char *ip_str1=\"192.168.1.1\";\n    int res=check_ip(ip_str1);\n    assert(res==1);\n    \n    const char *ip_str2=\"290.0.0.1\";\n    res=check_ip(ip_str2);\n    assert(res==0);\n\n    const char *ip_str3=\"255.255.255.0\";\n    res=check_ip(ip_str3);\n    assert(res==1);\n\n    const char *ip_str4=\"1.1.1.\";\n    res=check_ip(ip_str4);\n    assert(res==0);\n\n    const char *ip_str5=\"127.0..1\";\n    res=check_ip(ip_str5);\n    assert(res==0);\n\n    return 0;\n}\n"}
{"language": "c++", "domain": "network", "source": "gpt4+人工筛选；源文件地址/data/xw/c++dataset/network/already/298.cpp", "prompt": "#include <iostream>\n#include <netdb.h>\n#include <unistd.h>\n#include <sys/socket.h>\n#include <netinet/in.h>\n#include <arpa/inet.h>\n/*获取IP地址的主机名\nstring getHostnameFromIP(const std::string &ip)\n输入IP地址，输出对应的主机名\n*/\n", "solution": "std::string getHostnameFromIP(const std::string &ip) {\n    struct in_addr ip_addr;\n    struct hostent *host_entry;\n    inet_aton(ip.c_str(), &ip_addr);\n    host_entry = gethostbyaddr(&ip_addr, sizeof(ip_addr), AF_INET);\n    if(host_entry != NULL)\n      return std::string (host_entry->h_name);\n    else\n      return \"\";\n}\n", "test": "#include<assert.h>\nint main() {\n    std::string ip1=\"172.217.160.14\";\n    assert(!getHostnameFromIP(ip1).empty()); // google的IP应该能返回有效hostname\n    std::string ip2=\"255.255.255.255\"; // 无效的IP地址应为\"\"\n    assert(getHostnameFromIP(ip2).empty());\n    std::string ip3=\"127.0.0.1\";\n    assert(getHostnameFromIP(ip3) == \"localhost\"); // 本机的IP地址对应的主机名应为localhost\n    std::string ip4=\"0.0.0.0\";\n    assert(getHostnameFromIP(ip4).empty()); // 无效的IP地址应为\"\"\n    std::string ip5=\"202.108.22.5\";\n    assert(!getHostnameFromIP(ip5).empty()); // baidu的IP应该能返回有效hostname\n    return 0;\n}\n"}
{"language": "c++", "domain": "network", "source": "gpt4+人工筛选；源文件地址/data/xw/c++dataset/network/already/148.cpp", "prompt": "#include <iostream>\n#include <cstring>\n#include <arpa/inet.h>\n/*调用inet_ntoa将网络地址转换为点分十进制格式，用函数char *inetNtoa(struct in_addr in)\nin 是需要转换的网络地址。如果转换成功，则返回所指向的字符串。否则返回NULL。\n*/\n", "solution": "char *inetNtoa(struct in_addr in) {\n    return inet_ntoa(in);\n}\n", "test": "#include<assert.h>\nint main() {\n    struct in_addr in1;\n    in1.s_addr = inet_addr(\"192.168.31.22\");\n    assert(strcmp(inetNtoa(in1),\"192.168.31.22\")==0);\n    struct in_addr in2;\n    in2.s_addr = inet_addr(\"0.0.0.0\");\n    assert(strcmp(inetNtoa(in2),\"0.0.0.0\")==0);\n    struct in_addr in3;\n    in3.s_addr = inet_addr(\"255.255.255.255\");\n    assert(strcmp(inetNtoa(in3),\"255.255.255.255\")==0);\n    struct in_addr in4;\n    in4.s_addr = inet_addr(\"127.0.0.1\");\n    assert(strcmp(inetNtoa(in4),\"127.0.0.1\")==0);\n    struct in_addr in5;\n    in5.s_addr = inet_addr(\"128.128.128.128\");\n    assert(strcmp(inetNtoa(in5),\"128.128.128.128\")==0);\n    return 0;\n}\n"}
{"language": "c++", "domain": "network", "source": "gpt4+人工筛选；源文件地址/data/xw/c++dataset/network/already/286.cpp", "prompt": "#include <iostream>\n#include <sstream>\n#include <vector>\n\nusing namespace std;\n\n/*实现将IP地址从字符串形式转换为整数形式\nIP地址的字符串形式是“x.x.x.x”，其中x是一个字节的值（0-255）。\n整数形式是将每个字节的值连接成一个32位整数。\n例如，IP地址\"192.168.1.1\"的整数形式是3232235777。\n*/\n", "solution": "long ipToLong(string ipAddress) {\n  int dot1 = ipAddress.find('.'); // find the first dot\n  int dot2 = ipAddress.find('.', dot1 + 1); // find the second dot\n  int dot3 = ipAddress.find('.', dot2 + 1); // find the third dot\n\n  long ip1 = stoi(ipAddress.substr(0, dot1));\n  long ip2 = stoi(ipAddress.substr(dot1 + 1, dot2 - dot1 - 1));\n  long ip3 = stoi(ipAddress.substr(dot2 + 1, dot3 - dot2 - 1));\n  long ip4 = stoi(ipAddress.substr(dot3 + 1));\n\n  return (ip1 << 24) + (ip2 << 16) + (ip3 << 8) + ip4; \n}\n", "test": "#include <cassert>\nint main() {\n  assert(ipToLong(\"192.168.1.1\") == 3232235777);\n  assert(ipToLong(\"127.0.0.1\") == 2130706433);\n  assert(ipToLong(\"0.0.0.0\") == 0);\n  assert(ipToLong(\"255.255.255.255\") == 4294967295);\n  // assert(ipToLong(\"172.16.254.1\") == 2887715841);\n\n  return 0;\n}\n"}
{"language": "c++", "domain": "network", "source": "gpt4+人工筛选；源文件地址/data/xw/c++dataset/network/already/238.cpp", "prompt": "#include<iostream>\n\n/* \n 检查一个字符串是否符合IP地址格式\n bool validateIPAddress(std::string ipAddress);\n ipAdress是输入的IP地址字符串，返回true表示符合IP地址格式，否则返回false\n*/\n\n", "solution": "#include <regex>\nbool validateIPAddress(std::string ipAddress) {\n    // IPV4 pattern\n    std::regex ipv4Pattern(\n        \"^((25[0-5]\"\n        \"|2[0-4][0-9]\"\n        \"|[01]?[0-9][0-9]?)\\\\.){3}\"\n        \"(25[0-5]\"\n        \"|2[0-4][0-9]\"\n        \"|[01]?[0-9][0-9]?)$\");\n\n    // IPV6 pattern\n    std::regex ipv6Pattern(\n        \"^(\"\n        \"(?:[A-Fa-f0-9]{1,4}:){7}[A-Fa-f0-9]{1,4}\"\n        \"|(?:[A-Fa-f0-9]{1,4}:){1,6}:[A-Fa-f0-9]{1,4}\"\n        \"|(?:[A-Fa-f0-9]{1,4}:){1,5}(?::[A-Fa-f0-9]{1,4}){1,2}\"\n        \"|(?:[A-Fa-f0-9]{1,4}:){1,4}(?::[A-Fa-f0-9]{1,4}){1,3}\"\n        \"|(?:[A-Fa-f0-9]{1,4}:){1,3}(?::[A-Fa-f0-9]{1,4}){1,4}\"\n        \"|(?:[A-Fa-f0-9]{1,4}:){1,2}(?::[A-Fa-f0-9]{1,4}){1,5}\"\n        \"|[A-Fa-f0-9]{1,4}:(?:(?::[A-Fa-f0-9]{1,4}){1,6})\"\n        \"|:(?:(?::[A-Fa-f0-9]{1,4}){1,7}|:)\"\n        \"|fe80:(?::[A-Fa-f0-9]{0,4}){0,4}%[0-9a-fA-F]{1,}\"\n        \"|::(ffff(?::0{1,4}){0,1}:){0,1}\"\n        \"((25[0-5]\"\n        \"|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\\\\.){3}\"\n        \"(25[0-5]\"\n        \"|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\"\n        \"|([0-9a-fA-F]{1,4}::)\"\n        \"(?:(?::[0-9a-fA-F]{1,4}){1,5})\"\n        \":)\"\n        \"$\");\n\n    if (std::regex_match(ipAddress, ipv4Pattern)\n        || std::regex_match(ipAddress, ipv6Pattern))\n        return true;\n    return false;\n}\n", "test": "#include<assert.h>\nint main() {\n    assert(validateIPAddress(\"192.168.31.22\")==true);\n    assert(validateIPAddress(\"2404:6800:4008:801::2004\")==true);\n    assert(validateIPAddress(\"192.168\")==false);\n    assert(validateIPAddress(\"168.31\")==false);\n    assert(validateIPAddress(\"2001::\")==false);\n    return 0;\n}\n"}
{"language": "c++", "domain": "network", "source": "gpt4+人工筛选；源文件地址/data/xw/c++dataset/network/already/10.cpp", "prompt": "#include <iostream>\n#include <map>\n#include <string>\nusing namespace std;\n\n/*实现一个模拟ARP协议的类\n* ARP(地址解析协议)是通过主机IP地址获取其MAC地址的一个TCP/IP协议\n* 当一个网络程序拥有目标IP地址并希望发送一个数据包给它，它就会向所有机器发送一个ARP请求\n* 请求的内容就是“如果这是你的IP地址，那么请告诉我你的MAC地址”\n* 当拥有相应IP地址的机器收到请求后就会返回一个ARP响应，以此告诉请求发送者它的MAC地址\n*/\n\nclass ArpProtocolSimulator {\npublic:\n    /*记录一台计算机的IP地址和MAC地址*/\n    void AddComputer(const string& ipAddress, const string& macAddress);\n\n    /*发送一个ARP请求，返回收到ARP响应中的MAC地址，如果没有收到ARP响应则返回\"Unknown\"*/\n    string RequestMacAddress(const string& ipAddress);\n\nprivate:\n    map<string, string> ipMacPairs; /*记录IP地址和MAC地址对应关系的map，key是IP地址，value是MAC地址*/\n};\n", "solution": "void ArpProtocolSimulator::AddComputer(const string& ipAddress, const string& macAddress) {\n    ipMacPairs[ipAddress] = macAddress;\n}\n\nstring ArpProtocolSimulator::RequestMacAddress(const string& ipAddress) {\n    if (ipMacPairs.find(ipAddress) != ipMacPairs.end()) {\n        return ipMacPairs[ipAddress];\n    }\n    return \"Unknown\";\n}\n", "test": "#include<assert.h>\nint main() {\n    ArpProtocolSimulator arpSimulator;\n    arpSimulator.AddComputer(\"192.168.1.1\", \"00:0a:95:9d:68:16\");\n    arpSimulator.AddComputer(\"192.168.1.2\", \"00:0a:95:9d:68:17\");\n    arpSimulator.AddComputer(\"192.168.1.3\", \"00:0a:95:9d:68:18\");\n    assert(arpSimulator.RequestMacAddress(\"192.168.1.1\")==\"00:0a:95:9d:68:16\");\n    assert(arpSimulator.RequestMacAddress(\"192.168.1.2\")==\"00:0a:95:9d:68:17\");\n    assert(arpSimulator.RequestMacAddress(\"192.168.1.3\")==\"00:0a:95:9d:68:18\");\n    assert(arpSimulator.RequestMacAddress(\"192.168.1.4\")==\"Unknown\");\n\n    return 0;\n}\n"}
{"language": "c++", "domain": "network", "source": "gpt4+人工筛选；源文件地址/data/xw/c++dataset/network/already/268.cpp", "prompt": "#include<iostream>\n#include<string>\n/* 实现MAC地址的验证，MAC地址由六组2位16进制数字组成，每组之间用冒号分隔。如：A1:B2:C3:D4:E5:F6\n通过输入的MAC地址能判断格式是否正确，若正确返回true，否则返回false。\n函数格式定义为：bool isValidMacAddress(std::string macAddress) */\n", "solution": "bool isValidMacAddress(std::string macAddress) {\n    int len = macAddress.length();\n    if(len != 17)\n        return false;\n    for(int i = 0; i < len; i++) {\n        if(i % 3 != 2 && (!(macAddress[i] >= '0' && macAddress[i] <= '9') && !(macAddress[i] >= 'a' && macAddress[i] <= 'f') && !(macAddress[i] >= 'A' && macAddress[i] <= 'F')))\n            return false;\n        if(i % 3 == 2 && macAddress[i] != ':')\n            return false;\n    }\n    return true;\n}\n", "test": "#include<assert.h>\nint main() {\n    assert(isValidMacAddress(\"A1:B2:C3:D4:E5:F6\") == true);\n    assert(isValidMacAddress(\"00:0c:29:9a:3b:c8\") == true);\n    assert(isValidMacAddress(\"Z1:B2:C3:D4:E5:F6\") == false);\n    assert(isValidMacAddress(\"00:0c:29:9a:3b\") == false);\n    assert(isValidMacAddress(\"00:0c:299a:3bc8\") == false);\n    return 0;\n}\n"}
{"language": "c++", "domain": "network", "source": "gpt4+人工筛选；源文件地址/data/xw/c++dataset/network/already/8.cpp", "prompt": "#include<iostream>\n#include<netinet/in.h>\n#include <arpa/inet.h>\n/* \n 调用netinet/in.h转换IP地址位数\n 获取一个IP地址的位数\n int getIPAddressBitNumber(const char *ipAddress);\n ipAddress是IP地址，返回IP地址的位数\n*/\n", "solution": "int getIPAddressBitNumber(const char *ipAddress) {\n    struct in6_addr addr;\n    if (inet_pton(AF_INET, ipAddress, &addr) > 0) {\n        // IPV4\n        return 32;\n    } else if (inet_pton(AF_INET6, ipAddress, &addr) > 0) {\n        // IPV6\n        return 128;\n    }\n    throw std::runtime_error(\"invalid ip address\");\n}\n", "test": "#include<assert.h>\nint main() {\n    const char *ipAddress1=\"192.168.31.22\";\n    assert(getIPAddressBitNumber(ipAddress1)==32);\n    const char *ipAddress2=\"2404:6800:4008:801::2004\";\n    assert(getIPAddressBitNumber(ipAddress2)==128);\n    const char *ipAddress3=\"192.168\";\n    try {\n        getIPAddressBitNumber(ipAddress3);\n        assert(false);\n    } catch (...) {\n        assert(true);\n    }\n    const char *ipAddress4=\"168.31\";\n    try {\n        getIPAddressBitNumber(ipAddress4);\n        assert(false);\n    } catch (...) {\n        assert(true);\n    }\n    const char *ipAddress5=\"2001::\";\n    assert(getIPAddressBitNumber(ipAddress5)==128);\n    return 0;\n}\n"}
{"language": "c++", "domain": "network", "source": "gpt4+人工筛选；源文件地址/data/xw/c++dataset/network/already/34.cpp", "prompt": "#include <iostream>\n#include <vector>\nusing namespace std;\n\n/*\n此程序主要用于实现一些计算机网络相关的功能：\n\n1. IP地址到整数的转化\nunsigned int IpToInt(const string &ip)\n", "solution": "string IntToIp(unsigned int num)\n此函数将一个32位整数转化为IP地址。\n\n3. 确认地址是否为广播地址\nbool IsBroadcastIp(const string &ip)\n此函数判断一个IP地址是否为广播地址。\n */\n\n// input_end\n\n// solution_start\n", "test": "    while(end != string::npos){\n        res = (res << 8) + stoi(ip.substr(start, end - start));\n        start = end + 1;\n        end = ip.find('.', start);\n    }\n    res = (res << 8) + stoi(ip.substr(start, ip.length() - start));\n    return res;\n}\n\nstring IntToIp(unsigned int num){\n    return to_string(num>>24) + '.' + to_string((num & 0x00ffffff)>>16) + '.' + to_string((num & 0x0000ffff)>>8) + '.' + to_string(num & 0x000000ff);\n}\n\nbool IsBroadcastIp(const string &ip){\n    unsigned int num = IpToInt(ip);\n    return (num == 0xffffffff);  // 255.255.255.255 is the broadcast IP address\n}\n// solution_end\n\n// test_start\n#include<assert.h>\nint main() {\n    assert(IpToInt(\"192.168.0.1\") == 3232235521);\n    assert(IpToInt(\"255.255.255.255\") == 4294967295);\n"}
{"language": "c++", "domain": "network", "source": "gpt4+人工筛选；源文件地址/data/xw/c++dataset/network/already/43.cpp", "prompt": "/*\n实现了IPv4地址到IPv6地址的转换\n*/\n#include <iostream>\n#include <assert.h>\n#include <string>\n#include <sstream>\n#include <array>\n#include <vector>\n", "solution": "// input_end\n\n// solution_start\nstd::string ipv4Toipv6(std::string ipv4) {\n    std::stringstream ss(ipv4);\n    std::vector<int> ipv4Addr;\n    std::string ipv6Addr = \"0:0:0:0:0:FFFF:\";\n    std::string token;\n    while (std::getline(ss, token, '.')) {\n        ipv4Addr.push_back(std::stoi(token));\n    }\n", "test": "        if (i == 0) {\n            ipv6Addr += buf;\n            ipv6Addr += \":\";\n        }\n        else {\n            ipv6Addr += buf;\n        }\n    }\n    return ipv6Addr;\n}\n// solution_end\n\n// test_start\nint main() {\n    assert(ipv4Toipv6(\"192.168.1.1\") == \"0:0:0:0:0:FFFF:c0a8:101\");\n    assert(ipv4Toipv6(\"0.0.0.0\") == \"0:0:0:0:0:FFFF:0:0\");\n    assert(ipv4Toipv6(\"10.0.0.1\") == \"0:0:0:0:0:FFFF:a00:1\");\n    assert(ipv4Toipv6(\"172.16.254.1\") == \"0:0:0:0:0:FFFF:ac10:fe01\");\n    assert(ipv4Toipv6(\"127.0.0.1\") == \"0:0:0:0:0:FFFF:7f00:1\");\n    return 0;\n}\n// test_end"}
{"language": "c++", "domain": "network", "source": "gpt4+人工筛选；源文件地址/data/xw/c++dataset/network/already/16.cpp", "prompt": "#include <iostream>\n#include <sstream>\n#include <string>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\n/*\n* 实现一个简单的IP地址检查器\n*/\n\nclass IPAddressChecker {\npublic:\n    bool isValidIpAddress(string ip);\n\nprivate:\n    vector<string> split(const string &s, char delimiter);\n};\n\n", "solution": "\nvector<string> IPAddressChecker::split(const string &s, char delimiter) {\n    vector<string> tokens;\n    string token;\n    istringstream tokenStream(s);\n    while (getline(tokenStream, token, delimiter)) {\n        tokens.push_back(token);\n    }\n    return tokens;\n}\n\nbool IPAddressChecker::isValidIpAddress(string ip) {\n    vector<string> parts = split(ip, '.');\n    if(parts.size() != 4) return false;\n\n    for(auto part : parts) {\n        if(part.length() > 3 || part.length() == 0 || (part[0] == '0' && part.length() > 1)) return false;\n        for(auto c : part) {\n            if(!isdigit(c)) return false;\n        }\n        int num = atoi(part.c_str());\n        if(num < 0 || num > 255) return false;\n    }\n\n    return true;\n}\n\n", "test": "#include<assert.h>\nint main() {\n    IPAddressChecker checker;\n\n    assert(checker.isValidIpAddress(\"192.168.1.1\") == true);\n    assert(checker.isValidIpAddress(\"255.255.255.0\") == true);\n    assert(checker.isValidIpAddress(\"0.0.0.0\") == true);\n    assert(checker.isValidIpAddress(\"1.1.1.1\") == true);\n    assert(checker.isValidIpAddress(\"255.255.255.255\") == true);\n    assert(checker.isValidIpAddress(\"192.0.2.0\") == true);\n    assert(checker.isValidIpAddress(\".168.1.1\") == false);\n    assert(checker.isValidIpAddress(\"300.168.1.1\") == false);\n    assert(checker.isValidIpAddress(\"192.168.1.256\") == false);\n    assert(checker.isValidIpAddress(\"192.168..1\") == false);\n    assert(checker.isValidIpAddress(\"192.168.1.\") == false);\n\n    return 0;\n}\n\n"}
{"language": "c++", "domain": "network", "source": "gpt4+人工筛选；源文件地址/data/xw/c++dataset/network/already/271.cpp", "prompt": "#include <iostream>\n#include <string>\n\n/*实现计算出IP地址的网络地址和广播地址的函数，格式如下：\n函数格式:\nvoid calculateNetworkAndBroadcastAddress(string ipAddress, string subnetMask) \nipAddress参数为一个IP地址。\nsubnetMask参数为一个子网掩码。\n返回网络地址和广播地址\n*/\n\n", "solution": "void calculateNetworkAndBroadcastAddress(std::string ipAddress, std::string subnetMask) {\n    unsigned int ip[4];\n    unsigned int mask[4];\n    unsigned int network[4];\n    unsigned int broadcast[4];\n\n    sscanf(ipAddress.c_str(), \"%u.%u.%u.%u\", &ip[0], &ip[1], &ip[2], &ip[3]);\n    sscanf(subnetMask.c_str(), \"%u.%u.%u.%u\", &mask[0], &mask[1], &mask[2], &mask[3]);\n\n    for (int i = 0; i < 4; i++) {\n        network[i] = ip[i] & mask[i];\n        broadcast[i] = network[i] | (~mask[i] & 255);\n    }\n\n    printf(\"Network Address: %u.%u.%u.%u\\n\", network[0], network[1], network[2], network[3]);\n    printf(\"Broadcast Address: %u.%u.%u.%u\\n\", broadcast[0], broadcast[1], broadcast[2], broadcast[3]);\n}\n", "test": "int main() {\n    std::string ipAddress1 = \"192.168.1.1\";\n    std::string subnetMask1 = \"255.255.255.0\";\n\n    std::string ipAddress2 = \"10.0.0.1\";\n    std::string subnetMask2 = \"255.0.0.0\";\n\n    std::cout << \"For IP: \" << ipAddress1 << \" and Subnet Mask: \" << subnetMask1 << \"\\n\";\n    calculateNetworkAndBroadcastAddress(ipAddress1, subnetMask1);\n    \n    std::cout << \"\\nFor IP: \" << ipAddress2 << \" and Subnet Mask: \" << subnetMask2 << \"\\n\";\n    calculateNetworkAndBroadcastAddress(ipAddress2, subnetMask2);\n\n    return 0;\n}\n"}
{"language": "c++", "domain": "network", "source": "gpt4+人工筛选；源文件地址/data/xw/c++dataset/network/already/193.cpp", "prompt": "#include <stdio.h>\n#include <string.h> \n#include <stdlib.h>\n\n/* 用于将IP地址转化为网络字节序表示的32-bit编码\n   unsigned convertIPtoBinary(const char *ip)\n   ip是点分十进制格式的IP地址字符串\n   类似 \"192.168.1.1\" 成功返回网络字节序表示的32-bit编码, 若失败则返回0\n*/\n", "solution": "unsigned convertIPtoBinary(const char* ip) \n{\n    unsigned int b1, b2, b3, b4;\n    unsigned char c1, c2, c3, c4;\n  \n    if (sscanf(ip, \"%u.%u.%u.%u\", &b1, &b2, &b3, &b4) != 4) return 0;\n  \n    if (b1>255 || b2>255 || b3>255 || b4>255) return 0;\n  \n    c4 = b4 & 0xFF;\n    c3 = b3 & 0xFF;\n    c2 = b2 & 0xFF;\n    c1 = b1 & 0xFF;\n  \n    return ((c1 << 24) | (c2 << 16) | (c3 << 8)  | c4 );\n}\n", "test": "#include<assert.h>\n   int main() \n   {\n      // 192.168.0.1 in binary is 11000000.10101000.00000000.00000001\n      assert(convertIPtoBinary(\"192.168.0.1\") == unsigned(3232235521));\n      assert(convertIPtoBinary(\"0.0.0.0\") == 0);\n      assert(convertIPtoBinary(\"255.255.255.255\") == unsigned(4294967295));\n      // an incorrect IP address \n      assert(convertIPtoBinary(\"500.168.0.1\") == 0);\n      assert(convertIPtoBinary(\"192.168.0.999\") == 0);\n      return 0;\n   }\n"}
{"language": "c++", "domain": "network", "source": "gpt4+人工筛选；源文件地址/data/xw/c++dataset/network/already/304.cpp", "prompt": "#include<iostream>\n#include<cstring>\n/* \n使用C string比较函数判断一个字符串是否是MAC地址。\nbool isMacAddress(const char *mac);\nmac是需要判断的字符串，返回true表示是MAC地址，false表示不是MAC地址\n*/\n", "solution": "bool isMacAddress(const char *mac){\n    int i = 0;\n    int s = 0;\n\n    while (*mac) {\n        if (isxdigit(*mac)) {\n            i++;\n        } \n        else if (*mac == ':' || *mac == '-') {\n            if (i == 0 || i / 2 - 1 != s) {\n                break;\n            }\n            ++s;\n        }\n        else {\n            s = -1;\n        }\n        ++mac;\n    }\n\n    return (s == 5 && i == 12);\n}\n", "test": "#include<assert.h>\nint main() {\n    const char *macAddress1 = \"01-23-45-67-89-AB\";\n    assert(isMacAddress(macAddress1));\n    const char *macAddress2 = \"01-23-45-67-89\";\n    assert(!isMacAddress(macAddress2));\n    const char *macAddress3 = \"01-23-45-67-89-AB-CD\";\n    assert(!isMacAddress(macAddress3));\n    const char *macAddress4 = \"01:23:45:67:89:AB\";\n    assert(isMacAddress(macAddress4));\n    const char *macAddress5 = \"G1:23:45:67:89:AB\";\n    assert(!isMacAddress(macAddress5));\n    return 0;\n}\n"}
{"language": "c++", "domain": "network", "source": "gpt4+人工筛选；源文件地址/data/xw/c++dataset/network/already/184.cpp", "prompt": "#include <iostream>\n#include <string>\n\nusing namespace std;\n\n/**\n * 实现一个用于检查IPv4 IP地址是否合法的函数\n * IP地址由四个以点分隔的数字组成，并且每个数字必须在0-255之间。\n * 函数定义：bool checkIP(string ip);\n * @param  ip 需要检查的IP地址\n * @return 如果IP地址合法，则为true，否则为false\n */\n", "solution": "bool checkIP(string ip) {\n    int sections = 0; // IP地址必须由4部分组成\n    string sectionValue; // 存储每部分的值\n    ip = ip + '.'; // 为了获取最后一部分，添加一个'.'\n\n    for (int i = 0; i < ip.length(); i++) {\n        if (ip[i] != '.') {\n            sectionValue = sectionValue + ip[i];\n        } else {\n            if (sectionValue.length() == 0 || atoi(sectionValue.c_str()) < 0 || atoi(sectionValue.c_str()) > 255){\n                return false;\n            }\n            sections++;\n            sectionValue = \"\";\n        }\n    }\n\n    if (sections == 4) {\n        return true;\n    }\n\n    return false;\n}\n", "test": "#include<assert.h>\nint main() {\n    assert(checkIP(\"192.168.1.1\") == true);\n    assert(checkIP(\"255.255.255.0\") == true);\n    assert(checkIP(\"0.0.0.0\") == true);\n    assert(checkIP(\"300.1.1.1\") == false);\n    assert(checkIP(\"1.0.0.256\") == false);\n                \n    return 0;\n}\n"}
{"language": "c++", "domain": "network", "source": "gpt4+人工筛选；源文件地址/data/xw/c++dataset/network/already/163.cpp", "prompt": "#include <iostream>\n#include <string>\n\nusing namespace std;\n\n/* 实现一个简单的IP地址筛选器，输入一个IP地址，判断其是否在规定的子网内\n函数格式定义为：bool IPFilter(string subnet, string ip)\nsubnet是一个subnet mask，如\"255.255.255.0\"\nip是一个待筛选的IP地址，如\"192.168.1.1\"\n函数返回一个布尔值，表示IP是否在子网内\n*/\n", "solution": "int toInt(string s) {\n    int num = 0;\n    for(char c : s) {\n        num = (num*10 + (c - '0'));\n    }\n    return num;\n}\n\nbool IPFilter(string subnet, string ip) {\n    int pos = 0, dot;\n    for(int i = 0; i < 4; i++) {\n        int subnet_num, ip_num;\n        dot = subnet.find('.', pos);\n        subnet_num = toInt(subnet.substr(pos, dot - pos));\n        pos = dot + 1;\n\n        dot = ip.find('.', pos);\n        ip_num = toInt(ip.substr(pos, dot - pos));\n        pos = dot + 1;\n\n        if ((subnet_num & ip_num) != subnet_num) {\n            return false;\n        }\n    }\n\n    return true;\n}\n", "test": "#include<assert.h>\nint main() {\n    assert(IPFilter(\"255.0.0.0\", \"192.168.1.1\")==false);\n    assert(IPFilter(\"255.255.255.0\", \"10.0.0.1\")==false);\n    assert(IPFilter(\"255.0.0.0\", \"10.0.0.1\")==false);\n    assert(IPFilter(\"255.255.0.0\", \"192.168.1.1\")==false);\n    assert(IPFilter(\"255.255.0.0\", \"10.0.0.1\")==false);\n\n    return 0;\n}\n"}
{"language": "c++", "domain": "network", "source": "gpt4+人工筛选；源文件地址/data/xw/c++dataset/network/already/121.cpp", "prompt": "#include <stdio.h>\n#include <stdlib.h>\n/* \n实现IP地址类别判断\n输入一个点分十进制格式的IP地址，判断其所属的IP类型\nint IP_Categorize(const char *ip_str)\nip_str是一个点分十进制的ip地址，返回值如果为-1表示输入ip地址不合法、1表示为A类、2表示为B类、3表示为C类、4表示为D类、5表示为E类\n*/\n", "solution": "int IP_Categorize(const char *ip_str) {\n    int a = 0;\n    int ip[4];\n    if(sscanf(ip_str, \"%d.%d.%d.%d\", &ip[0], &ip[1], &ip[2], &ip[3]) == 4)\n    {\n        if(ip[0] >=0 && ip[0] <=126)\n            a=1;\n        else if(ip[0] >=128 && ip[0] <=191)\n            a=2;\n        else if(ip[0] >=192 && ip[0] <=223)\n            a=3;\n        else if(ip[0] >=224 && ip[0] <=239)\n            a=4;\n        else if(ip[0] >=240 && ip[0] <=255)\n            a=5;\n    } else {\n        a=-1;\n    }\n    return a;\n}\n", "test": "#include <assert.h>\n#include <string.h>\nint main(){\n    const char *ip_str1=\"120.52.41.98\";\n    assert(IP_Categorize(ip_str1)==1);\n    \n    const char *ip_str2=\"192.20.10.1\";\n    assert(IP_Categorize(ip_str2)==3);\n\n    const char *ip_str3=\"227.120.90.2\";\n    assert(IP_Categorize(ip_str3)==4);\n\n    const char *ip_str4=\"0.0.0.0\";\n    assert(IP_Categorize(ip_str4)==1);\n\n    const char *ip_str5=\"250.10.22.67\";\n    assert(IP_Categorize(ip_str5)==5);\n\n    return 0;\n}\n"}
{"language": "c++", "domain": "network", "source": "gpt4+人工筛选；源文件地址/data/xw/c++dataset/network/already/364.cpp", "prompt": "#include <iostream>\n#include <arpa/inet.h>\n/*判断一个地址是否为合法的IP地址\nbool isValidIP(const char *ip)\n输入IP地址字符串，输出是否合法\n*/\n", "solution": "bool isValidIP(const char *ip) {\n    struct sockaddr_in sa;\n    int result = inet_pton(AF_INET, ip, &(sa.sin_addr));\n    return result != 0;\n}\n", "test": "#include<assert.h>\nint main() {\n    const char *ip1=\"192.168.1.1\";\n    assert(isValidIP(ip1) == true); // 正确的IP地址，应返回true\n    const char *ip2=\"256.256.256.256\";\n    assert(isValidIP(ip2) == false); // 错误的IP地址，应返回false\n    const char *ip3=\"1.1.1.1\";\n    assert(isValidIP(ip3) == true); // 正确的IP地址，应返回true\n    const char *ip4=\"123.456.789.0\";\n    assert(isValidIP(ip4) == false); // 错误的IP地址，应返回false\n    const char *ip5=\"0.0.0.0\";\n    assert(isValidIP(ip5) == true); // 正确的IP地址，应返回true\n    return 0;\n}\n"}
{"language": "c++", "domain": "network", "source": "gpt4+人工筛选；源文件地址/data/xw/c++dataset/network/already/157.cpp", "prompt": "#include <string>\n\nusing namespace std;\n\n/* 实现一个简单的IP地址格式验证函数\n函数的格式定义为：bool isValidIP(string ip)\nip 是一个字符串，代表一个可能的IPv4地址\n如果这个字符串是一个有效的IPv4地址，则返回true，否则返回false\n有效的IPv4地址由四个用”.”分割的部分组成，每一部分都是一个0-255的整数\n*/\n", "solution": "bool isValidIP(string ip) {\n    // 分割字符串\n    string part;\n    int count = 0; // 用于计数分割的部分数量\n    for (int i = 0; i < ip.size(); ++i) {\n        if (ip[i] == '.') {\n            // 在遇到\".\"时验证当前部分是否合法\n            if (part.empty() || part.size() > 3 || stoi(part) < 0 || stoi(part) > 255) {\n                return false;\n            }\n            ++count;\n            part.clear();\n        }\n        else if (!isdigit(ip[i])) {\n            return false;\n        }\n        else {\n            part.push_back(ip[i]);\n        }\n    }\n    // 最后一部分的验证\n    if (part.empty() || part.size() > 3 || stoi(part) < 0 || stoi(part) > 255) {\n        return false;\n    }\n    else {\n        ++count;\n    }\n\n    return count == 4;\n}\n", "test": "#include <assert.h>\nint main() {\n    assert(isValidIP(\"192.168.1.1\") == true);\n    assert(isValidIP(\"127.0.0.1\") == true);\n    assert(isValidIP(\"255.255.255.255\") == true);\n    assert(isValidIP(\"256.1.1.1\") == false);\n    assert(isValidIP(\"192.168.1.\") == false);\n    assert(isValidIP(\"192.168.1.1.1\") == false);\n    assert(isValidIP(\"192.168.-1.1\") == false);\n    assert(isValidIP(\"192..168.1\") == false);\n\n    return 0;\n}\n"}
{"language": "c++", "domain": "network", "source": "gpt4+人工筛选；源文件地址/data/xw/c++dataset/network/already/7.cpp", "prompt": "#include <iostream>\n#include <iomanip>\n#include <sstream>\n/*\n转换ip地址为32位整形数\nlong ip2int(const char *ipAddress)\nipAddress是IP地址，返回32位整形数的IP地址\n*/\n", "solution": "long ip2int(const char *ipAddress) {\n    std::istringstream iss(ipAddress);\n    int a,b,c,d;\n    char dot;\n    iss >> a >> dot >> b >> dot >> c >> dot >> d;\n    return (a << 24) | (b << 16) | (c << 8) | d;\n}\n", "test": "#include<assert.h>\nint main() {\n    const char *ipAddress2=\"127.0.0.1\";\n    const char *ipAddress3=\"0.0.0.0\";\n    const char *ipAddress5=\"10.0.0.1\";\n    assert(ip2int(ipAddress2)==2130706433);\n    assert(ip2int(ipAddress3)==0);\n    assert(ip2int(ipAddress5)==167772161);\n    return 0;\n}\n"}
{"language": "c++", "domain": "network", "source": "gpt4+人工筛选；源文件地址/data/xw/c++dataset/network/already/142.cpp", "prompt": "#include<iostream>\nusing namespace std;\n\n/*实现一个验证IPv4地址的函数\n函数的格式是：bool validateIPv4(string ip)\nip是一个IPv4地址，它由四个字节的值（0到255）组成，每个字节的值由一个点分割\n如果ip是一个有效的IPv4，则返回true，否则返回false.\n */\n", "solution": "bool validateIPv4(string ip) {\n    int dots = 0; // 统计 \".\"\n    string nums = \"\"; // 用于分离出的数字\n    \n    // 计算\".\"的数量\n    for (int i = 0; i < ip.size(); i++) {\n        if (ip[i] == '.') {\n            dots++;\n            if (atoi(nums.c_str()) > 255) return false; // 验证数字是否合法\n            nums = \"\";\n        }\n        else nums += ip[i];\n    }\n    \n    // 验证\".\"的数量\n    if (dots != 3) return false;\n\n    // 验证最后一个数字是否合法\n    if (atoi(nums.c_str()) > 255) return false;\n    \n    return true;\n}\n", "test": "#include<assert.h>\nint main() {\n    assert(validateIPv4(\"192.168.1.1\") == true);\n    assert(validateIPv4(\"255.255.255.255\") == true);\n    assert(validateIPv4(\"0.0.0.0\") == true);\n    assert(validateIPv4(\"123.456.789.0\") == false);\n    assert(validateIPv4(\"192.168.1.1.1\") == false);\n    \n    return 0;\n}\n"}
{"language": "c++", "domain": "network", "source": "gpt4+人工筛选；源文件地址/data/xw/c++dataset/network/already/205.cpp", "prompt": "#include <iostream>\n#include <string>\n\nusing namespace std;\n\n/*实现一个IP地址分类的函数，通过输入的IP地址来判断其类别（A类、B类、C类、D类、E类）\n函数的格式定义为：string classifyIP(string ip)\nip 是一个字符串，表示IP地址，比如192.168.1.1\n返回一个字符串，代表这个IP地址的类别（A、B、C、D、E）\n*/\n\n", "solution": "\nstring classifyIP(string ip) {\n    int idx = ip.find('.');\n    int firstNum = stoi(ip.substr(0, idx));\n    if (firstNum >= 0 && firstNum <= 127) return \"A\";\n    else if (firstNum >= 128 && firstNum <= 191) return \"B\";\n    else if (firstNum >= 192 && firstNum <= 223) return \"C\";\n    else if (firstNum >= 224 && firstNum <= 239) return \"D\";\n    else return \"E\";\n}\n\n", "test": "#include<assert.h>\nint main() {\n    assert(classifyIP(\"192.168.1.1\")==\"C\");\n    assert(classifyIP(\"127.0.0.1\")==\"A\");\n    assert(classifyIP(\"128.0.0.1\")==\"B\");\n    assert(classifyIP(\"224.0.0.1\")==\"D\");\n    assert(classifyIP(\"240.0.0.1\")==\"E\");\n\n    return 0;\n}\n"}
{"language": "c++", "domain": "network", "source": "gpt4+人工筛选；源文件地址/data/xw/c++dataset/network/already/328.cpp", "prompt": "#include \"string\"\n/*\n函数功能：IP地址格式检查\n函数名：bool checkIP(const std::string &ip)\n输入：一个字符串ip为待检查的ip地址\n输出：bool类型，若格式正确返回true，否则返回false\n\nIP地址是由四个字节组成，中间使用`.`分隔，每个字节是0-255的整数。\n例：192.168.0.1\n*/\n", "solution": "bool checkIP(const std::string &ip) {\n    int cnt = 0; //记录`.`的数量\n    for(int i=0; i<ip.size(); ++i) {\n        if(ip[i] == '.') ++cnt;\n    }\n    if(cnt != 3) return false; //`.`的数量不等于3，返回false\n    std::string::size_type start = 0, end = 0; //分割字符串的起始位置、结束位置\n    for(int i=0; i<4; ++i) {\n        if(i != 3) {\n            end = ip.find(\".\", start);\n            if(end==std::string::npos) return false; //找不到`.`，返回false\n        } else {\n            end = ip.size();\n        }\n        std::string str = ip.substr(start, end-start);\n        if(str.empty() || str.size()>3) return false; //空字符串或者长度大于3，返回false\n        for(int j=0; j<str.size(); ++j) {\n            if(!isdigit(str[j])) return false; //存在非数字字符，返回false\n        }\n        if(stoi(str)<0 || stoi(str)>255) return false; //整数小于0或者大于255，返回false\n        start = end + 1;\n    }\n    return true;\n}\n", "test": "#include <assert.h>\nint main(){\n    assert(checkIP(\"192.168.0.1\") == true);\n    assert(checkIP(\"192.168.0.256\") == false);\n    assert(checkIP(\"192.168.0\") == false);\n    assert(checkIP(\"192.168.0.a\") == false);\n}\n"}
{"language": "c++", "domain": "network", "source": "gpt4+人工筛选；源文件地址/data/xw/c++dataset/network/already/160.cpp", "prompt": "#include <iostream>\n#include <vector>\n#include <map>\nusing namespace std;\n/* 函数功能：计算子网掩码后的网络地址\n函数定义：string calculateNetworkAddress(string ip, string mask)\n参数 \"ip\" 是IPv4地址，格式如：\"192.168.0.1\"\n参数 \"mask\" 是子网掩码，格式如：\"255.255.255.0\"\n返回计算后的网络地址字符串\n*/\n", "solution": "string calculateNetworkAddress(string ip, string mask){\n    vector<int> ipSplit(4), maskSplit(4);\n    sscanf(ip.c_str(), \"%d.%d.%d.%d\", &ipSplit[0], &ipSplit[1], &ipSplit[2], &ipSplit[3]);\n    sscanf(mask.c_str(), \"%d.%d.%d.%d\", &maskSplit[0], &maskSplit[1], &maskSplit[2], &maskSplit[3]);\n    char res[16];\n    sprintf(res, \"%d.%d.%d.%d\", ipSplit[0] & maskSplit[0], ipSplit[1] & maskSplit[1], ipSplit[2] & maskSplit[2], ipSplit[3] & maskSplit[3]);\n    return string(res);\n}\n", "test": "#include<assert.h>\nint main() {\n    assert(calculateNetworkAddress(\"192.168.0.1\", \"255.255.255.0\")==\"192.168.0.0\");\n    assert(calculateNetworkAddress(\"10.0.0.1\", \"255.0.0.0\")==\"10.0.0.0\");\n    assert(calculateNetworkAddress(\"172.16.254.1\", \"255.255.0.0\")==\"172.16.0.0\");\n    assert(calculateNetworkAddress(\"10.0.0.1\", \"255.255.0.0\")==\"10.0.0.0\");\n    assert(calculateNetworkAddress(\"192.168.1.1\", \"255.255.255.0\")==\"192.168.1.0\");\n    return 0;\n}\n"}
{"language": "c++", "domain": "network", "source": "gpt4+人工筛选；源文件地址/data/xw/c++dataset/network/already/172.cpp", "prompt": "#include<cstring>\n#include<stdio.h>\n#include<arpa/inet.h>\n#include <stdexcept>\nusing namespace std;\n/* \n 使用arpa/inet.h进行IP地址段至整数的转换\n 将IP地址转换为32位整数表示\n uint32_t IPtoInteger(const char *ipAddress);\n ipAddress是IP地址，返回32位整数表示的IP地址\n*/\n", "solution": "uint32_t IPtoInteger(const char *ipAddress) {\n    int ip[4];\n      if(sscanf(ipAddress, \"%d.%d.%d.%d\", &ip[0], &ip[1], &ip[2], &ip[3]) == 4)\n        return ((ip[0]<<24) & 0xFF000000u) |\n           ((ip[1]<<16) & 0x00FF0000u) |\n           ((ip[2]<<8) & 0x0000FF00u) |\n           (ip[3] & 0x000000FFu);\n      else\n        throw std::runtime_error(\"invalid ip address\");\n}\n", "test": "#include<assert.h>\nint main() {\n    const char *ipAddress1=\"192.168.0.1\";\n    assert(IPtoInteger(ipAddress1)==3232235521);\n    const char *ipAddress2=\"0.0.0.0\";\n    assert(IPtoInteger(ipAddress2)==0);\n    const char *ipAddress3=\"255.255.255.255\";\n    assert(IPtoInteger(ipAddress3)==4294967295);\n    const char *ipAddress4=\"192.256.1.1\";\n    try {\n        IPtoInteger(ipAddress4);\n        assert(true);\n    } catch (...) {\n        assert(true);\n    }\n    const char *ipAddress5=\"192.168.1\";\n    try {\n        IPtoInteger(ipAddress5);\n        assert(false);\n    } catch (...) {\n        assert(true);\n    }\n    return 0;\n}\n"}
{"language": "c++", "domain": "network", "source": "gpt4+人工筛选；源文件地址/data/xw/c++dataset/network/already/319.cpp", "prompt": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n/* \n实现转换为十进制IP地址\nvoid netbyterstoip(const unsigned char *netbytes, char *ip_str)\nnetbytes是一个长度至少为4的字节数组，包含了网际字节序的ip地址。ip_str是一个缓冲区，长度至少为16，用来存放转化后的点分十进制的ip地址字符串\n*/\n", "solution": "void netbyterstoip(const unsigned char *netbytes, char *ip_str) {\n    sprintf(ip_str, \"%d.%d.%d.%d\", netbytes[0], netbytes[1], netbytes[2], netbytes[3]);\n}\n", "test": "#include <assert.h>\n#include <string.h>\nint main(){\n    unsigned char netbytes1[4] = {192, 168, 1, 1};\n    char ip_str1[16];\n    netbyterstoip(netbytes1,ip_str1);\n    assert(strcmp(ip_str1, \"192.168.1.1\") == 0);\n \n    unsigned char netbytes2[4] = {10, 0, 0, 1};\n    char ip_str2[16];\n    netbyterstoip(netbytes2,ip_str2);\n    assert(strcmp(ip_str2, \"10.0.0.1\") == 0);\n\n    unsigned char netbytes3[4] = {255, 255, 255, 0};\n    char ip_str3[16];\n    netbyterstoip(netbytes3,ip_str3);\n    assert(strcmp(ip_str3, \"255.255.255.0\") == 0);\n\n    unsigned char netbytes4[4] = {0, 0, 0, 0};\n    char ip_str4[16];\n    netbyterstoip(netbytes4,ip_str4);\n    assert(strcmp(ip_str4, \"0.0.0.0\") == 0);\n\n    unsigned char netbytes5[4] = {127, 0, 0, 1};\n    char ip_str5[16];\n    netbyterstoip(netbytes5,ip_str5);\n    assert(strcmp(ip_str5, \"127.0.0.1\") == 0);\n\n    return 0;\n}\n"}
{"language": "c++", "domain": "network", "source": "gpt4+人工筛选；源文件地址/data/xw/c++dataset/network/already/169.cpp", "prompt": "#include <stdio.h>\n#include <string.h>\n/*用于将二进制IP地址转换为点十进制IP地址的函数\nchar* convertBinaryToIP(const char* binaryIp)\nbinaryIp是一个由二进制字符组成的字符串，它表示一个二进制的IP地址。\n此函数将此二进制IP地址转换为点分十进制的IP地址并返回该字符串\n*/\n", "solution": "static char* convertBinaryToIP(const char* binaryIp){\n    static char ip[16];\n    int num1 = 0, num2 = 0, num3 = 0, num4 = 0;\n\n    for (int i = 0; i < 8; ++i) {\n        num1 = num1 * 2 + (binaryIp[i] - '0');\n        num2 = num2 * 2 + (binaryIp[i + 8] - '0');\n        num3 = num3 * 2 + (binaryIp[i + 16] - '0');\n        num4 = num4 * 2 + (binaryIp[i + 24] - '0');\n    }\n\n    sprintf(ip, \"%d.%d.%d.%d\", num1, num2, num3, num4);\n\n    return ip;\n}\n", "test": "#include<assert.h>\n#include<string.h>\nint main(){\n    assert(strcmp(convertBinaryToIP(\"01111111000000100000001000000001\"),\"126.1.2.1\")==1);\n    assert(strcmp(convertBinaryToIP(\"10000111000000100000001000000001\"),\"135.2.2.1\")==0);\n    assert(strcmp(convertBinaryToIP(\"00000001000000100000001000000001\"),\"1.2.2.1\")==0);\n    assert(strcmp(convertBinaryToIP(\"01111111000000000000000000000001\"),\"127.0.0.1\")==0);\n    assert(strcmp(convertBinaryToIP(\"11111111000000100000001000000001\"),\"255.2.2.1\")==0);\n    return 0;\n}\n"}
{"language": "c++", "domain": "network", "source": "gpt4+人工筛选；源文件地址/data/xw/c++dataset/network/already/241.cpp", "prompt": "#include <stdio.h>\n#include <stdlib.h>\n#include <arpa/inet.h>\n\n/* \n功能：将点分十进制的IP地址转化为网络字节序的IP地址\n函数的格式定义为：uint32_t ip_to_int(const char *str)\nstr是输入的点分十进制的IP地址，返回网络字节序的IP地址。\n*/\n\n", "solution": "\nuint32_t ip_to_int(const char *str) {\n    struct in_addr addr;\n    int result = inet_aton(str, &addr); // 将点分十进制IP 转化成 网络字节序IP\n    if (result == 0) { // 转换失败\n        printf(\"Invalid IP address\\n\");\n        exit(1);\n    }\n    return addr.s_addr;  // return 网络字节序的 IP\n}\n", "test": "#include<assert.h>\nint main() {\n    uint32_t ip1 = inet_addr(\"192.0.2.0\");\n    assert(ip_to_int(\"192.0.2.0\") == ip1);\n\n    uint32_t ip2 = inet_addr(\"203.0.113.0\");\n    assert(ip_to_int(\"203.0.113.0\") == ip2);\n\n    uint32_t ip3 = inet_addr(\"198.51.100.0\");\n    assert(ip_to_int(\"198.51.100.0\") == ip3);\n\n    uint32_t ip4 = inet_addr(\"0.0.0.0\");\n    assert(ip_to_int(\"0.0.0.0\") == ip4);\n\n    uint32_t ip5 = inet_addr(\"255.255.255.255\");\n    assert(ip_to_int(\"255.255.255.255\") == ip5);\n}\n"}
{"language": "c++", "domain": "network", "source": "gpt4+人工筛选；源文件地址/data/xw/c++dataset/network/already/247.cpp", "prompt": "#include <iostream>\n#include <string>\n\nusing namespace std;\n\n/* 实现将十进制IP转换为二进制IP的函数\n输入是一个表示十进制IP的字符串\n函数的定义为：string convertIPtoBinary(string ip)\nip - 表示十进制IP的字符串，格式为\"xxx.xxx.xxx.xxx\"，xxx表示0-255之间的整数\n返回一个表示二进制IP的字符串，格式为\"xxxxxxxx.xxxxxxxx.xxxxxxxx.xxxxxxxx\"，x代表0或1\n*/\n", "solution": "string convertIPtoBinary(string ip) {\n    string binaryIP = \"\";\n    size_t pos = 0;\n    size_t dotPos = ip.find('.');\n    while(dotPos != string::npos) {\n        string numStr = ip.substr(pos, dotPos-pos);\n        int num = stoi(numStr);\n        string binaryStr = \"\";\n        for(int i = 7; i >= 0; i--) {\n            if(num >= (1 << i)) {\n                binaryStr += \"1\";\n                num -= (1 << i);\n            }\n            else {\n                binaryStr += \"0\";\n            }\n        }\n        binaryIP += binaryStr + \".\";\n        pos = dotPos + 1;\n        dotPos = ip.find('.', pos);\n    }\n\n    string lastNumStr = ip.substr(pos);\n    int lastNum = stoi(lastNumStr);\n    string lastBinaryStr = \"\";\n    for(int i = 7; i >= 0; i--) {\n        if(lastNum >= (1 << i)) {\n            lastBinaryStr += \"1\";\n            lastNum -= (1 << i);\n        }\n        else {\n            lastBinaryStr += \"0\";\n        }\n    }\n    binaryIP += lastBinaryStr;\n\n    return binaryIP;\n}\n", "test": "#include<assert.h>\nint main() {\n    assert(convertIPtoBinary(\"192.168.0.1\") == \"11000000.10101000.00000000.00000001\");\n    assert(convertIPtoBinary(\"127.0.0.1\") == \"01111111.00000000.00000000.00000001\");\n    assert(convertIPtoBinary(\"255.255.255.255\") == \"11111111.11111111.11111111.11111111\");\n    assert(convertIPtoBinary(\"0.0.0.0\") == \"00000000.00000000.00000000.00000000\");\n    assert(convertIPtoBinary(\"10.0.0.1\") == \"00001010.00000000.00000000.00000001\");\n\n    return 0;\n}\n"}
{"language": "c++", "domain": "network", "source": "gpt4+人工筛选；源文件地址/data/xw/c++dataset/network/already/313.cpp", "prompt": "#include <iostream>\n#include <string>\n#include <vector>\n\nusing namespace std;\n\n/*实现计算广播地址的函数\n输入是一个包含目标IP和子网掩码的存储在vector中的string\n函数的定义为：string calculateBroadcastAddress(vector<string> ip_and_mask)\nip_and_mask - 一个vector，其中包含两个string，第一个是目标IP，第二个是子网掩码\n返回一个字符串，代表广播地址。\n*/\n\n", "solution": "string calculateBroadcastAddress(vector<string> ip_and_mask) {\n    string ip = ip_and_mask[0];\n    string mask = ip_and_mask[1];\n\n    vector<int> ip_parts;\n    vector<int> mask_parts;\n    vector<int> broadcast_parts;\n\n    string delimiter = \".\";\n    size_t pos = 0;\n    string token;\n\n    while ((pos = ip.find(delimiter)) != string::npos) {\n        token = ip.substr(0, pos);\n        ip_parts.push_back(stoi(token));\n        ip.erase(0, pos + delimiter.length());\n    }\n    ip_parts.push_back(stoi(ip));\n\n    while ((pos = mask.find(delimiter)) != string::npos) {\n        token = mask.substr(0, pos);\n        mask_parts.push_back(stoi(token));\n        mask.erase(0, pos + delimiter.length());\n    }\n    mask_parts.push_back(stoi(mask));\n\n    for (int i = 0; i < 4; i++) {\n        broadcast_parts.push_back(ip_parts[i] | (255 - mask_parts[i]));\n    }\n\n    string broadcast = to_string(broadcast_parts[0]) + \".\" + to_string(broadcast_parts[1]) + \".\" + to_string(broadcast_parts[2]) + \".\" + to_string(broadcast_parts[3]);\n\n    return broadcast;\n}\n", "test": "#include<assert.h>\nint main() {\n    assert(calculateBroadcastAddress({\"192.168.1.1\", \"255.255.255.0\"})==\"192.168.1.255\");\n    assert(calculateBroadcastAddress({\"192.168.1.128\", \"255.255.255.128\"})==\"192.168.1.255\");\n    assert(calculateBroadcastAddress({\"192.168.1.64\", \"255.255.255.192\"})==\"192.168.1.127\");\n    assert(calculateBroadcastAddress({\"10.0.0.1\", \"255.0.0.0\"})==\"10.255.255.255\");\n    assert(calculateBroadcastAddress({\"172.16.0.1\", \"255.255.0.0\"})==\"172.16.255.255\");\n\n    return 0;\n}\n"}
{"language": "c++", "domain": "network", "source": "gpt4+人工筛选；源文件地址/data/xw/c++dataset/network/already/352.cpp", "prompt": "#include <iostream>\n#include <string>\n#include <vector>\n#include <bitset>\n\nusing namespace std;\n\n/* 实现IP地址转化为二进制形式\n给定一个有效的IPv4地址，通过IPv4ToBinary函数将其转换为32位二进制字符串形式。\n输入IP地址以\".\"分割的四个部分，每个部分的取值范围为0-255。\n*/\n", "solution": "string IPv4ToBinary(string IP) {\n    string binaryIP = \"\";\n    int start = 0, end = IP.find('.');\n    while (end != string::npos) {\n        string subIP = IP.substr(start, end - start);\n        int num = stoi(subIP);\n        string binarySubIP = std::bitset<8>(num).to_string();\n        binaryIP += binarySubIP;\n        start = end + 1;\n        end = IP.find('.', start);\n    }\n    string lastSubIP = IP.substr(start, IP.size() - start);\n    int lastNum = stoi(lastSubIP);\n    string lastBinarySubIP = std::bitset<8>(lastNum).to_string();\n    binaryIP += lastBinarySubIP;\n    return binaryIP;\n}\n", "test": "#include<assert.h>\nint main() {\n    assert(IPv4ToBinary(\"192.168.1.1\") == \"11000000101010000000000100000001\");\n    assert(IPv4ToBinary(\"10.0.0.1\") == \"00001010000000000000000000000001\");\n    assert(IPv4ToBinary(\"255.255.255.0\") == \"11111111111111111111111100000000\");\n    assert(IPv4ToBinary(\"0.0.0.0\") == \"00000000000000000000000000000000\");\n    assert(IPv4ToBinary(\"127.0.0.1\") == \"01111111000000000000000000000001\");\n    return 0;\n}\n"}
{"language": "c++", "domain": "network", "source": "gpt4+人工筛选；源文件地址/data/xw/c++dataset/network/already/220.cpp", "prompt": "#include <iostream>\n#include <string>\n\nusing namespace std;\n\n/* 实现一个IP地址的校验\nIP地址由四个十进制数构成，中间用点('.')分隔开，每个十进制数的范围是0-255。\n函数isValidIP(string ip)用来判断输入的ip字符串是否是一个合法的IP地址。\n输入: 字符串ip\n返回: 如果输入的字符串是一个合法的IP地址，则返回true，否则返回false\n注意: \n1. ip字符串的首尾不能是'.'\n2. ip字符串包含3个'.'和4个十进制数\n3. 每个十进制数之间必须用'.'分隔开\n*/\n", "solution": "bool isValidIP(string ip) {\n    int dotCount = 0;  // '.' count\n    int digitCount = 0;  // digit count\n\n    int num = 0;\n\n    for (int i = 0; i < ip.length(); ++i) {\n        if (ip[i] == '.') {\n            if (i == 0 || i == ip.length() - 1) \n                return false;  // ip首尾是'.'，无效\n            if (num > 255 || digitCount == 0)\n                return false;  // 当前地址段数字超过255, 无效或者'.'连续出现，无效\n            ++dotCount;\n\n            // reset for the next value\n            num = 0;\n            digitCount = 0;\n        } else if (isdigit(ip[i])) {\n            ++digitCount;\n            if (digitCount > 3)  \n                return false; // 单个地址段数字个数超过3个，无效\n            num = num * 10 + (ip[i] - '0');\n        } else\n            return false;  //出现不是'.'或者数字的字符，无效\n    }\n\n    // 载体是否有4个地址段和3个'.'\n    return (num <= 255 && dotCount == 3 && digitCount > 0);\n}\n", "test": "#include<assert.h>\nint main() {\n    assert(isValidIP(\"172.16.254.1\") == true);\n    assert(isValidIP(\"172.16.254.\") == false);\n    assert(isValidIP(\".254.255.0\") == false);\n    assert(isValidIP(\"1.2.3.4.5\") == false);\n    assert(isValidIP(\"123.456.78.90\") == false);\n    assert(isValidIP(\"123.045.067.089\") == true);\n\n    return 0;\n}\n"}
{"language": "c++", "domain": "network", "source": "gpt4+人工筛选；源文件地址/data/xw/c++dataset/network/already/337.cpp", "prompt": "#include<iostream>\n#include<sstream>\n#include<vector>\n#include<assert.h>\n\nusing namespace std;\n\n/*实现一个IP地址转换函数，将十进制格式的IP地址转为二进制的格式\n函数的格式定义为：vector<string> decimalToBinaryIP(string ip)\nip 为输入的十进制格式的IP地址，例如 \"192.168.0.1\"\n返回值为二进制格式的IP地址的每一位，例如对于\"192.168.0.1\"，返回值为 {\"11000000\", \"10101000\", \"00000000\", \"00000001\"}\n*/\n", "solution": "vector<string> decimalToBinaryIP(string ip) {\n    stringstream s(ip);\n    string block;\n    vector<string> result;\n    while (getline(s, block, '.')) {\n        int num = stoi(block);\n        string bin = \"\";\n        while (num) {\n            bin = to_string(num % 2) + bin;\n            num /= 2;\n        }\n        while (bin.length() < 8) {\n            bin = \"0\" + bin;\n        }\n        result.push_back(bin);\n    }\n    return result;\n}\n", "test": "int main() {\n    vector<string> result = decimalToBinaryIP(\"192.168.0.1\");\n    assert(result[0] == \"11000000\");\n    assert(result[1] == \"10101000\");\n    assert(result[2] == \"00000000\");\n    assert(result[3] == \"00000001\");\n\n    result = decimalToBinaryIP(\"255.255.255.0\");\n    assert(result[0] == \"11111111\");\n    assert(result[1] == \"11111111\");\n    assert(result[2] == \"11111111\");\n    assert(result[3] == \"00000000\");\n\n    result = decimalToBinaryIP(\"0.0.0.0\");\n    assert(result[0] == \"00000000\");\n    assert(result[1] == \"00000000\");\n    assert(result[2] == \"00000000\");\n    assert(result[3] == \"00000000\");\n\n    result = decimalToBinaryIP(\"1.1.1.1\");\n    assert(result[0] == \"00000001\");\n    assert(result[1] == \"00000001\");\n    assert(result[2] == \"00000001\");\n    assert(result[3] == \"00000001\");\n\n    result = decimalToBinaryIP(\"255.255.255.255\");\n    assert(result[0] == \"11111111\");\n    assert(result[1] == \"11111111\");\n    assert(result[2] == \"11111111\");\n    assert(result[3] == \"11111111\");\n\n    return 0;\n}\n"}
{"language": "c++", "domain": "network", "source": "gpt4+人工筛选；源文件地址/data/xw/c++dataset/network/already/277.cpp", "prompt": "#include <iostream>\n#include <cstring>\n#include <arpa/inet.h>\n/*调用inet.h实现从32位网络字节序整数转化为IPv4的点分十进制\nvoid convertToIp(const unsigned long addr, char* ipAddress)\naddr是32位网络字节序整数，ipAddress将存在转化后的IP地址，无返回值\n*/\n", "solution": "void convertToIp(const unsigned long addr, char* ipAddress) {\n    struct sockaddr_in sa;\n    sa.sin_addr.s_addr = addr;\n    strcpy(ipAddress, inet_ntoa(sa.sin_addr));\n}\n", "test": "#include <assert.h>\n#include <string.h>\nint main() {\n    char ipAddress[50];\n    convertToIp(-1, ipAddress);\n    assert(strcmp(ipAddress, \"255.255.255.255\") == 0);\n    convertToIp(0, ipAddress);\n    assert(strcmp(ipAddress, \"0.0.0.0\") == 0);\n    convertToIp(4294967295, ipAddress);\n    assert(strcmp(ipAddress, \"255.255.255.255\") == 0);\n    return 0;\n}\n"}
{"language": "c++", "domain": "network", "source": "gpt4+人工筛选；源文件地址/data/xw/c++dataset/network/already/112.cpp", "prompt": "#include <iostream>\n#include <cstring>\n\nusing namespace std;\n\n/*实现一个字符串函数，可以判断输入的字符串是不是一个有效的IP地址\n函数的格式定义为: bool isValidIP(string ip)\n参数ip是一个输入的字符串\n返回一个布尔值（true表示输入的字符串是一个有效的IP地址，false表示输入的字符串不是一个有效的IP地址）\n*/\n", "solution": "bool isValidIP(string ip) {\n    int dots = 0;\n    int nums = 1;\n    for(int i = 0; i < ip.size(); i++) {\n        if(ip[i] == '.') {\n            if(nums < 1 || nums > 3)\n                return false;\n            nums = 0;\n            dots++;\n            if(dots > 3)\n                return false;\n        }\n        else if(ip[i] >= '0' && ip[i] <= '9') {\n            if(nums == 0 && ip[i] == '0')\n                return false;\n            nums++;\n            if(nums > 3)\n                return false;\n        }\n        else {\n            return false;\n        }\n    }\n    if(nums < 1 || nums > 3 || dots < 3)\n        return false;\n    return true;\n}\n", "test": "#include<assert.h>\nint main() {\n    assert(isValidIP(\"192.168.1.1\") == false);\n    assert(isValidIP(\"255.255.255.0\") == false);\n    assert(isValidIP(\"255..255.255\") == false);\n    assert(isValidIP(\"192.168.1.256\") == false);\n    assert(isValidIP(\"1\") == false);\n\n    return 0;\n}\n"}
{"language": "c++", "domain": "network", "source": "gpt4+人工筛选；源文件地址/data/xw/c++dataset/network/already/190.cpp", "prompt": "#include <iostream>\n#include <sys/socket.h>\n#include <netinet/in.h>\n#include <arpa/inet.h>\n/* 调用socket.h, netinet.h和inet.h实现将字符串形式的ip地址转化为整数形式\nint stringToIntegerIP(const char* ip)\nip是以字符串形式表示的ip地址，返回以整数形式表示的ip地址\n*/\n", "solution": "int stringToIntegerIP(const char* ip) {\n    struct in_addr ip_addr;\n    inet_aton(ip, &ip_addr);\n    return ip_addr.s_addr;\n}\n", "test": "#include<assert.h>\n#include<string.h>\nint main() {\n    assert(stringToIntegerIP(\"192.168.1.0\") == htonl(3232235776) );\n    assert(stringToIntegerIP(\"10.0.0.0\") == htonl(167772160));\n    return 0;\n}\n"}
{"language": "c++", "domain": "network", "source": "gpt4+人工筛选；源文件地址/data/xw/c++dataset/network/already/175.cpp", "prompt": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\n/*\n实现一个函数，通过IPv4地址和子网掩码计算网络地址。\n函数的格式定义为：char* calculate_network_address(char* ip, char* mask)。\nip是输入的IPv4地址，mask是子网掩码。\nipv4地址和子网掩码的格式都是\"xxx.xxx.xxx.xxx\"，\nxxx的范围是0-255。\n返回网络地址的字符串。\n*/\n\n", "solution": "char* calculate_network_address(char* ip, char* mask) {\n    int ip_arr[4];\n    int mask_arr[4];\n    int net_addr[4];\n\n    sscanf(ip, \"%d.%d.%d.%d\", &ip_arr[0], &ip_arr[1], &ip_arr[2], &ip_arr[3]);\n    sscanf(mask, \"%d.%d.%d.%d\", &mask_arr[0], &mask_arr[1], &mask_arr[2], &mask_arr[3]);\n    \n    for(int i=0; i<4; i++) {\n        net_addr[i] = ip_arr[i] & mask_arr[i];\n    }\n    \n    char* result = (char*)malloc(16 * sizeof(char));\n    sprintf(result, \"%d.%d.%d.%d\", net_addr[0], net_addr[1], net_addr[2], net_addr[3]);\n    return result;\n}\n", "test": "#include<assert.h>\n#include<string.h>\nint main() {\n    assert(strcmp(calculate_network_address(\"192.168.0.1\", \"255.255.255.0\"), \"192.168.0.0\") == 0);\n    assert(strcmp(calculate_network_address(\"10.0.0.1\", \"255.0.0.0\"), \"10.0.0.0\") == 0);\n    assert(strcmp(calculate_network_address(\"192.168.1.1\", \"255.255.255.0\"), \"192.168.1.0\") == 0);\n    assert(strcmp(calculate_network_address(\"172.16.0.1\", \"255.255.0.0\"), \"172.16.0.0\") == 0);\n    assert(strcmp(calculate_network_address(\"10.1.1.1\", \"255.0.0.0\"), \"10.0.0.0\") == 0);\n}\n"}
{"language": "c++", "domain": "network", "source": "gpt4+人工筛选；源文件地址/data/xw/c++dataset/network/already/226.cpp", "prompt": "#include <iostream>\n#include <string>\n\nusing namespace std;\n\n/* 检查IP地址是否有效的函数。\n   函数定义为：bool checkIP(string ip)\n   输入的参数是IP地址字符串\n   如果IP地址有效，返回true；否则，返回false。\n   有效的IP地址必须有4个段，每个段的值在0-255之间。\n*/\n", "solution": "bool checkIP(string ip){\n    int parts[4]={0}, partCount = 0, partIndex = 0;\n    char c;\n    for(int i=0;i<ip.size();i++){\n        c = ip[i];\n        if(c == '.'){\n            partCount++;\n            partIndex = 0;\n            continue;\n        }\n        if(c<'0' || c>'9') return false;\n        parts[partCount] = parts[partCount]*10 + (c-'0');\n        if(parts[partCount]>255) return false;\n        partIndex++;\n        if(partIndex>3) return false;\n    }\n    if(partCount!=3) return false;\n    return true;\n}\n", "test": "#include<assert.h>\nint main() {\n    assert(checkIP(\"192.168.1.1\")==true);\n    assert(checkIP(\"255.255.255.255\")==true);\n    assert(checkIP(\"0.0.0.0\")==true);\n    assert(checkIP(\"256.0.0.0\")==false);\n    assert(checkIP(\"192.168.1\")==false);\n    return 0;\n}\n"}
{"language": "c++", "domain": "network", "source": "gpt4+人工筛选；源文件地址/data/xw/c++dataset/network/already/199.cpp", "prompt": "#include <iostream>\n#include <cassert>\n\nusing namespace std;\n\n/*判断给定的字符串是否是一个有效的IP地址\n输入是一个字符串\n函数的格式定义为：bool isValidIP(string IP);\n返回一个bool值，表示给定的字符串是否是一个有效的IP地址\n*/\n", "solution": "\nbool isValidIP(string IP) {\n    int cnt = 0, num = 0;\n    for(int i = 0; i < IP.size(); i++) {\n        if(IP[i] == '.') {\n            cnt++;\n            if(i == 0 || i == IP.size()-1 || IP[i+1] == '.' || num >= 256)\n                return false;\n            num = 0;\n        }\n        else {\n            if(!isdigit(IP[i])) return false;\n            num = num * 10 + IP[i]-'0';\n        }\n    }\n    if(cnt != 3 || num >= 256) return false;\n    return true;\n}\n\n", "test": "\nint main() {\n    assert(isValidIP(\"127.0.0.1\")==true);\n    assert(isValidIP(\"192.168.1.1\")==true);\n    assert(isValidIP(\"0.0.0.0\")==true);\n    assert(isValidIP(\"255.255.255.255\")==true);\n    assert(isValidIP(\"256.10.10.10\")==false);\n\n    return 0;\n}\n\n"}
{"language": "c++", "domain": "network", "source": "gpt4+人工筛选；源文件地址/data/xw/c++dataset/network/already/37.cpp", "prompt": "#include <iostream>\n#include <sstream>\n#include <string>\n\n/*\n * Parses an IP address string into its four segments.\n * @parameter ip_address: A string representing the IP address to be parsed. It is expected to be\n * in the form \"X.X.X.X\", where each X is a number between 0 and 255.\n * @returns: True if the parsing was successful, false otherwise.\n */\n", "solution": "\n// solution_start\n\nbool parse_ip(const std::string& ip_address, int& segment1, int& segment2, int& segment3, int& segment4) {\n    char dot;\n    std::istringstream ss(ip_address);\n    if (!(ss >> segment1 >> dot >> segment2 >> dot >> segment3 >> dot >> segment4)) return false;\n    if (segment1 < 0 || segment1 > 255) return false;\n    if (segment2 < 0 || segment2 > 255) return false;\n    if (segment3 < 0 || segment3 > 255) return false;\n    if (segment4 < 0 || segment4 > 255) return false;\n    return true;\n}\n\n// solution_end\n\n// test_start\n#include<assert.h>\nint main() {\n", "test": "    assert(segment1 == 192);\n    assert(segment2 == 168);\n    assert(segment3 == 1);\n    assert(segment4 == 1);\n\n    result = parse_ip(\"300.1.2.3\", segment1, segment2, segment3, segment4);\n    assert(result == false);\n\n    result = parse_ip(\"1.2.3\", segment1, segment2, segment3, segment4);\n    assert(result == false);\n    \n"}
{"language": "c++", "domain": "network", "source": "gpt4+人工筛选；源文件地址/data/xw/c++dataset/network/already/202.cpp", "prompt": "#include<iostream>\n#include<string>\n\nusing namespace std;\n/* 用于检查一个字符串是否为一个有效的IPv4地址的函数，有效的IPv4地址应为四个0-255的整数，通过点分隔。\n具体函数格式定义为：bool isIPv4(string ip) */\n", "solution": "bool isIPv4(string ip) {\n    int dots = 0; // Count of periods\n    int numbers = 0; // Count of Numbers\n    string numString = \"\";\n\n    for (char ch : ip) {\n        if (ch == '.') {\n            dots++;\n            if (stoi(numString) < 0 || stoi(numString) > 255) {\n                return false;\n            }\n            numbers = 0;\n            numString = \"\";\n        }\n        else if (isdigit(ch)) {\n            numbers++;\n            numString += ch;\n            if (numbers > 3) {\n                return false;\n            }\n        }\n        else {\n            return false;\n        }\n    }\n\n    if (dots != 3 || stoi(numString) < 0 || stoi(numString) > 255) {\n        return false;\n    }\n\n    return true;\n}\n", "test": "#include<assert.h>\nint main() {\n    assert(isIPv4(\"192.168.1.1\") == true);\n    assert(isIPv4(\"255.255.255.255\") == true);\n    assert(isIPv4(\"0.0.0.0\") == true);\n    assert(isIPv4(\"256.1.1.1\") == false);\n    assert(isIPv4(\"192.168.1\") == false);\n    return 0;\n}\n"}
{"language": "c++", "domain": "network", "source": "gpt4+人工筛选；源文件地址/data/xw/c++dataset/network/already/52.cpp", "prompt": "/*\n1. `initForwardTable`函数：初始化一个2D数组用于代表转发表。\n2. `updateTable`函数：更新转发表，添加新的条目。\n3. `deleteEntry`函数：在转发表中删除一个条目。\n4. `forwardPacket`函数：转发一个数据包到其目的地。\n*/\n", "solution": "#include <utility>\n\n// 初始化转发表，一个N x 2的二维数组，每一行代表一个条目，第一列是目的地，第二列是下一跳\nvoid initForwardTable(std::vector<std::pair<int, int>>& table);\n\n// 更新转发表，添加新的条目\nvoid updateTable(std::vector<std::pair<int, int>>& table, int dest, int nextHop);\n\n// 删除转发表中的一个条目\nvoid deleteEntry(std::vector<std::pair<int, int>>& table, int dest);\n\n// 用转发表转发一个数据包，返回目的地\nint forwardPacket(std::vector<std::pair<int, int>>& table, int packetDest);\n// input_end\n\n// solution_start\nvoid initForwardTable(std::vector<std::pair<int, int>>& table) {\n    // For simplicity, we initialize the table with 0 entries\n    table.clear();\n}\n\nvoid updateTable(std::vector<std::pair<int, int>>& table, int dest, int nextHop) {\n    // If destination exists, update the next hop, otherwise, append the entry\n    for(auto & i : table){\n        if(i.first == dest){\n            i.second = nextHop;\n            return;\n        }\n    }\n    table.emplace_back(dest, nextHop);\n}\n\n", "test": "    for(auto it = table.begin(); it != table.end(); ++it){\n        if ((*it).first == dest) {\n            table.erase(it);\n            return;\n        }\n    }\n}\n\nint forwardPacket(std::vector<std::pair<int, int>>& table, int packetDest) {\n"}
{"language": "c++", "domain": "network", "source": "gpt4+人工筛选；源文件地址/data/xw/c++dataset/network/already/223.cpp", "prompt": "#include <iostream>\n\nusing namespace std;\n\n/* 实现一个简单的检查IPv4地址格式的函数\n函数的格式定义为：bool isValidIpAddress(string ip)\nip 是一个字符串，代表IPv4的地址\nIPv4的地址是四个0-255的数字，用\".\"分隔\n如果这个ip是有效的，则返回true，否则返回false\n*/\n", "solution": "bool isValidIpAddress(string ip) {\n    //1.IP地址为空\n    if (ip.empty()) {\n      return false;\n    }\n\n    //2.IP地址长度超过15\n    if (ip.size() > 15) {\n      return false;\n    }\n\n    int dotNum = 0, num = 0;\n    for (int i = 0; i < ip.size(); ++i) {\n\n      //3.IP地址中有非法字符\n      if ((ip[i] < '0' || ip[i] > '9') && ip[i] != '.') {\n        return false;\n      }\n\n      //4.IP地址数字中有空格\n      if (ip[i] == ' ') {\n        return false;\n      }\n\n      //5.IP地址中'.'连续出现\n      if (i > 0 && ip[i] == '.' && ip[i - 1] == '.') {\n        return false;\n      }\n\n      //计算'.'出现的次数，且'.'不位于开头和结尾\n      if (ip[i] == '.') {\n        ++dotNum;\n        num = 0;\n\n        //6.IP地址以'.'结尾\n        if (i == ip.size() - 1) {\n          return false;\n        }\n        continue;\n      }\n\n      num = num * 10 + (ip[i] - '0');\n\n      //7.IP地址以'.'开头\n      if (i > 0 && ip[i - 1] == '.' && num == 0) {\n        return false;\n      }\n\n      //8.IP地址的每一段值大于255\n      if (num > 255) {\n        return false;\n      }\n    }\n\n    //9.'.'的数量不对，'.'数量应为3\n    if (dotNum != 3) {\n      return false;\n    }\n  return true;\n}\n", "test": "#include<assert.h>\nint main() {\n    assert(isValidIpAddress(\"192.168.1.1\") == true);\n    assert(isValidIpAddress(\"0.0.0.0\") == false);\n    assert(isValidIpAddress(\"255.255.255.255\") == true);\n    assert(isValidIpAddress(\".192.168.1.1\") == false);\n    assert(isValidIpAddress(\"192.168.1.\") == false);\n    assert(isValidIpAddress(\"192.168..1\") == false);\n    assert(isValidIpAddress(\"192.168.01.1\") == false);\n    assert(isValidIpAddress(\"192.168.256.1\") == false);\n    assert(isValidIpAddress(\"192.168.1.1.\") == false);\n    assert(isValidIpAddress(\"192.168.1 .1\") == false);\n\n    return 0;\n}\n"}
{"language": "c++", "domain": "network", "source": "gpt4+人工筛选；源文件地址/data/xw/c++dataset/network/already/232.cpp", "prompt": "#include <iostream>\n#include <arpa/inet.h>\n\n/* 检查一个IP地址字符串是否有效\nbool isValidIP(const char *ip)\n输入IP地址字符串，返回真假 \n*/\n", "solution": "bool isValidIP(const char *ip) {\n    struct sockaddr_in sa;\n    // inet_pton() 是一个IP地址转换函数，可以在IP地址表示的格式（点分十进制和冒号十六进制）之间转换，如果输入不是有效的地址字符串，则返回值将为零\n    int result = inet_pton(AF_INET, ip, &(sa.sin_addr));\n    return result != 0; \n}\n", "test": "#include<assert.h>\nint main() {\n    const char *ip1=\"123.123.123.123\";\n    assert(isValidIP(ip1) == true); // \n    const char *ip2=\"255.255.255.256\"; \n    assert(isValidIP(ip2) == false); \n    const char *ip3=\"192.0.2.0\";\n    assert(isValidIP(ip3) == true); \n    const char *ip4=\"0.0.0.0\";\n    assert(isValidIP(ip4) == true); \n    const char *ip5=\"www.google.com\";\n    assert(isValidIP(ip5) == false); \n    return 0;\n}\n"}
{"language": "c++", "domain": "network", "source": "gpt4+人工筛选；源文件地址/data/xw/c++dataset/network/already/346.cpp", "prompt": "#include <iostream>\n#include <string>\n#include <vector>\n/*将一个IPv4地址转为IP数字\nstd::string IPv4ToNum(const std::string &Ip)\n参数Ip是IPv4地址，需要满足形如“192.168.1.1”的格式。\n该函数将Ip转为一个数字，该数字是IPv4地址的整数表示。\n*/\n", "solution": "std::string IPv4ToNum(const std::string &Ip) {\n    unsigned long res = 0;\n    std::vector<std::string> parts;\n    size_t pos = 0, found = Ip.find('.');\n    while(found != std::string::npos){\n        parts.push_back(Ip.substr(pos, found - pos));\n        pos = found+1;\n        found = Ip.find('.', pos);\n    }\n    parts.push_back(Ip.substr(pos));\n\n    for(auto & part : parts){\n        res = res * 256 + std::stoul(part);\n    }\n    return std::to_string(res);\n}\n", "test": "#include<assert.h>\nint main() {\n    assert(IPv4ToNum(\"127.0.0.1\")==\"2130706433\");\n    assert(IPv4ToNum(\"255.255.255.255\")==\"4294967295\");\n    assert(IPv4ToNum(\"0.0.0.0\")==\"0\");\n    return 0;\n}\n"}
{"language": "c++", "domain": "network", "source": "gpt4+人工筛选；源文件地址/data/xw/c++dataset/network/already/214.cpp", "prompt": "#include <iostream>\n#include <cstring>\n#include <netinet/in.h>\n#include <arpa/inet.h>\n/*调用inet.h将点分十进制IP地址转换为二进制格式\nvoid convertIPToBinary(const char *ipAddress, char *binaryIP)\nipAddress是IP地址，binaryIP是用来保存转换后的二进制IP地址的字符数组\n*/\n", "solution": "void convertIPToBinary(const char *ipAddress, char *binaryIP) {\n    struct in_addr in;\n    inet_aton(ipAddress, &in);\n    unsigned long ip = in.s_addr;\n    for (int i = 0; i < 32; i++) {\n        if (ip & 1) {\n            binaryIP[31 - i] = '1';\n        } else {\n            binaryIP[31 - i] = '0';\n        }\n        ip >>= 1;\n    }\n    binaryIP[32] = '\\0';\n}\n", "test": "#include<assert.h>\nint main() {\n    char binaryIP[33];\n    const char *ipAddress1=\"192.168.31.22\";\n    convertIPToBinary(ipAddress1,binaryIP);\n    assert(strcmp(binaryIP,\"00010110000111111010100011000000\")==0);\n    const char *ipAddress2=\"1.2.3.4\";\n    convertIPToBinary(ipAddress2,binaryIP);\n    assert(strcmp(binaryIP,\"00000100000000110000001000000001\")==0);\n    const char *ipAddress3=\"255.255.255.255\";\n    convertIPToBinary(ipAddress3,binaryIP);\n    assert(strcmp(binaryIP,\"11111111111111111111111111111111\")==0);\n    const char *ipAddress4=\"0.0.0.0\";\n    convertIPToBinary(ipAddress4,binaryIP);\n    assert(strcmp(binaryIP,\"00000000000000000000000000000000\")==0);\n    const char *ipAddress5=\"127.0.0.1\";\n    convertIPToBinary(ipAddress5,binaryIP);\n    assert(strcmp(binaryIP,\"00000001000000000000000001111111\")==0);\n    return 0;\n}\n"}
{"language": "c++", "domain": "network", "source": "gpt4+人工筛选；源文件地址/data/xw/c++dataset/network/already/343.cpp", "prompt": "#include <iostream>\n#include <cstring>\n#include <netinet/in.h>\n#include <arpa/inet.h>\n/*调用inet.h实现将32位网络字节序整数转换为IPv4的点分十进制\nconst char *convertToIPAddress(unsigned long networkBytes)\nnetworkBytes是32位网络字节序整数，返回转换后的IPv4地址，错误返回NULL\n*/\n", "solution": "const char *convertToIPAddress(unsigned long networkBytes) {\n    struct sockaddr_in sa;\n    sa.sin_addr.s_addr = networkBytes;   \n    char *ipAddress = inet_ntoa(sa.sin_addr);\n    return ipAddress;\n}\n", "test": "#include<assert.h>\n#include<string.h>\nint main() {\n    // 4294967295是255.255.255.255的网络字节序表示\n    unsigned long networkBytes1 = 4294967295;\n    assert(strcmp(convertToIPAddress(networkBytes1), \"255.255.255.255\")==0);\n    // 0是0.0.0.0的网络字节序表示\n    unsigned long networkBytes2 = 0;\n    assert(strcmp(convertToIPAddress(networkBytes2), \"0.0.0.0\")==0);\n    // 16885952是192.168.1.1的网络字节序表示\n    unsigned long networkBytes3 = 16885952;\n    assert(strcmp(convertToIPAddress(networkBytes3), \"192.168.1.1\")==0);\n    return 0;\n}\n"}
{"language": "c++", "domain": "network", "source": "gpt4+人工筛选；源文件地址/data/xw/c++dataset/network/already/13.cpp", "prompt": "#include <iostream>\n#include <vector>\nusing namespace std;\n\n/*实现一个简易版的路由器类\n* 该路由器记录了其连接的其他路由器，以及通过这些路由器可以到达的网络\n* 通过 Bellman-Ford 算法更新和计算最短路径\n*/\n\nclass Router {\npublic:\n    //路由器的标识\n    int id;\n\n    //构造路由器\n    Router(int id);\n\n    //添加网络连接\n    void add_connection(Router* r, int cost);\n\n    //使用 Bellman-Ford 算法更新距离\n    void update_distance();\n\n    //获取到特定路由器的距离\n    int get_distance(Router* r);\n\nprivate:\n    vector<pair<Router*, int>> connections;\n    vector<pair<Router*, int>> distance;\n};\n\n", "solution": "Router::Router(int id) : id(id) {}\n\nvoid Router::add_connection(Router* r, int cost) {\n    connections.push_back(make_pair(r, cost));\n    distance.push_back(make_pair(r, cost));\n}\n\nvoid Router::update_distance() {\n    for (int i = 0; i < distance.size(); i++) {\n        for (pair<Router*, int>& conn : connections) {\n            int new_distance = conn.second + conn.first->get_distance(this);\n            if (distance[i].first == conn.first && new_distance < distance[i].second) {\n                distance[i].second = new_distance;\n            }\n        }\n    }\n}\n\nint Router::get_distance(Router* r) {\n    for(int i = 0; i < distance.size(); i++) {\n        if(distance[i].first == r) {\n            return distance[i].second;\n        }\n    }\n    return -1;\n}\n", "test": "int main() {\n    Router r1(1), r2(2), r3(3);\n    r1.add_connection(&r2, 10);\n    r2.add_connection(&r3, 1);\n    r1.update_distance();\n    r2.update_distance();\n    r3.update_distance();\n    assert(r1.get_distance(&r2) == 9);\n    assert(r1.get_distance(&r3) == -1);\n    assert(r2.get_distance(&r3) == 0);\n\n    r1.add_connection(&r2, 3);\n    r1.update_distance();\n    r2.update_distance();\n    r3.update_distance();\n    assert(r1.get_distance(&r2) == 2);\n\n    return 0;\n}\n"}
{"language": "c++", "domain": "network", "source": "gpt4+人工筛选；源文件地址/data/xw/c++dataset/network/already/340.cpp", "prompt": "#include <iostream>\n#include <vector>\nusing namespace std;\n\n/*\n功能：将十进制的IP地址转换为二进制的IP地址\n函数的定义形式：vector<int> convertIPtoBinary(int ip1, int ip2, int ip3, int ip4)\nip1,ip2,ip3,ip4 分别为十进制IP地址的四个字段 \n\n返回值是一个vector，包含32个int类型的元素，每个元素为0或1，表示二进制的IP地址\n*/\n", "solution": "vector<int> convertIPtoBinary(int ip1, int ip2, int ip3, int ip4) {\n    vector<int> binaryIP(32);\n    for (int i = 7; i >= 0; --i) {\n        binaryIP[i] = ip1%2;\n        ip1 = ip1/2;\n    }\n    for (int i = 15 ; i >= 8; --i) {\n        binaryIP[i] = ip2%2;\n        ip2 = ip2/2;\n    }\n    for (int i = 23 ; i >= 16; --i) {\n        binaryIP[i] = ip3%2;\n        ip3 = ip3/2;\n    }\n    for (int i = 31 ; i >= 24; --i) {\n        binaryIP[i] = ip4%2;\n        ip4 = ip4/2;\n    }    \n    return binaryIP;\n}\n", "test": "#include<assert.h>\nint main() {\n    vector<int> v1 = convertIPtoBinary(192, 168, 1, 1);\n    vector<int> v2 = {1,1,0,0,0,0,0,0,1,0,1,0,1,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,1};\n    for (int i = 0 ; i < 32; ++i) {\n        if(v1[i] != v2[i])\n        assert(v1[i] == v2[i]);\n    }\n\n    vector<int> v3 = convertIPtoBinary(10, 0, 0, 1);\n    vector<int> v4 = {0,0,0,0,1,0,1,0, 0,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,1};\n    for (int i = 0 ; i < 32; ++i) {\n        assert(v3[i] == v4[i]);\n    }\n\n    return 0;\n}\n"}
{"language": "c++", "domain": "network", "source": "gpt4+人工筛选；源文件地址/data/xw/c++dataset/network/already/19.cpp", "prompt": "#include <iostream>\n#include <cstring>\n#include <cassert>\nusing namespace std;\n\n/*\n* 实现一个简单的IP地址与子网掩码计算\n创建了一个IP地址的类。使用两个独立方法分别设置IP地址和子网掩码，然后计算和获取网络地址\n*/\nclass IPAddress {\npublic:\n    IPAddress();\n    void setIP(const string input);\n    void setMask(const string input);\n    string getNetworkAddress();\n\nprivate:\n    string ip;\n    string mask;\n};\n\n", "solution": "IPAddress::IPAddress() {\n    ip = \"\";\n    mask = \"\";\n}\n\nvoid IPAddress::setIP(const string input) {\n    ip = input;\n}\n\nvoid IPAddress::setMask(const string input) {\n    mask = input;\n}\n\nstring IPAddress::getNetworkAddress() {\n    int ipArr[4];\n    int maskArr[4];\n    sscanf(ip.c_str(), \"%d.%d.%d.%d\", &ipArr[0], &ipArr[1], &ipArr[2], &ipArr[3]);\n    sscanf(mask.c_str(), \"%d.%d.%d.%d\", &maskArr[0], &maskArr[1], &maskArr[2], &maskArr[3]);\n\n    string networkAddr = \"\";\n    for (int i = 0; i < 4; ++i) {\n        if (i > 0) networkAddr += \".\";\n        networkAddr += to_string(ipArr[i] & maskArr[i]);\n    }\n    return networkAddr;\n}\n\n", "test": "int main() {\n    IPAddress ipcalc;\n\n    // Test 1: IP:192.168.1.1, Subnet Mask:255.255.255.0\n    ipcalc.setIP(\"192.168.1.1\");\n    ipcalc.setMask(\"255.255.255.0\");\n    assert(ipcalc.getNetworkAddress() == \"192.168.1.0\");\n\n    // Test 2: IP:10.0.0.1, Subnet Mask:255.0.0.0\n    ipcalc.setIP(\"10.0.0.1\");\n    ipcalc.setMask(\"255.0.0.0\");\n    assert(ipcalc.getNetworkAddress() == \"10.0.0.0\");\n\n    // Test 3: IP:172.16.0.1, Subnet Mask:255.255.0.0\n    ipcalc.setIP(\"172.16.0.1\");\n    ipcalc.setMask(\"255.255.0.0\");\n    assert(ipcalc.getNetworkAddress() == \"172.16.0.0\");\n\n    // Test 4: IP:102.51.10.221, Subnet Mask:255.255.255.192\n    ipcalc.setIP(\"102.51.10.221\");\n    ipcalc.setMask(\"255.255.255.192\");\n    assert(ipcalc.getNetworkAddress() == \"102.51.10.192\");\n\n    // Test 5: IP:198.51.100.25, Subnet Mask:255.255.255.128\n    ipcalc.setIP(\"198.51.100.25\");\n    ipcalc.setMask(\"255.255.255.128\");\n    assert(ipcalc.getNetworkAddress() == \"198.51.100.0\");\n\n    return 0;\n}\n"}
{"language": "c++", "domain": "network", "source": "gpt4+人工筛选；源文件地址/data/xw/c++dataset/network/already/109.cpp", "prompt": "#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n\n/* \n实现一个IP地址分类函数，传入一个IP地址的字符串，返回其分类（A、B、C、D、E）。\n函数的格式定义为：char get_ip_class(const char* ip)\nip是输入的IP地址字符串。\n*/\n\n", "solution": "char get_ip_class(const char* ip) {\n    // get first octet\n    char first_octet_str[4];\n    int i = 0;\n    while (ip[i] != '.') {\n        first_octet_str[i] = ip[i];\n        i++;\n    }\n    first_octet_str[i] = '\\0';\n    int first_octet = atoi(first_octet_str);\n\n    // classify IP address\n    if (first_octet >=1 && first_octet < 128)\n        return 'A';\n    else if (first_octet >=128 && first_octet <192)\n        return 'B';\n    else if (first_octet >=192 && first_octet <224)\n        return 'C';    \n    else if (first_octet >=224 && first_octet <240)\n        return 'D';\n    else if (first_octet >=240 && first_octet <=255)\n        return 'E';\n    else\n        return 'U'; // Undefined\n}\n", "test": "#include <assert.h>\nint main() {\n    assert(get_ip_class(\"1.1.1.1\") == 'A');\n    assert(get_ip_class(\"128.1.1.1\") == 'B');\n    assert(get_ip_class(\"192.168.1.1\") == 'C');\n    assert(get_ip_class(\"224.0.0.1\") == 'D');\n    assert(get_ip_class(\"240.0.0.1\") == 'E');\n}\n"}
{"language": "c++", "domain": "network", "source": "gpt4+人工筛选；源文件地址/data/xw/c++dataset/network/already/166.cpp", "prompt": "#include <stdio.h>\n#include <arpa/inet.h>\n/*\n验证IP地址的格式是否正确\nint isValidIP(const char *ipStr)\n接收一个字符串作为参数\n如果字符串是有效的IPv4地址，返回1，否则返回0\n*/\n", "solution": "int isValidIP(const char *ipStr) {\n    struct sockaddr_in sa;\n    int result = inet_pton(AF_INET, ipStr, &(sa.sin_addr));\n    return (result != 0);\n}\n", "test": "#include<assert.h>\nint main() {\n    const char *ip1=\"127.0.0.1\";\n    assert(isValidIP(ip1) == 1); // \"127.0.0.1\" 是有效的ip\n    const char *ip2=\"255.300.255.0\";\n    assert(isValidIP(ip2) == 0); // \"255.300.255.0\" 是无效的ip\n    const char *ip3=\"192.168.1.1\";\n    assert(isValidIP(ip3) == 1); // \"192.168.1.1\" 是有效的ip\n    const char *ip4=\"123.456.789.0\";\n    assert(isValidIP(ip4) == 0); // \"123.456.789.0\" 是无效的ip\n    const char *ip5=\"0.0.0.0\";\n    assert(isValidIP(ip5) == 1); // \"0.0.0.0\" 是有效的ip\n    return 0;\n}\n"}
