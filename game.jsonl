{"language": "c++", "domain": "game", "source": "gpt4+人工筛选；源文件地址/data/xw/c++dataset/game/already/270.cpp", "prompt": "#include <iostream>\nusing namespace std;\n\n/* 以井字棋为例：实现游戏胜负判定函数\n函数格式定义：char tictactoeResult(char board[3][3]);\nboard表示井字棋盘面，初始化为3x3的矩阵，其中'X'表示玩家X的棋子，'O'表示玩家O的棋子，'-'表示该格为空\n若X方获胜，则返回'X', 若O方获胜返回'O', 若游戏未结束，返回'-', 若平局，返回'D'\n*/\n\n", "solution": "char tictactoeResult(char board[3][3]) {\n    // 检查行\n    for(int i = 0; i < 3; i++) {\n        if(board[i][0] == board[i][1] && board[i][0] == board[i][2]) {\n            if(board[i][0] != '-') {\n                return board[i][0];\n            }\n        }\n    }\n    // 检查列\n    for(int i = 0; i < 3; i++) {\n        if(board[0][i] == board[1][i] && board[0][i] == board[2][i]) {\n            if(board[0][i] != '-') {\n                return board[0][i];\n            }\n        }\n    }\n    // 检查对角线\n    if(board[0][0] == board[1][1] && board[0][0] == board[2][2]) {\n        if(board[0][0] != '-') {\n            return board[0][0];\n        }\n    }\n    if(board[0][2] == board[1][1] && board[0][2] == board[2][0]) {\n        if(board[0][2] != '-') {\n            return board[0][2];\n        }\n    }\n    \n    // 检查是否为平局\n    for (int i = 0; i < 3; i++) {\n        for (int j = 0; j < 3; j++) {\n            if (board[i][j] == '-')\n                return '-';\n        }\n    }\n    return 'D';\n}\n", "test": "#include <assert.h>\nint main() {\n    char board1[3][3] = {{'X', '-', 'O'}, {'-', 'X', '-'}, {'O', '-', 'X'}};\n    assert(tictactoeResult(board1) == 'X');\n\n    char board2[3][3] = {{'O', 'X', 'O'}, {'-', 'X', '-'}, {'O', '-', 'X'}};\n    assert(tictactoeResult(board2) == '-');\n\n    char board3[3][3] = {{'X', 'X', 'O'}, {'X', 'O', 'O'}, {'O', 'X', 'X'}};\n    assert(tictactoeResult(board3) == 'O');\n\n    char board4[3][3] = {{'-', 'X', 'O'}, {'X', '-', 'O'}, {'O', 'X', '-'}};\n    assert(tictactoeResult(board4) == '-');\n    \n    char board5[3][3] = {{'O', 'X', 'X'}, {'X', 'O', 'O'}, {'O', 'X', 'X'}};\n    assert(tictactoeResult(board5) == 'D');\n    return 0; \n}\n"}
{"language": "c++", "domain": "game", "source": "gpt4+人工筛选；源文件地址/data/xw/c++dataset/game/already/207.cpp", "prompt": "#include <iostream>\n\nusing namespace std;\n\n/*实现21点游戏的函数\n函数的格式定义为：int BlackJackGame(int player1[], int player2[], int cardNum)\nplayer1[]和player2[]是数组，表示两个玩家手中的牌\ncardNum是手中牌的数量，我们假设cardNum在1到10之间\n返回一个表示谁赢的数字（0表示平局，1表示玩家1赢，2表示玩家2赢）\n*/\n", "solution": "int BlackJackGame(int player1[10], int player2[10], int cardNum) {\n    int sum1 = 0;\n    int sum2 = 0;\n    for(int i=0; i<cardNum; i++){\n        sum1 += player1[i];\n        sum2 += player2[i];\n    }\n    if(sum1 > 21){\n        sum1 = 0;\n    }\n    if(sum2 > 21){\n        sum2 = 0;\n    }\n    if(sum1 > sum2){\n        return 1;\n    }else if(sum1 < sum2){\n        return 2;\n    }\n    return 0;\n}\n", "test": "#include<assert.h>\nint main() {\n    int player1[10] = {1, 5, 9, 4, 3};\n    int player2[10] = {2, 2, 4, 11, 3};\n    \n    int player3[10] = {10, 8, 4};\n    int player4[10] = {10, 8, 3};\n    \n    int player5[10] = {2, 2, 2, 2, 2, 5};\n    int player6[10] = {1,1,1,1,1,1,6};\n    \n    int player7[10] = {2,10,10};\n    int player8[10] = {1,11,11};\n\n    assert(BlackJackGame(player1,player2,5)==0);\n    assert(BlackJackGame(player3,player4,3)==2);\n    assert(BlackJackGame(player5,player6,6)==1);\n    assert(BlackJackGame(player7,player8,3)==0);\n\n    return 0;\n}\n"}
{"language": "c++", "domain": "game", "source": "gpt4+人工筛选；源文件地址/data/xw/c++dataset/game/already/117.cpp", "prompt": "#include <iostream>\n#include <vector>\n\nusing namespace std;\n\n/*实现射击游戏的计分规则\n函数的格式定义为：int shootingGame(vector<int> scores)\nscores 是一个整数数组，表示玩家每次射击的得分（+10表示击中，-5表示未击中）,击中得10分，未击中不扣分\n返回一个整数，表示游戏结束时的最终分数，如果连续三次未击中，则游戏立即结束\n*/\n", "solution": "int shootingGame(vector<int> scores) {\n    int final_score = 0, miss_count = 0;\n    for (auto score : scores) {\n        if (score == -5) {\n            miss_count++;\n            if (miss_count == 3) break;\n        } else {\n            final_score += score;\n            miss_count = 0;\n        }\n    }\n    return final_score;\n}\n", "test": "#include<assert.h>\nint main() {\n    vector<int> scores1 = {10, 10, -5, 10, -5, -5, 10};\n    vector<int> scores2 = {-5, 10, 10, -5, -5, -5};\n    vector<int> scores3 = {10, 10, 10, 10, -5, -5, -5, 10};\n    vector<int> scores4 = {10, 10, -5, 10, 10, -5, -5, -5, 10};\n\n    assert(shootingGame(scores1)==40);\n    assert(shootingGame(scores2)==20);\n    assert(shootingGame(scores3)==40);\n    assert(shootingGame(scores4)==40);\n\n    return 0;\n}\n"}
{"language": "c++", "domain": "game", "source": "gpt4+人工筛选；源文件地址/data/xw/c++dataset/game/already/105.cpp", "prompt": "#include <iostream>\n#include <vector>\n\nusing namespace std;\n/*\ndetermine_winner 执行函数判断井字棋游戏中是否有玩家胜出\nvector<vector<int>> board 二维数组表示游戏棋盘，1代表玩家一，2代表玩家二\n返回值：1，玩家一胜出；2，玩家二胜出；0，无人胜出，游戏还在进行中；\n*/\nint determine_winner(vector<vector<int>>& board);\n", "solution": "int determine_winner(vector<vector<int>>& board) {\n    // Check horizontal lines\n    for (int i = 0; i < 3; i++) {\n        if (board[i][0] != 0 && board[i][0] == board[i][1] && board[i][1] == board[i][2])\n            return board[i][0];\n    }\n\n    // Check vertical lines\n    for (int i = 0; i < 3; i++) {\n        if (board[0][i] != 0 && board[0][i] == board[1][i] && board[1][i] == board[2][i])\n            return board[0][i];\n    }\n\n    // Check diagonals\n    if (board[0][0] != 0 && board[0][0] == board[1][1] && board[1][1] == board[2][2])\n        return board[0][0];\n    if (board[0][2] != 0 && board[0][2] == board[1][1] && board[1][1] == board[2][0])\n        return board[0][2];\n\n    // No one has won yet\n    return 0;\n}\n", "test": "#include<assert.h>\nint main() \n{\n    vector<vector<int>> game1{\n        {1, 2, 1},\n        {0, 1, 2},\n        {2, 1, 1}\n    };\n\n    vector<vector<int>> game2{\n        {2, 2, 2},\n        {0, 1, 0},\n        {1, 0, 1}\n    };\n\n    vector<vector<int>> game3{\n        {2, 1, 2},\n        {2, 1, 1},\n        {1, 2, 1}\n    };\n\n    vector<vector<int>> game4{\n        {1, 0, 2},\n        {2, 1, 0},\n        {2, 0, 1}\n    };\n\n    assert(determine_winner(game1) == 1);\n    assert(determine_winner(game2) == 2);\n    assert(determine_winner(game3) == 0);\n    assert(determine_winner(game4) == 1);\n\n    return 0;\n}\n"}
{"language": "c++", "domain": "game", "source": "gpt4+人工筛选；源文件地址/data/xw/c++dataset/game/already/30.cpp", "prompt": "#include <iostream>\n#include <vector>\nusing namespace std;\n\n/*\n此程序主要用于实现一个简单的井字棋游戏,包括以下功能：\n\n1. 初始化棋盘\n  void initializeBoard(vector<vector<char>> &board)\n  此函数没有输入，但会初始化一个空的3x3井字棋棋盘。\n", "solution": "  此函数检查当前棋盘状态,如果有玩家胜利返回该玩家的标记('X'或'O'),没有玩家胜利则返回'N'.\n\n3. 玩家落子\n  bool makeMove(vector<vector<char>> &board, int row, int col, char player)\n  此函数从玩家接收一步棋(行和列的位置以及player的标记O或者X),如果此位置可以下棋，那么更新棋盘并返回true，否则返回false.\n*/\n// input_end\n\n// solution_start\nvoid initializeBoard(vector<vector<char>> &board) {\n  board = vector<vector<char>>(3, vector<char>(3, ' '));\n}\n\nchar checkWin(const vector<vector<char>> &board) {\n  // 左到右\n  for(int i = 0; i < 3; ++i) {\n    if(board[i][0] == board[i][1] && board[i][1] == board[i][2] && board[i][0] != ' ') {\n      return board[i][0];\n    }\n  }\n\n  // 上到下\n", "test": "    }\n  }\n\n  // 主对角线\n  if(board[0][0] == board[1][1] && board[1][1] == board[2][2] && board[0][0] != ' ') {\n    return board[0][0];\n  }\n\n  // 副对角线\n  if(board[0][2] == board[1][1] && board[1][1] == board[2][0] && board[0][2] != ' ') {\n    return board[0][2];\n  }\n\n  return 'N';\n}\n\nbool makeMove(vector<vector<char>> &board, int row, int col, char player) {\n  if (board[row][col] != ' ') {\n    return false;\n  } \n  board[row][col] = player;\n  return true;\n}\n// solution_end\n\n// test_start\n#include <cassert>\nint main() {\n\n  // 初始化棋盘\n  vector<vector<char>> board; \n  initializeBoard(board);\n\n  assert(board.size() == 3);\n"}
{"language": "c++", "domain": "game", "source": "gpt4+人工筛选；源文件地址/data/xw/c++dataset/game/already/198.cpp", "prompt": "#include <iostream>\n#include <vector>\n\nusing namespace std;\n\n/*实现一个简单的矩阵版的俄罗斯方块游戏\n矩阵具有固定大小(例如10x10)，每个格子可以为0(空)或1(块)\n\"块\"会从顶部一行一行的下落到底部，或者到达其他块的顶部\n俄罗斯方块(russian_square)接收一个当前矩阵和一个块的位置，返回下一个矩阵和块的位置\n注意块的位置是从1开始的，当块的位置返回为0表示游戏结束\n*/\n", "solution": "pair<vector<vector<int>>,int> russian_square(vector<vector<int>> matrix, int blockPosition) {\n    for (int i = 0; i < matrix.size(); ++i) {\n        // If the current row is not empty or the block is at the bottom, the block stops falling\n        if (matrix[i][blockPosition - 1] == 1 || i == matrix.size() - 1) {\n            if(i==0)\n                return {{}, 0};\n            else\n                matrix[i - 1][blockPosition - 1] = 1;\n            return {matrix, blockPosition};\n        }\n    }\n    \n    // The block position does not change\n    return {matrix, blockPosition};\n}\n", "test": "#include<assert.h>\nint main() {\n    vector<vector<int>> matrix = {{0, 0, 0, 0, 0},\n                                  {0, 0, 0, 0, 0},\n                                  {0, 0, 0, 0, 0},\n                                  {0, 0, 0, 0, 0},\n                                  {0, 0, 0, 1, 0}};\n    int blockPosition = 3;\n    auto p = russian_square(matrix, blockPosition);\n    assert(p.first[4][2] == 0);\n    assert(p.second == 3);\n\n    p = russian_square(p.first, blockPosition);\n    assert(p.first[3][2] == 1);\n    assert(p.second == 3);\n\n    matrix = {{1, 0, 0, 0, 0},\n              {0, 0, 0, 0, 0},\n              {0, 0, 0, 0, 0},\n              {0, 0, 0, 0, 0},\n              {0, 0, 0, 1, 0}};\n    blockPosition = 3;\n    p = russian_square(matrix, blockPosition);\n    assert(p.second == 3);\n\n    return 0;\n}\n"}
{"language": "c++", "domain": "game", "source": "gpt4+人工筛选；源文件地址/data/xw/c++dataset/game/already/162.cpp", "prompt": "#include <iostream>\n#include <vector>\n\nusing namespace std;\n\n/*实现一个简短的剪刀石头布小游戏\n输入两个参数，分别代表两个玩家的出招（0代表剪刀，1代表石头，2代表布）\n函数的定义：int rockPaperScissors(int player1, int player2);\n玩家的出招需要为一个0-2之间的数字\n返回一个表示游戏结果的数字（0表示平局，1表示玩家1赢，2表示玩家2赢）\n*/\n", "solution": "int rockPaperScissors(int player1, int player2) {\n    if (player1 == player2) {\n        return 0;\n    }\n    if ((player1 == 0 && player2 == 2) || (player1 == 1 && player2 == 0) || (player1 == 2 && player2 == 1)) {\n        return 1;\n    }\n    return 2;\n}\n", "test": "#include<assert.h>\nint main() {\n    assert(rockPaperScissors(0, 0)==0);\n    assert(rockPaperScissors(0, 2)==1);\n    assert(rockPaperScissors(2, 0)==2);\n    assert(rockPaperScissors(1, 0)==1);\n    assert(rockPaperScissors(0, 1)==2);\n    return 0;\n}\n"}
{"language": "c++", "domain": "game", "source": "gpt4+人工筛选；源文件地址/data/xw/c++dataset/game/already/222.cpp", "prompt": "#include <iostream>\n\nusing namespace std;\n\n/*实现井字游戏（tic-tac-toe）\n游戏的格式定义为：char ticTacToe(char board[3][3])\nboard是一个3x3的字符数组，两个玩家使用字符'X'和'O'。\n游戏的结果返回一个字符，'X'表示玩家X赢，'O'表示玩家O赢，'D'表示平局，'N'表示游戏尚未结束。\n*/\n", "solution": "char ticTacToe(char board[3][3]) {\n    for (int i = 0; i < 3; i++) {\n        if (board[i][0] == board[i][1] && board[i][1] == board[i][2]) {\n            return board[i][0];\n        }\n        if (board[0][i] == board[1][i] && board[1][i] == board[2][i]) {\n            return board[0][i];\n        }\n    }\n    if (board[0][0] == board[1][1] && board[1][1] == board[2][2]) {\n        return board[0][0];\n    }\n    if (board[0][2] == board[1][1] && board[1][1] == board[2][0]) {\n        return board[0][2];\n    }\n    for (int i = 0; i < 3; i++) {\n        for (int j = 0; j < 3; j++) {\n            if (board[i][j] == ' ') {\n                return 'N';\n            }\n        }\n    }\n    return 'D';\n}\n", "test": "#include<assert.h>\nint main() {\n    char board1[3][3] = {{'X', 'O', 'X'}, {'O', 'X', 'O'},{'O', 'X', 'X'}};\n    assert(ticTacToe(board1)=='X');\n    char board2[3][3] = { {'X', 'O', 'X'}, {'O', 'X', 'X'},{'O', 'X', 'O'}};\n    assert(ticTacToe(board2)=='D');\n    char board3[3][3] = { {'X', 'O', 'X'}, {'O', 'X', 'X'},{'X', 'O', 'X'}};\n    assert(ticTacToe(board3)=='X');\n    char board4[3][3] = { {'X', 'O', ' '}, {'O', ' ', 'X'},{'O', 'X', ' '}};\n    assert(ticTacToe(board4)=='N');\n    char board5[3][3] = { {'X','X', 'O'}, {'O', 'X', ' '},{'O', ' ', 'O'}};\n    assert(ticTacToe(board5)=='N');\n\n    return 0;\n}\n"}
{"language": "c++", "domain": "game", "source": "gpt4+人工筛选；源文件地址/data/xw/c++dataset/game/already/252.cpp", "prompt": "#include <iostream>\n\nusing namespace std;\n\n/*实现游戏角色位置移动的函数\n函数的格式定义为：int movePosition(int currentPosition, int steps)\ncurrentPosition是角色当前的位置，取值范围1-10\nsteps是角色要移动的步数，取值范围1-6（象征骰子）\n返回角色移动后的位置, 当角色的位置超过10时从1开始重新计数\n */\n", "solution": "int movePosition(int currentPosition, int steps) {\n    currentPosition += steps;\n    if (currentPosition > 10) {\n        currentPosition %= 10; \n    }\n    return currentPosition;\n}\n", "test": "#include<assert.h>\nint main() {\n    assert(movePosition(1,6)==7);\n    assert(movePosition(5,3)==8);\n    assert(movePosition(8,3)==1);\n    assert(movePosition(10,1)==1);\n    assert(movePosition(9,2)==1);\n\n    return 0;\n}\n"}
{"language": "c++", "domain": "game", "source": "gpt4+人工筛选；源文件地址/data/xw/c++dataset/game/already/318.cpp", "prompt": "#include <iostream>\n#include <vector>\n#include <time.h>\n\nusing namespace std;\n\n/*\n定义一个函数，实现简单的Tetris游戏的下落功能\n该函数的定义格式为：vector<int> TetrisFall(vector<int> tetris, int col)\ntetris是一个一维数组，定义了有多少个方块已经放在了相应列上（列数从0开始计算）\ncol是下一个方块即将落在哪一列中\n返回一个更新后的tetris数组\n*/\n", "solution": "vector<int> TetrisFall(vector<int> tetris, int col) {\n    tetris[col] += 1;\n    return tetris;\n}\n", "test": "#include<cassert>\nint main() {\n    vector<int> test1 = {0,0,0,0,0};\n    vector<int> test2 = {0,1,0,1,0};\n    vector<int> test3 = {1,2,3,4,5};\n    vector<int> res1 = {1,0,0,0,0};\n    vector<int> res2 = {0,2,0,1,0};\n    vector<int> res3 = {1,2,4,4,5};\n    assert(TetrisFall(test1,0) == res1);\n    assert(TetrisFall(test2,1) == res2);\n    assert(TetrisFall(test3,2) == res3);\n    assert(TetrisFall(test3,1) != res3);\n    assert(TetrisFall(test1,4) != res1);\n    \n    return 0;\n}\n"}
{"language": "c++", "domain": "game", "source": "gpt4+人工筛选；源文件地址/data/xw/c++dataset/game/already/21.cpp", "prompt": "#include <iostream>\n#include <ctime>\nusing namespace std;\n\n/* \n产生一个在指定范围内的随机数的函数\n接收两个整数参数，分别为随机数的上下限。上限值大于下限值\n函数的格式定义为：int randomInRange(int lower, int upper)\n*/\n", "solution": "int randomInRange(int lower, int upper) {\n    srand(time(0));\n    return rand() % (upper - lower + 1) + lower;\n}\n", "test": "#include<assert.h>\nint main() {\n\n    //产生一个在10到20内的随机数，并检测其是否在这个范围\n    int randomNumber1 = randomInRange(10, 20);\n    assert(randomNumber1 >= 10 && randomNumber1 <= 20);\n    \n    //产生一个在-100到100内的随机数，并检测其是否在这个范围\n    int randomNumber2 = randomInRange(-100, 100);\n    assert(randomNumber2 >= -100 && randomNumber2 <= 100);\n    \n    //产生一个在0到0内的随机数，因为上下限相同，所以产生的随机数只能是0\n    int randomNumber3 = randomInRange(0, 0);\n    assert(randomNumber3 == 0);\n    \n    return 0;\n}\n"}
{"language": "c++", "domain": "game", "source": "gpt4+人工筛选；源文件地址/data/xw/c++dataset/game/already/357.cpp", "prompt": "#include<vector>\n#include<queue>\n#include<utility>\nusing namespace std;\n/*\n实现迷宫游戏，判断玩家从起始位置（0,0）是否可以到达终点默认是(4,4)\n输入是二维vector， 5*5大小，代表迷宫的地图,0表示无障碍，1表示有障碍。\n函数的定义为：bool canReachToEnd(vector<vector<int>> matrix)\nmatrix - 一个5*5的vector，其中0表示无障碍，1表示有障碍.\n返回一个bool值，如果玩家可以从起始位置到达终点返回true，否则返回false\n*/\n", "solution": "bool canReachToEnd(vector<vector<int>> matrix) {\n    vector<vector<bool>> visited(5,vector<bool>(5,false));  //标记是否已经访问过\n    vector<vector<int>> dir={{0,1},{0,-1},{1,0},{-1,0}};  //四个方向\n    queue<pair<int,int>> q;\n    q.push({0,0});\n    visited[0][0]=true;\n    while(!q.empty()){\n        pair<int,int> current=q.front();\n        q.pop();\n        if(current.first==4 && current.second==4)\n            return true;\n        for(int i=0;i<4;i++){\n            int x=current.first+dir[i][0];\n            int y=current.second+dir[i][1];\n            if(x>=0 && x<5 && y>=0 && y<5 && !matrix[x][y] && !visited[x][y]){\n                visited[x][y]=true;\n                q.push({x,y});\n            }\n        }\n    }\n    return false;\n}\n", "test": "#include<assert.h>\nint main(){\n    assert(canReachToEnd({{0,0,0,0,0},\n                          {1,1,1,1,0},\n                          {0,0,0,0,0},\n                          {0,1,1,1,1},\n                          {0,0,0,0,0}}) == true);\n    assert(canReachToEnd({{0,0,0,0,0},\n                          {1,1,1,1,1},\n                          {0,0,0,0,0},\n                          {0,1,1,1,1},\n                          {0,0,0,0,0}}) == false);\n    assert(canReachToEnd({{0,1,0,0,0},\n                          {0,1,1,1,0},\n                          {0,0,0,1,0},\n                          {0,1,1,1,0},\n                          {0,0,0,0,0}}) == true);\n    assert(canReachToEnd({{0,1,1,1,1},\n                          {0,0,0,0,1},\n                          {1,1,1,0,1},\n                          {1,1,1,0,0},\n                          {1,1,1,1,0}}) == true);\n    assert(canReachToEnd({{0,0,1,1,1},\n                          {1,0,1,1,1},\n                          {1,0,1,1,1},\n                          {1,0,0,0,0},\n                          {1,1,1,1,0}}) == true);\n    return 0;\n}\n"}
{"language": "c++", "domain": "game", "source": "gpt4+人工筛选；源文件地址/data/xw/c++dataset/game/already/135.cpp", "prompt": "#include <iostream>\n#include <vector>\n\nusing namespace std;\n\n/* 实现一个检查井字棋游戏结果的函数\n函数的格式定义为：string ticTacToe(vector<vector<int>> board)\nboard 是一个 3x3 的二维数组，代表井字棋的棋盘，玩家1用1表示，玩家2用2表示，未下棋的位置为0；\n函数返回“Player1”，如果玩家1赢；返回“Player2”，如果玩家2赢；返回“Draw”，如果平局；返回“Pending”，如果游戏还没结束\n*/\n", "solution": "string ticTacToe(vector<vector<int>> board) {\n    for (int i = 0; i < 3; ++i) {\n        if (board[i][0] != 0 && board[i][0] == board[i][1] && board[i][0] == board[i][2]) {\n            return board[i][0] == 1 ? \"Player1\" : \"Player2\"; \n        }\n        if (board[0][i] != 0 && board[0][i] == board[1][i] && board[0][i] == board[2][i]) {\n            return board[0][i] == 1 ? \"Player1\" : \"Player2\";\n        }\n    }\n    \n    if (board[0][0] != 0 && board[0][0] == board[1][1] && board[0][0] == board[2][2]) {\n        return board[0][0] == 1 ? \"Player1\" : \"Player2\";\n    }\n    \n    if (board[0][2] != 0 && board[0][2] == board[1][1] && board[0][2] == board[2][0]) {\n        return board[0][2] == 1 ? \"Player1\" : \"Player2\";\n    }\n    \n    for (int i = 0; i < 3; ++i) {\n        for (int j = 0; j < 3; ++j) {\n            if (board[i][j] == 0) {\n                return \"Pending\";\n            }\n        }\n    }\n    \n    return \"Draw\";\n}\n", "test": "#include<assert.h>\n\nint main() {\n    vector<vector<int>> board1 = {{1, 2, 1}, {2, 1, 2}, {2, 1, 1}};\n    vector<vector<int>> board2 = {{2, 2, 2}, {1, 1, 0}, {1, 0, 1}};\n    vector<vector<int>> board3 = {{1, 2, 0}, {2, 1, 0}, {0, 0, 0}};\n    vector<vector<int>> board4 = {{1, 2, 1}, {2, 1, 2}, {1, 0, 2}};\n    vector<vector<int>> board5 = {{1, 2, 1}, {2, 1, 2}, {2, 1, 2}};\n\n    assert(ticTacToe(board1) == \"Player1\");\n    assert(ticTacToe(board2) == \"Player2\");\n    assert(ticTacToe(board3) == \"Pending\");\n    assert(ticTacToe(board5) == \"Draw\");\n\n    return 0;\n}\n"}
{"language": "c++", "domain": "game", "source": "gpt4+人工筛选；源文件地址/data/xw/c++dataset/game/already/game5.cpp", "prompt": "#include <iostream>\n#include <vector>\n\nusing namespace std;\n\n/*实现五子棋游戏\n棋盘是一个二维矩阵，元素值为0表示该位置上没有棋子，1表示玩家1的棋子，2表示玩家2的棋子。\n五子棋游戏通过五子棋(x, y, z, t)判断z玩家在(t, t)位置下棋后，是否赢得比赛。\n如果是，返回其玩家编号，否则返回0。\n*/\n", "solution": "int fiveInRow(vector<vector<int>>& board, int player, int row, int col) {\n    // check horizontal, vertical, diagonal and anti-diagonal\n    vector<vector<int>> directions = {{0, 1}, {1, 0}, {1, 1}, {1, -1}};\n    for (const auto& dir : directions) {\n        int count = 1;\n        for (int i = 1; i < 5; ++i) {\n            int x = row + i * dir[0];\n            int y = col + i * dir[1];\n            if (x < 0 || x >= board.size() || y < 0 || y >= board[0].size() || board[x][y] != player)\n                break;\n            ++count;\n        }\n        for (int i = 1; i < 5; ++i) {\n            int x = row - i * dir[0];\n            int y = col - i * dir[1];\n            if (x < 0 || x >= board.size() || y < 0 || y >= board[0].size() || board[x][y] != player)\n                break;\n            ++count;\n        }\n        if (count >= 5) return player;\n    }\n    return 0;\n}\n", "test": "#include<assert.h>\nint main() {\n    vector<vector<int>> board = {{0,0,0,0,0,0,0,0,0,0},\n                                 {0,0,0,0,0,0,0,0,0,0},\n                                 {0,0,0,1,0,0,0,0,0,0},\n                                 {0,0,0,1,0,0,2,0,0,0},\n                                 {0,0,0,1,0,2,0,0,0,0},\n                                 {0,0,0,1,2,0,0,0,0,0},\n                                 {0,0,0,1,0,0,0,0,0,0},\n                                 {0,0,0,0,0,0,0,0,0,0},\n                                 {0,0,0,0,0,0,0,0,0,0},\n                                 {0,0,0,0,0,0,0,0,0,0}};\n    assert(fiveInRow(board, 1, 7, 2) == 0);\n    assert(fiveInRow(board, 1, 2, 3) == 1);\n    assert(fiveInRow(board, 2, 4, 6) == 0);\n    assert(fiveInRow(board, 2, 5, 5) == 0);\n\n    return 0;\n}\n"}
{"language": "c++", "domain": "game", "source": "gpt4+人工筛选；源文件地址/data/xw/c++dataset/game/already/15.cpp", "prompt": "#include <iostream>\n#include <vector>\nusing namespace std;\n\n/*\n* 一个简单的井字游戏（Tic Tac Toe）\n*/\n\nclass TicTacToe {\npublic:\n    TicTacToe(int n);\n\n    /** Returns 1: Player 1 wins\n        Returns 2: Player 2 wins\n        Returns 0: No one wins, game continues\n        Returns -1: No one wins, but no places left\n    */\n    int move(int row, int col, int player);\n\nprivate:\n    vector<vector<int>> board;\n    int size;\n};\n\n", "solution": "\nTicTacToe::TicTacToe(int n): size(n), board(n, vector<int>(n, 0)) {}\n\nint TicTacToe::move(int row, int col, int player) {\n    // place the player's marker\n    board[row][col] = player;\n\n    // check row\n    for (int i = 0; i < size; ++i) {\n        if (board[i][col] != player) break;\n        if (i == size-1) return player;\n    }\n\n    // check column\n    for (int i = 0; i < size; ++i) {\n        if (board[row][i] != player) break;\n        if (i == size-1) return player;\n    }\n\n    // check diagonal\n    if (row == col) {\n        for (int i = 0; i < size; ++i) {\n            if (board[i][i] != player) break;\n            if (i == size-1) return player;\n        }\n    }\n\n    // check anti diagonal\n    if (row + col == size - 1) {\n        for (int i = 0; i < size; ++i) {\n            if (board[i][size-1-i] != player) break;\n            if (i == size-1) return player;\n        }\n    }\n\n    // check draw\n    for (int i = 0; i < size; ++i)\n        for (int j = 0; j < size; ++j)\n            if (!board[i][j]) return 0; // game continues as there's empty cell\n\n    return -1; // in case of draw\n}\n\n", "test": "#include<assert.h>\nint main() {\n    TicTacToe game(3);\n\n    assert(game.move(0, 0, 1) == 0);\n    assert(game.move(0, 2, 2) == 0);\n    assert(game.move(1, 2, 2) == 0);//Player 1 wins\n\n    TicTacToe game2(2);\n\n    assert(game2.move(0, 0, 1) == 0);\n    assert(game2.move(0, 1, 2) == 0);\n    assert(game2.move(1, 0, 2) == 2); //Player 2 wins\n\n    return 0;\n}\n"}
{"language": "c++", "domain": "game", "source": "gpt4+人工筛选；源文件地址/data/xw/c++dataset/game/already/game4.cpp", "prompt": "#include <iostream>\n#include <vector>\n#include <cassert>\n\nusing namespace std;\n\n/*实现24点游戏的函数\n输入是4个1-9之间的整数，代表牌面值\n函数的格式定义为：bool canMake24(int a, int b, int c, int d);\n返回一个bool值，表示是否可以通过四则运算（可以重复使用且可以不使用）使得这四张牌的牌面值等于24\n*/\n", "solution": "\nbool dfs(vector<double>& nums) {\n    if (nums.size() == 1) {\n        return abs(nums[0] - 24) < 1e-6;\n    }\n\n    for (int i = 0; i < nums.size(); i++) {\n        for (int j = 0; j < nums.size(); j++) {\n            if (i != j) {\n                vector<double> nums2;\n                for (int k = 0; k < nums.size(); k++) {\n                    if (k != i && k != j) {\n                        nums2.push_back(nums[k]);\n                    }\n                }\n\n                for (int k = 0; k < 4; k++) {\n                    if (k < 2 && i < j) {\n                        continue;\n                    }\n                    if (k == 0) {\n                        nums2.push_back(nums[i] + nums[j]);\n                    } else if (k == 1) {\n                        nums2.push_back(nums[i] * nums[j]);\n                    } else if (k == 2) {\n                        nums2.push_back(nums[i] - nums[j]);\n                    } else {\n                        if (nums[j] != 0) {\n                            nums2.push_back(nums[i] / nums[j]);\n                        } else {\n                            continue;\n                        }\n                    }\n                    if (dfs(nums2)) {\n                        return true;\n                    }\n                    nums2.pop_back();\n                }\n            }\n        }\n    }\n\n    return false;\n}\nbool canMake24(int a, int b, int c, int d) {\n    vector<double> nums = {(double)a, (double)b, (double)c, (double)d};\n    return dfs(nums);\n}\n", "test": "int main() {\n    assert(canMake24(1,2,3,4)==true);\n    assert(canMake24(1,1,1,1)==false);\n    assert(canMake24(3,3,8,8)==true);\n    assert(canMake24(2,2,2,2)==false);\n    assert(canMake24(3,4,5,6)==false);\n\n    return 0;\n}\n"}
{"language": "c++", "domain": "game", "source": "gpt4+人工筛选；源文件地址/data/xw/c++dataset/game/already/264.cpp", "prompt": "#include <iostream>\n#include <vector>\n\nusing namespace std;\n\n/* 实现一个小游戏：猜数游戏。\n * 其中，provideRandNum() 函数提供一个在给定范围内的随机数，使玩家来猜测。\n * 若玩家猜测的数等于随机数，返回true。\n * 若玩家猜测的数小于随机数，返回-1，表示玩家下次应该猜更大的数。\n * 若玩家猜测的数大于随机数，返回1，表示玩家下次应该猜更小的数。\n */\n", "solution": "#include <stdlib.h> \n#include <time.h> \n\nint provideRandNum(int lower, int upper, int guessed_num) {\n    srand(time(0));\n    int num = (rand() % (upper - lower + 1)) + lower;\n    if (guessed_num == num) {\n        return true;\n    } else if (guessed_num < num) {\n        return -1;\n    } else {\n        return 1;\n    }\n}\n", "test": "#include <assert.h>\nvoid test() {\n    int lower = 1, upper = 10000;\n    int true_num = provideRandNum(lower, upper, 5000);\n    if(true_num == true)\n        assert(provideRandNum(lower, upper, 5000) == true);\n    else if(true_num == -1)\n        assert(provideRandNum(lower, upper, 5000) < 5000);\n    else if(true_num == 1)\n        assert(provideRandNum(lower, upper, 5000) > 5000);\n}\nint main() {\n    test();\n    return 0;\n}\n"}
{"language": "c++", "domain": "game", "source": "gpt4+人工筛选；源文件地址/data/xw/c++dataset/game/already/228.cpp", "prompt": "#include <iostream>\n#include <vector>\nusing namespace std;\n\n/*实现一个对角棋盘游戏的函数\n对角棋盘游戏，1x1，2x2，3x3，......,10x10大小的格子组成\n从左上角开始，走到右下角结束，每次可以往右走或者往下走\n判断输入的步数是否足够走完全程\n函数的定义：bool diagonalGame(int steps);\n输入参数：\nsteps 是行走的步数\n返回一个表示游戏结果的布尔值（如果步数足够，返回true，反之返回false）\n*/\n", "solution": "bool diagonalGame(int steps) {\n    if (steps >= 55) {\n        return true; //If more than or equal to 55 steps, you can reach the destination\n    } else {\n        return false; //Less than 55 steps, you cannot reach the destination\n    }\n}\n", "test": "#include<assert.h>\nint main() {\n    assert(diagonalGame(56) == true);\n    assert(diagonalGame(54) == false);\n    assert(diagonalGame(0) == false);\n    assert(diagonalGame(55) == true);\n    assert(diagonalGame(100) == true);\n    return 0;\n}\n"}
{"language": "c++", "domain": "game", "source": "gpt4+人工筛选；源文件地址/data/xw/c++dataset/game/already/24.cpp", "prompt": "#include<iostream>\n\n/*\n此程序模拟的是一个简单的猜数字游戏，也就是计算机生成一个随机数，然后用户进行猜测\n主要函数为：\n1. int get_random();\n    该函数随机生成一个0-100之间的整数\n2. bool judge(int guessed, int answer);\n    该函数接受一个用于猜测的整数和答案，如果相等返回true，否则返回false\n*/\n\n", "solution": "#include<cstdlib>\n#include<ctime>\n\nint get_random(){\n    srand((unsigned)time(NULL));\n    return rand() % 101;\n}\n\nbool judge(int guessed, int answer){\n    if(guessed == answer)\n        return true;\n    else\n        return false;\n}\n", "test": "#include<assert.h>\n\nint main() {\n    int answer = get_random();\n    assert(judge(answer, answer) == true);\n    assert(judge(answer+1, answer) == false);\n    assert(judge(answer-1, answer) == false);\n    assert(judge(0, answer) == (answer == 0));\n    assert(judge(100, answer) == (answer == 100));\n    \n    return 0;\n}\n"}
{"language": "c++", "domain": "game", "source": "gpt4+人工筛选；源文件地址/data/xw/c++dataset/game/already/282.cpp", "prompt": "#include<iostream>\n#include<cstdlib>\n#include<ctime>\n/* \n 随机生成游戏下一步状态\n int getNextState(int currentState);\n currentState是当前状态，返回下一个状态\n 这里我们假设游戏状态可以被整数代表，比如说对于贪吃蛇游戏，我们可以用1代表向上，2代表向下，3代表向左，4代表向右\n 这个函数将会返回一个1~4的整数，代表下一步的方向\n*/\n", "solution": "int getNextState(int currentState) {\n    srand(time(NULL));\n    int nextState = rand() % 4 + 1;\n    return nextState;\n}\n", "test": "#include<assert.h>\nint main() {\n    int currentState1=1;\n    int nextState1=getNextState(currentState1);\n    assert(nextState1>=1 && nextState1<=4);\n\n    int currentState2=2;\n    int nextState2=getNextState(currentState2);\n    assert(nextState2>=1 && nextState2<=4);\n\n    int currentState3=3;\n    int nextState3=getNextState(currentState3);\n    assert(nextState3>=1 && nextState3<=4);\n\n    int currentState4=4;\n    int nextState4=getNextState(currentState4);\n    assert(nextState4>=1 && nextState4<=4);\n\n    int currentState5=5;\n    int nextState5=getNextState(currentState5);\n    assert(nextState5>=1 && nextState5<=4);\n    \n    return 0;\n}\n"}
{"language": "c++", "domain": "game", "source": "gpt4+人工筛选；源文件地址/data/xw/c++dataset/game/already/348.cpp", "prompt": "#include<iostream>\nusing namespace std;\n/*  \n判断井字棋游戏是否有赢家 \nchar checkWinner(char board[3][3]);\nboard是一个3x3的字符数组，代表一个井字棋板，空格表示未下子，'X'和'O'表示下子，返回赢家，'X'，'O'或者' '表示没有赢家 \n*/\n", "solution": "char checkWinner(char board[3][3]) {\n    for (int i = 0; i < 3; ++i) { \n        if(board[i][0] == board[i][1] && board[i][0] == board[i][2] && board[i][0] != ' ') return board[i][0]; \n        if(board[0][i] == board[1][i] && board[0][i] == board[2][i] && board[0][i] != ' ') return board[0][i]; \n    } \n    if(board[0][0] == board[1][1] && board[0][0] == board[2][2] && board[0][0] != ' ') return board[0][0]; \n    if(board[0][2] == board[1][1] && board[0][2] == board[2][0] && board[0][2] != ' ') return board[0][2]; \n    return ' ';\n}\n", "test": "#include<assert.h>\nint main() {\n    char board1[3][3] = {{'X', 'O', 'O'}, {' ', 'X', ' '}, {' ', ' ', 'X'}};\n    assert(checkWinner(board1)=='X');\n    char board2[3][3] = {{'X', 'O', 'O'}, {' ', 'O', ' '}, {' ', ' ', 'O'}};\n    assert(checkWinner(board2)==' ');\n    char board3[3][3] = {{'X', 'X', 'O'}, {'O', 'X', 'X'}, {'X', 'O', 'O'}};\n    assert(checkWinner(board3)==' ');\n    char board4[3][3] = {{'X', 'X', 'X'}, {'O', 'O', ' '}, {' ', ' ', ' '}};\n    assert(checkWinner(board4)=='X');\n    char board5[3][3] = {{'O', 'X', ' '}, {'O', 'X', ' '}, {'O', ' ', ' '}};\n    assert(checkWinner(board5)=='O');\n    return 0;\n}\n"}
{"language": "c++", "domain": "game", "source": "gpt4+人工筛选；源文件地址/data/xw/c++dataset/game/already/261.cpp", "prompt": "#include <iostream>\n#include <vector>\n/*\n检测游戏中是否有连续三个相同的字符\nbool isGameWon(std::vector<char> gameBoard)\ngameBoard是游戏场地，返回是否有连续三个相同的字符\n*/\n", "solution": "bool isGameWon(std::vector<char> gameBoard) {\n    for(int i=0; i<7; i+=3) {\n        if((gameBoard[i] == gameBoard[i+1]) && (gameBoard[i+1] == gameBoard[i+2]) && gameBoard[i]!=' ')\n            return true;\n    }\n    for(int i=0; i<3; i++) {\n        if((gameBoard[i] == gameBoard[i+3]) && (gameBoard[i+3] == gameBoard[i+6]) && gameBoard[i]!=' ')\n            return true;\n    }\n    if((gameBoard[0] == gameBoard[4]) && (gameBoard[4] == gameBoard[8]) && gameBoard[0]!=' ')\n        return true;\n    if((gameBoard[2] == gameBoard[4]) && (gameBoard[4] == gameBoard[6]) && gameBoard[2]!=' ')\n        return true;\n    return false;\n}\n", "test": "#include<assert.h>\nint main() {\n    std::vector<char> gameBoard1 = {'X', 'O', 'X', 'X', 'X', 'O', 'O', 'X', 'O'};\n    std::vector<char> gameBoard2 = {'X', 'O', 'X', 'O', 'X', 'O', 'O', 'X', 'O'};\n    std::vector<char> gameBoard3 = {' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' '};\n    std::vector<char> gameBoard4 = {'O', 'O', 'O', 'X', 'X', ' ', 'O', ' ', 'X'};\n    std::vector<char> gameBoard5 = {'X', ' ', ' ', 'O', 'O', 'O', 'X', ' ', 'X'};\n    assert(isGameWon(gameBoard1)==false);\n    assert(isGameWon(gameBoard2)==false);\n    assert(isGameWon(gameBoard3)==false);\n    assert(isGameWon(gameBoard4)==true);\n    assert(isGameWon(gameBoard5)==true);\n    return 0;\n}\n"}
{"language": "c++", "domain": "game", "source": "gpt4+人工筛选；源文件地址/data/xw/c++dataset/game/already/291.cpp", "prompt": "#include <iostream>\n#include <vector>\n#include <string.h>\nusing namespace std;\n\n/* 实现一个猜数字游戏\n* 输入一个数字n，代表要猜的数字，和一个试图猜出这个数字的vector。\n* 函数的定义为：string guessTheNumber(int n, vector<int> attempts)\n* n - 要猜的数字， 在1-100之间。\n* attempts - 试图猜出这个数字。如果数字在100以下，代表猜的太小，如果数字在100以上，代表猜的太大，如果数字是 -1，代表猜中了数字。\n* 返回一个字符串，显示你是否猜中了数字，没有猜中就返回对应的提示。\n*/\n\n", "solution": "string guessTheNumber(int n, int attempts) {\n    if (attempts == n)\n        return \"Congratulation! You found the number.\";\n    else if (attempts < n)\n        return \"Too low!\";\n    else if (attempts > n)\n        return \"Too high!\";\n    return \"None of your guesses is correct.\";\n}\n\n", "test": "#include<assert.h>\nint main(){\n    assert(guessTheNumber(50, 50) == \"Congratulation! You found the number.\");\n    assert(guessTheNumber(75, 75) == \"Congratulation! You found the number.\");\n    assert(guessTheNumber(60, 1000) == \"Too high!\");\n    assert(guessTheNumber(25, 10) == \"Too low!\");\n    assert(guessTheNumber(88, 1) == \"Too low!\");\n    \n    return 0;\n}\n\n"}
{"language": "c++", "domain": "game", "source": "gpt4+人工筛选；源文件地址/data/xw/c++dataset/game/already/309.cpp", "prompt": "#include <iostream>\n#include <vector>\n#include <cassert>\n\nusing namespace std;\n\n/*实现判断俄罗斯方块是否能够放进游戏盘的函数\n输入是一个二维数组，每个里面包含的元素为1或者0，1表示有方块，0表示没有方块。作为要放入的俄罗斯方块，\n第二个输入是另一个二维数组，同样每个元素为1或者0，代表游戏盘。1表示位置已经被占据，0表示没有被占据\n函数的格式定义为：bool ifFit(vector<vector<int>>& tetris, vector<vector<int>>& board);\n返回一个bool值，表示是否可以把这个俄罗斯方块放入游戏盘，只能从上到下，左到右来放\n*/\n", "solution": "\nbool ifFit(vector<vector<int>>& tetris, vector<vector<int>>& board) {\n    for (int i = 0; i < board.size() - tetris.size() + 1; i++) {\n        for (int j = 0; j < board[0].size() - tetris[0].size() + 1; j++) {\n            bool fit = true;\n            for (int m = 0; m < tetris.size(); m++) {\n                for (int n = 0; n < tetris[0].size(); n++) {\n                    if (tetris[m][n] == 1 && board[i+m][j+n] == 1) {\n                        fit = false;\n                        break;\n                    }\n                }\n                if (!fit) {\n                    break;\n                }\n            }\n            if (fit) {\n                return true;\n            }\n        }\n    }\n    return false;\n}\n", "test": "int main() {\n    vector<vector<int>> tetris = { { 1, 0 },\n        { 1, 0 },\n    };\n    vector<vector<int>> board = { { 0, 0, 0 },\n        { 0, 0, 0 },\n        { 0, 0, 0 },\n    };\n    assert(ifFit(tetris, board)==true);\n\n    vector<vector<int>> tetris1 = { { 1, 0 },\n        { 1, 0 },\n    };\n    vector<vector<int>> board1 = { { 0, 0, 0 },\n        { 1, 0, 0 },\n        { 0, 0, 0 },\n    };\n    assert(ifFit(tetris1, board1)==true);\n\n    vector<vector<int>> tetris2 = { { 1, 0 },\n        { 1, 0 },\n    };\n    vector<vector<int>> board2 = { { 0, 0 },\n        { 1, 0 },\n    };\n    assert(ifFit(tetris2, board2)==false);\n\n    vector<vector<int>> tetris3 = { { 1, 1 },\n        { 0, 0 },\n    };\n    vector<vector<int>> board3 = { { 0, 0 },\n        { 0, 0 },\n    };\n    assert(ifFit(tetris3, board3)==true);\n\n    vector<vector<int>> tetris4 = { { 1 },\n        { 1 },\n    };\n    vector<vector<int>> board4 = { { 0 },\n        { 1 },\n    };\n    assert(ifFit(tetris4, board4)==false);\n    \n    return 0;\n}\n"}
{"language": "c++", "domain": "game", "source": "gpt4+人工筛选；源文件地址/data/xw/c++dataset/game/already/339.cpp", "prompt": "#include <iostream>\n\nusing namespace std;\n\n/*实现象棋马的移动判定\n函数的格式定义为：bool is_valid_move(int src_x, int src_y, int tgt_x, int tgt_y)\nsrc_x，src_y为起始位置的坐标，0 <= src_x, src_y < 8\ntgt_x，tgt_y为目标位置的坐标，0 <= tgt_x, tgt_y < 8\n函数将根据源和目标位置决定这是否是一个有效的马（象棋试用的陆军单位）步骤。\n如果马能从起始位置到达目标位置，函数返回true，否则返回false。*/\n", "solution": "bool is_valid_move(int src_x, int src_y, int tgt_x, int tgt_y) {\n    int dx = abs(tgt_x - src_x);\n    int dy = abs(tgt_y - src_y);\n    \n    return ((dx == 2 && dy == 1) || (dx == 1 && dy == 2));\n}\n", "test": "#include<assert.h>\nint main() {\n    assert(is_valid_move(1, 1, 3, 2)==true);\n    assert(is_valid_move(0, 0, 1, 0)==false);\n    assert(is_valid_move(1, 1, 2, 3)==true);\n    assert(is_valid_move(5, 5, 7, 6)==true);\n    assert(is_valid_move(4, 6, 5, 7)==false);\n\n    return 0;\n}\n"}
{"language": "c++", "domain": "game", "source": "gpt4+人工筛选；源文件地址/data/xw/c++dataset/game/already/258.cpp", "prompt": "#include <iostream>\n/*判断井字棋游戏是否有人胜出\nchar gameBoard[3][3]为3x3大小的游戏棋盘，游戏者为'X'或'O'，空位为空格' '。\n如果'X'赢了返回'X'，'O'赢了返回'O'，没有胜者返回' '\n*/\n", "solution": "char winnerCheck(char gameBoard[3][3]) {\n    for (int i = 0; i < 3; i++) {\n        if (gameBoard[i][0] == gameBoard[i][1] && gameBoard[i][0] == gameBoard[i][2] && gameBoard[i][0] != ' ')\n            return gameBoard[i][0];\n        if (gameBoard[0][i] == gameBoard[1][i] && gameBoard[0][i] == gameBoard[2][i] && gameBoard[0][i] != ' ')\n            return gameBoard[0][i];\n    }\n    if (gameBoard[0][0] == gameBoard[1][1] && gameBoard[0][0] == gameBoard[2][2] && gameBoard[0][0] != ' ')\n        return gameBoard[0][0];\n    if (gameBoard[0][2] == gameBoard[1][1] && gameBoard[0][2] == gameBoard[2][0] && gameBoard[0][2] != ' ')\n        return gameBoard[0][2];\n    return ' ';\n}\n", "test": "#include<assert.h>\nint main() {\n    char gameBoard1[3][3] = { {'X', 'O', 'X'}, {'O', 'X', 'O'}, {'X', 'O', 'X'} };\n    assert(winnerCheck(gameBoard1) == 'X');\n    char gameBoard2[3][3] = { {' ', 'O', ' '}, {' ', 'O', ' '}, {' ', 'O', ' '} };\n    assert(winnerCheck(gameBoard2) == 'O');\n    char gameBoard3[3][3] = { {'X', ' ', ' '}, {'X', ' ', ' '}, {'O', ' ', ' '} };\n    assert(winnerCheck(gameBoard3) == ' ');\n    char gameBoard4[3][3] = { {'O', ' ', 'O'}, {' ', 'O', ' '}, {'O', ' ', 'O'} };\n    assert(winnerCheck(gameBoard4) == 'O');\n    char gameBoard5[3][3] = { {' ', ' ', ' '}, {' ', ' ', ' '}, {' ', ' ', ' '} };\n    assert(winnerCheck(gameBoard5) == ' ');\n    return 0;\n}\n"}
{"language": "c++", "domain": "game", "source": "gpt4+人工筛选；源文件地址/data/xw/c++dataset/game/already/186.cpp", "prompt": "#include <iostream>\n#include <vector>\n\nusing namespace std;\n\n/*实现一个函数，用于解决猜数游戏。\n函数的格式定义为：string guessNumber(const vector<int>& secretSequence, const vector<int>& playerSequence)\n发起方秘密选取一个敏感数字序列，玩家必须尽力去猜测这个数字序列。发起方则将参与者猜测的结果以“答对的数字的个数 / 答对的数字并且位置也对的个数”的方式回应。秘密数字序列和玩家数字序列的长度都为4，元素为1到6。\n秘密数字序列和玩家数字序列使用向量vector<int>表示，其中每个元素对应一个数字（1到6）。\n函数返回的应该是一个字符串“x/y”，其中x是玩家猜中的数字个数，y是玩家猜对数字并且位置也对的个数。\n */\n", "solution": "string guessNumber(const vector<int>& secretSequence, const vector<int>& playerSequence){\n    int countGuessRightNumAndPos = 0;\n    int countGuessRightNum = 0;\n    for(int i = 0; i < 4; ++i){\n        for(int j = 0; j < 4; ++j){\n            if(playerSequence[i] == secretSequence[j]){\n                countGuessRightNum++;\n                if(i==j){\n                    countGuessRightNumAndPos++;\n                }\n                break;\n            }\n        }\n    }\n    // 使用to_string函数将数字转为字符串，然后拼接起来\n    return string(to_string(countGuessRightNum) + '/' + to_string(countGuessRightNumAndPos));\n}\n", "test": "#include<assert.h>\nint main() {\n    assert(guessNumber({1,2,3,4}, {5,6,1,2})==\"2/0\");\n    assert(guessNumber({2,2,2,2}, {1,1,1,1})==\"0/0\");\n    assert(guessNumber({1,2,3,4}, {4,3,2,1})==\"4/0\");\n    assert(guessNumber({1,2,3,4}, {1,5,3,4})==\"3/3\");\n\n    return 0;\n}\n"}
{"language": "c++", "domain": "game", "source": "gpt4+人工筛选；源文件地址/data/xw/c++dataset/game/already/stb.cpp", "prompt": "#include <iostream>\n\nusing namespace std;\n\n/*实现剪刀石头布游戏的函数\n(0-2，0表示剪刀，1表示石头，2表示布)\n函数的格式定义为：int playGame(int player1Choice, int player2Choice)\nplayer1Choice和player2Choice的选择(0-2，0表示剪刀，1表示石头，2表示布)\n返回一个表示游戏结果的数字（0表示平局，1表示玩家1赢，2表示玩家2赢）\n*/\n", "solution": "int playGame(int player1Choice, int player2Choice) {\n    if (player1Choice == player2Choice) {\n        return 0; \n    } else if ((player1Choice == 0 && player2Choice == 2) ||\n               (player1Choice == 1 && player2Choice == 0) ||\n               (player1Choice == 2 && player2Choice == 1)) {\n        return 1; \n    } else {\n        return 2; \n    }\n}\n", "test": "#include<assert.h>\nint main() {\n    assert(playGame(0,1)==2);\n    assert(playGame(0,2)==1);\n    assert(playGame(0,0)==0);\n    assert(playGame(1,1)==0);\n\n\n    return 0;\n}\n"}
{"language": "c++", "domain": "game", "source": "gpt4+人工筛选；源文件地址/data/xw/c++dataset/game/already/12.cpp", "prompt": "#include <iostream>\n#include <vector>\nusing namespace std;\n\n/*实现一个简易版的井字游戏类\n* 允许两名玩家玩井字游戏\n* 并可以返回当前比赛的状态\n*/\n\nclass TicTacToeGame {\npublic:\n    //构造井字游戏\n    TicTacToeGame();\n\n    //玩家放置标记\n    bool MakeMove(int player, int row, int col);\n\n    //检查当前游戏的状态，返回的值0表示比赛正在进行，1表示玩家1获胜，2表示玩家2获胜，3表示平局\n    int CheckStatus();\n\nprivate:\n    vector<vector<int>> board;\n    int moves;\n};\n\n", "solution": "TicTacToeGame::TicTacToeGame() : board(3, vector<int>(3, 0)), moves(0) {}\n\nbool TicTacToeGame::MakeMove(int player, int row, int col) {\n    if(row < 0 || row >= 3 || col < 0 || col >= 3 || board[row][col] != 0)\n        return false;\n    board[row][col] = player;\n    moves++;\n    return true;\n}\n\nint TicTacToeGame::CheckStatus() {\n    for(int i = 0; i < 3; i++) {\n        if(board[i][0] != 0 && board[i][0] == board[i][1] && board[i][1] == board[i][2])\n            return board[i][0];\n        if(board[0][i] != 0 && board[0][i] == board[1][i] && board[1][i] == board[2][i])\n            return board[0][i];\n    }\n    if(board[0][0] != 0 && board[0][0] == board[1][1] && board[1][1] == board[2][2])\n        return board[0][0];\n    if(board[0][2] != 0 && board[0][2] == board[1][1] && board[1][1] == board[2][0])\n        return board[0][2];\n    if(moves == 9)\n        return 3;\n    return 0;\n}\n", "test": "#include<assert.h>\nint main() {\n    TicTacToeGame game;\n    assert(game.MakeMove(1, 0, 0));\n    assert(game.CheckStatus() == 0);\n    assert(game.MakeMove(2, 0, 1));\n    assert(game.CheckStatus() == 0);\n    assert(game.MakeMove(1, 1, 1));\n    assert(game.CheckStatus() == 0);\n    assert(game.MakeMove(2, 0, 2));\n    assert(game.CheckStatus() == 0);\n    assert(game.MakeMove(1, 2, 2));\n    assert(game.CheckStatus() == 1);\n\n    return 0;\n}\n"}
{"language": "c++", "domain": "game", "source": "gpt4+人工筛选；源文件地址/data/xw/c++dataset/game/already/138.cpp", "prompt": "#include <iostream>\n#include <vector>\n\nusing namespace std;\n\n/*实现老鼠迷宫游戏的函数\n函数的格式定义为：bool findExit(vector<vector<int>>& maze, int startX, int startY)\nmaze 二维向量表示迷宫地图（0表示通路，1表示障碍）\nstartX 和 startY 是老鼠的起始位置\n如果找到出口则返回true，否则返回false\n*/\n", "solution": "bool findExit(vector<vector<int>>& maze, int startX, int startY) {\n    if(startX < 0 || startY < 0 || startX >= maze.size() || startY >= maze[0].size() || maze[startX][startY] == 1) {\n        return false;\n    }\n    if(startX == maze.size()-1 && startY == maze[0].size()-1) {\n        return true;\n    }\n    maze[startX][startY] = 1;  \n    return findExit(maze,startX+1, startY) || findExit(maze,startX, startY+1) || findExit(maze,startX-1, startY) || findExit(maze,startX, startY-1);\n}\n", "test": "#include<assert.h>\nint main() {\n    vector<vector<int>> maze_1 = {{0,0,0,1,0},\n                                  {1,1,0,1,0},\n                                  {0,0,0,0,0},\n                                  {0,1,1,1,1},\n                                  {0,0,0,0,0}};\n    assert(findExit(maze_1, 0,0)==true);\n\n    vector<vector<int>> maze_2 = {{0,1,0,0,0},\n                                  {0,1,0,1,0},\n                                  {0,0,0,0,0},\n                                  {0,1,1,1,0},\n                                  {0,0,0,0,0}};\n    assert(findExit(maze_2, 0,0)==true);\n\n    vector<vector<int>> maze_3 = {{0,0,0,1,0},\n                                  {1,1,0,1,0},\n                                  {0,0,0,0,0},\n                                  {0,1,1,1,1},\n                                  {0,0,0,1,0}};\n    assert(findExit(maze_3, 0,0)==false);\n\n    vector<vector<int>> maze_4 = {{0,0,0,1,0},\n                                  {1,1,0,1,0},\n                                  {0,0,0,0,0},\n                                  {0,1,1,1,0},\n                                  {0,0,0,0,0}};\n    assert(findExit(maze_4, 4,4)==true);\n\n    vector<vector<int>> maze_5 = {{0,1,0,0,0},\n                                  {0,1,0,1,0},\n                                  {0,0,0,0,0},\n                                  {0,1,0,1,0},\n                                  {0,0,0,0,0}};\n    assert(findExit(maze_5, 0,0)==true);\n\n    return 0;\n}\n"}
{"language": "c++", "domain": "game", "source": "gpt4+人工筛选；源文件地址/data/xw/c++dataset/game/already/279.cpp", "prompt": "#include <iostream>\n#include <vector>\n/*\n确定井字棋游戏的胜负\nbool determineTicTacToe(std::vector<std::vector<char>> board)\nboard 是一个3x3的字符矩阵, 'X' 表示玩家X, 'O' 表示玩家O, '.' 表示空位\n如果玩家X胜利, 返回 'X'\n如果玩家O胜利, 返回 'O'\n如果比赛未有结论, 返回 '.'\n*/\n", "solution": "char determineTicTacToe(std::vector<std::vector<char>> board){\n    for(int i = 0; i < 3; ++i){\n        if(board[i][0] == board[i][1] && board[i][1] == board[i][2] && board[i][0] != '.'){\n            return board[i][0];\n        }\n        if(board[0][i] == board[1][i] && board[1][i] == board[2][i] && board[0][i] != '.'){\n            return board[0][i];\n        }\n    }\n    if(board[0][0] == board[1][1] && board[1][1] == board[2][2] && board[0][0] != '.'){\n        return board[0][0];\n    }\n    if(board[0][2] == board[1][1] && board[1][1] == board[2][0] && board[0][2] != '.'){\n        return board[0][2];\n    }\n    return '.';\n}\n", "test": "#include<assert.h>\nint main(){\n    std::vector<std::vector<char>> board1 = {{'X', '.', 'O'}, {'.', 'X', 'O'}, {'O', 'O', 'X'}};\n    std::vector<std::vector<char>> board2 = {{'X', 'X', 'X'}, {'.', '.', 'O'}, {'O', 'O', '.'}};\n    std::vector<std::vector<char>> board3 = {{'X', 'O', 'X'}, {'O', 'O', 'X'}, {'O', 'X', 'O'}};\n    std::vector<std::vector<char>> board4 = {{'O', 'X', 'O'}, {'X', 'X', 'O'}, {'X', 'X', 'O'}};\n    std::vector<std::vector<char>> board5 = {{'X', '.', 'O'}, {'.', 'O', 'X'}, {'.', 'X', '.'}};\n    assert(determineTicTacToe(board1) == 'X');\n    assert(determineTicTacToe(board2) == 'X');\n    assert(determineTicTacToe(board3) == '.');\n    assert(determineTicTacToe(board4) == 'X');\n    assert(determineTicTacToe(board5) == '.');\n    return 0;\n}\n"}
{"language": "c++", "domain": "game", "source": "gpt4+人工筛选；源文件地址/data/xw/c++dataset/game/already/153.cpp", "prompt": "#include <stdlib.h>\n#include <assert.h>\n\n/* \n实现一个简单的点数游戏，每个玩家有10点初始点数，玩家可选择抢点或者不抢。\n玩家每次都有50%的概率抢点，每次成功抢到的点数为1，如果有一个玩家点数达到15点，那么该玩家就赢得游戏。\n游戏允许最多进行20轮，如果20轮之内没有玩家达到15点，那么最后点数高的玩家获胜，如果点数相同，则表示游戏平局。\n函数的格式定义为：int play_game()\n函数返回值为0表示玩家A赢，1表示玩家B赢，2表示游戏平局\n*/\n\n", "solution": "\n// 该函数用来模拟抢点过程\nint grab_point() {\n    return rand() % 2;\n}\n\nint play_game() {\n    int rounds = 20;\n    int pointsA = 10;\n    int pointsB = 10;\n    while (rounds > 0) {\n        pointsA += grab_point();\n        pointsB += grab_point();\n        if (pointsA >= 15) return 0; //玩家A赢\n        if (pointsB >= 15) return 1; //玩家B赢\n        rounds--;\n    }\n    //20轮后，判断胜负\n    if (pointsA > pointsB) return 0; //20轮后，点数多的获胜\n    if (pointsA < pointsB) return 1;\n    return 2; //平局\n}\n", "test": "int main() {\n    srand(1);\n    assert(play_game() == 1);   \n\n    srand(2);\n    assert(play_game() == 1);  \n\n    srand(3);\n    assert(play_game() == 1);   \n\n    srand(4);\n    assert(play_game() == 1);  \n\n    srand(5);\n    assert(play_game() == 1); \n    return 0;\n}\n"}
{"language": "c++", "domain": "game", "source": "gpt4+人工筛选；源文件地址/data/xw/c++dataset/game/already/210.cpp", "prompt": "#include <vector>\n#include <assert.h>\n/*检查井字棋是否有赢家\n  int checkTicTacToe(std::vector<std::vector<int>>& board)\n  输入一个3x3的vector，每个cell有0（空），1（玩家1的棋），或者2（玩家2的棋）\n  如果有人赢了返回1或者2，否则返回0。\n*/\n", "solution": "int checkTicTacToe(std::vector<std::vector<int>>& board) {\n    //检查行\n    for(int i = 0 ; i < 3 ; ++i) {\n      if(board[i][0] == board[i][1] && board[i][1] == board[i][2] && board[i][0]) {\n        return board[i][0];\n      }\n    }\n    //检查列\n    for(int j = 0 ; j < 3 ; ++j) {\n      if(board[0][j] == board[1][j] && board[1][j] == board[2][j] && board[0][j]) {\n        return board[0][j];\n      }\n    }\n    //检查对角线\n    if(board[0][0] == board[1][1] && board[1][1] == board[2][2] && board[0][0]) {\n      return board[0][0];\n    }\n    if(board[0][2] == board[1][1] && board[1][1] == board[2][0] && board[0][2]) {\n      return board[0][2];\n    }   \n    //无人胜出\n    return 0;\n}\n", "test": "int main() {\n    std::vector<std::vector<int>> board1 = {{1, 0, 2}, {2, 1, 0}, {1, 2, 0}};\n    assert(checkTicTacToe(board1) == 0); // 无人胜出\n    std::vector<std::vector<int>> board2 = {{1, 1, 1}, {2, 1, 0}, {1, 2, 0}};\n    assert(checkTicTacToe(board2) == 1); // 玩家1胜出\n    std::vector<std::vector<int>> board3 = {{1, 2, 2}, {2, 2, 0}, {1, 2, 1}};\n    assert(checkTicTacToe(board3) == 2); // 玩家2胜出\n    std::vector<std::vector<int>> board4 = {{2, 1, 1}, {2, 1, 0}, {2, 2, 0}};\n    assert(checkTicTacToe(board4) == 2); // 玩家2胜出\n    std::vector<std::vector<int>> board5 = {{1, 0, 2}, {1, 1, 0}, {1, 2, 0}};\n    assert(checkTicTacToe(board5) == 1); // 玩家1胜出\n    return 0;\n}\n"}
{"language": "c++", "domain": "game", "source": "gpt4+人工筛选；源文件地址/data/xw/c++dataset/game/already/11111.cpp", "prompt": "#include <iostream>\n\nusing namespace std;\n\n/* 实现一个简单的数独验证函数\n函数的格式定义为：bool isValidSudoku(int grid[9][9])\ngrid 是一个 9x9 的二维数组，代表数独的格子，有效的数字为1-9，未填写的格子为0\n如果这个数独在现有的数字上是有效的，则返回true，否则返回false\n*/\n", "solution": "bool isValidSudoku(int grid[9][9]) {\n    //检查每一行\n    for(int i=0; i<9; ++i) {\n        bool exists[10] = { false };\n        for(int j=0; j<9; ++j) {\n            if (grid[i][j] != 0 && exists[grid[i][j]])\n                return false;\n            exists[grid[i][j]] = true;\n        }\n    }\n\n    //检查每一列\n    for(int j=0; j<9; ++j) {\n        bool exists[10] = { false };\n        for(int i=0; i<9; ++i) {\n            if (grid[i][j] != 0 && exists[grid[i][j]])\n                return false;\n            exists[grid[i][j]] = true;\n        }\n    }\n\n    //检查9个3x3的方格\n    for(int di=0; di<3; ++di) {\n        for(int dj=0; dj<3; ++dj) {\n            bool exists[10] = { false };\n            for(int i=0; i<3; ++i) {\n                for(int j=0; j<3; ++j) {\n                    if (grid[3*di+i][3*dj+j] != 0 && exists[grid[3*di+i][3*dj+j]])\n                        return false;\n                    exists[grid[3*di+i][3*dj+j]] = true;\n                }\n            }\n        }\n    }\n\n    return true;\n}\n", "test": "#include<assert.h>\nint main() {\n    int grid1[9][9] = {\n        {5, 3, 0, 0, 7, 0, 0, 0, 0},\n        {6, 0, 0, 1, 9, 5, 0, 0, 0},\n        {0, 9, 8, 0, 0, 0, 0, 6, 0},\n        {8, 0, 0, 0, 6, 0, 0, 0, 3},\n        {4, 0, 0, 8, 0, 3, 0, 0, 1},\n        {7, 0, 0, 0, 2, 0, 0, 0, 6},\n        {0, 6, 0, 0, 0, 0, 2, 8, 0},\n        {0, 0, 0, 4, 1, 9, 0, 0, 5},\n        {0, 0, 0, 0, 8, 0, 0, 7, 9}\n    };\n\n    int grid2[9][9] = {\n        {8, 3, 0, 0, 7, 0, 0, 0, 0},\n        {6, 0, 0, 1, 9, 5, 0, 0, 0},\n        {0, 9, 8, 0, 0, 0, 0, 6, 0},\n        {8, 0, 0, 0, 6, 0, 0, 0, 3},\n        {4, 0, 0, 8, 0, 3, 0, 0, 1},\n        {7, 0, 0, 0, 2, 0, 0, 0, 6},\n        {0, 6, 0, 0, 0, 0, 2, 8, 0},\n        {0, 0, 0, 4, 1, 9, 0, 0, 5},\n        {0, 0, 0, 0, 8, 0, 0, 7, 9}\n    };\n\n    assert(isValidSudoku(grid1) == true);\n    assert(isValidSudoku(grid2) == false);\n\n    return 0;\n}\n"}
{"language": "c++", "domain": "game", "source": "gpt4+人工筛选；源文件地址/data/xw/c++dataset/game/already/204.cpp", "prompt": "#include <iostream>\n#include <vector>\n\nusing namespace std;\n\n/*实现井字棋游戏的胜负判断函数\n函数的格式定义为：int winChecker(vector<vector<int>>& board)\nboard是一个3x3的矩阵，分别用0，1，2表示空，玩家1，玩家2\n返回一个表示游戏结果的数字（0表示还没结束，1表示玩家1赢，2表示玩家2赢，3表示平局）\n*/\n", "solution": "int winChecker(vector<vector<int>>& board){\n    for (int i = 0; i < 3; i++) {\n        if (board[i][0] == board[i][1] && board[i][1] == board[i][2] && board[i][0] != 0) {\n            return board[i][0];\n        }\n        if (board[0][i] == board[1][i] && board[1][i] == board[2][i] && board[0][i] != 0) {\n            return board[0][i];\n        }\n    }\n    if (board[0][0] == board[1][1] && board[1][1] == board[2][2] && board[0][0] != 0) {\n        return board[0][0];\n    }\n    if (board[0][2] == board[1][1] && board[1][1] == board[2][0] && board[0][2] != 0) {\n        return board[0][2];\n    }\n    for(int i = 0; i < 3; i++) {\n        for(int j = 0; j < 3; j++) {\n            if(board[i][j] == 0) {\n                return 0;\n            }\n        }\n    }\n    return 3;\n}\n", "test": "#include<assert.h>\nint main() {\n    vector<vector<int>> board1 = {{1,2,1},{2,1,2},{1,2,1}};\n    assert(winChecker(board1)==1);\n\n    vector<vector<int>> board2 = {{1,2,1},{2,1,2},{2,2,2}};\n    assert(winChecker(board2)==2);\n\n    vector<vector<int>> board3 = {{1,1,1},{2,1,2},{2,2,0}};\n    assert(winChecker(board3)==1);\n\n    vector<vector<int>> board4 = {{0,1,2},{0,1,2},{2,2,2}};\n    assert(winChecker(board4)==2);\n\n    vector<vector<int>> board5 = {{0,0,0},{2,1,2},{1,2,1}};\n    assert(winChecker(board5)==0);\n    return 0;\n}\n"}
{"language": "c++", "domain": "game", "source": "gpt4+人工筛选；源文件地址/data/xw/c++dataset/game/already/156.cpp", "prompt": "#include<cmath>\n\n/*\n实现一个判断棋盘游戏是否获胜的函数\n函数格式定义为：bool checkWin(int board[],int size)\nboard为一个一维数组来代表棋盘，其中0代表空位，1代表玩家1的棋子，2代表玩家2的棋子\nsize为棋盘的大小。假设棋盘是一个正方形，size就是棋盘的边长。\n如果其中某一个玩家在任意一条直线（行，列，对角线）上连续放置了size个棋子，就判定这个玩家获胜，函数返回true\n否则返回false\n*/\n", "solution": "bool checkWin(int board[],int size){\n    int sum1, sum2;\n    for(int i=0; i<size; i++){ //检查每一行\n        sum1=0, sum2=0;\n        for(int j=0; j<size; j++){\n            if(board[i*size+j]==1) sum1++;\n            if(board[i*size+j]==2) sum2++;\n        }\n        if(sum1==size || sum2==size) return true;\n    }\n    for(int i=0; i<size; i++){ //检查每一列\n        sum1=0, sum2=0;\n        for(int j=0; j<size; j++){\n            if(board[j*size+i]==1) sum1++;\n            if(board[j*size+i]==2) sum2++;\n        }\n        if(sum1==size || sum2==size) return true;\n    }\n    sum1=0, sum2=0;\n    for(int i=0; i<size; i++){ //检查正对角线\n        if(board[i*size+i]==1) sum1++;\n        if(board[i*size+i]==2) sum2++;\n    }\n    if(sum1==size || sum2==size) return true;\n    sum1=0, sum2=0;\n    for(int i=0; i<size; i++){ //检查反对角线\n        if(board[i*size+(size-i-1)]==1) sum1++;\n        if(board[i*size+(size-i-1)]==2) sum2++;\n    }\n    if(sum1==size || sum2==size) return true;\n    return false;\n}\n", "test": "#include<assert.h>\nint main() {\n    int board1[9] = {1,0,0,0,1,0,0,0,1};\n    int board2[9] = {1,1,1,0,2,0,0,0,2};\n    int board3[9] = {1,0,0,0,1,0,0,0,2};\n    int board4[9] = {1,1,1,0,0,0,2,2,2};\n    int board5[9] = {2,2,2,0,1,0,0,0,1};\n    assert(checkWin(board1,3)==true);\n    assert(checkWin(board2,3)==true);\n    assert(checkWin(board3,3)==false);\n    assert(checkWin(board4,3)==true);\n    assert(checkWin(board5,3)==true);\n    return 0;\n}\n"}
{"language": "c++", "domain": "game", "source": "gpt4+人工筛选；源文件地址/data/xw/c++dataset/game/already/183.cpp", "prompt": "#include <vector>\n#include <iostream>\nusing namespace std;\n\n/* 实现一个函数，用于判断2048游戏是否结束。\n函数的格式定义为：bool isGameOver(vector<vector<int>> &board)\nboard 表示游戏的棋盘，二维数组，元素是2的n次方和0，0代表空位\n返回一个布尔值，表示游戏是否结束，如果棋盘充满（无空位），并且任何相邻的两个数都不相等，则游戏结束，返回true，否则返回false\n*/\n", "solution": "bool isGameOver(vector<vector<int>> &board) {\n    int n = board.size();\n    if(n==0 || board[0].size()==0) return true; //如果棋盘大小为0，游戏结束\n    for (int i = 0; i < n; ++i) \n        for (int j = 0; j < n; ++j) {\n            if(board[i][j]==0) \n                return false; //如果有空位，游戏未结束\n            //如果上下左右有相等的元素，游戏未结束\n            if ((i > 0 && board[i][j] == board[i-1][j]) || (i < n - 1 && board[i][j] == board[i+1][j]) || (j > 0 && board[i][j] == board[i][j-1]) || (j < n - 1 && board[i][j] == board[i][j+1]))\n                return false;\n        }\n    return true; //如果以上情况都不成立，游戏结束\n}\n", "test": "#include<assert.h>\nint main() {\n\n    vector<vector<int>> board1 = {{2, 4, 2, 4}, {4, 2, 4, 2}, {2, 4, 2, 4}, {4, 2, 4, 0}}; //未填满的棋盘\n    vector<vector<int>> board2 = {{2, 4, 2, 4}, {4, 2, 4, 2}, {2, 4, 2, 4}, {4, 2, 4, 2}}; //填满且无法合并\n    vector<vector<int>> board3 = {{2, 4, 8, 8}, {4, 2, 4, 2}, {2, 4, 2, 4}, {4, 2, 4, 2}}; //填满但可以合并\n    vector<vector<int>> board4 = {}; //空棋盘\n    vector<vector<int>> board5 = {{2, 4, 2}, {4, 2, 4}, {2, 4, 2}}; //3x3的棋盘，可以合并\n\n    assert(isGameOver(board1) == false);\n    assert(isGameOver(board2) == true);\n    assert(isGameOver(board3) == false);\n    assert(isGameOver(board4) == true);\n    assert(isGameOver(board5) == true);\n\n    return 0;\n}\n"}
{"language": "c++", "domain": "game", "source": "gpt4+人工筛选；源文件地址/data/xw/c++dataset/game/already/165.cpp", "prompt": "#include <iostream>\n#include <vector>\n/*\n输出小游戏不同状态下的胜负判定结果\nbool isWin(std::vector<std::vector<int>> &board, int player)\nboard表示队列，包括0-空位，1-玩家1，2-玩家2；player表示当前玩家，为1或2\n*/\n", "solution": "bool isWin(std::vector<std::vector<int>> &board, int player) {\n    for (int i = 0; i < board.size(); i++) {\n        for(int j = 0; j < board[0].size(); j++) {\n            // 横向判断\n            if (i<=board.size()-4 && board[i][j]==player && board[i+1][j]==player && board[i+2][j]==player && board[i+3][j]==player)\n                return true;\n            // 纵向判断\n            if (j<=board[0].size()-4 && board[i][j]==player && board[i][j+1]==player && board[i][j+2]==player && board[i][j+3]==player)\n                return true;\n            // 对角线判断（两种方向）\n            if (i<=board.size()-4 && j<=board[0].size()-4 && \n               (board[i][j]==player && board[i+1][j+1]==player && board[i+2][j+2]==player && board[i+3][j+3]==player ||  \n               board[i+3][j]==player && board[i+2][j+1]==player && board[i+1][j+2]==player && board[i][j+3]==player))\n                return true;\n        }\n    }\n    return false;\n}\n", "test": "#include <cassert>\nint main(){\n    std::vector<std::vector<int>> board1 = { {1,1,1,1,0,0,0},{2,2,2,0,0,0,0},{0,0,0,0,0,0,0},{0,0,0,0,0,0,0},{0,0,0,0,0,0,0} };\n    assert(isWin(board1, 1) == true);\n    assert(isWin(board1, 2) == false);\n\n    std::vector<std::vector<int>> board2 = { {1,2,1,2,0,0,0},{2,1,2,0,0,0,0},{1,2,1,0,0,0,0},{2,1,2,0,0,0,0},{0,0,0,0,0,0,0} };\n    assert(isWin(board2, 1) == false);\n    assert(isWin(board2, 2) == true);\n\n    std::vector<std::vector<int>> board3 = { {1,1,2,2,0,0,0},{2,1,1,0,0,0,0},{1,2,2,0,0,0,0},{2,1,2,0,0,0,0},{0,0,0,0,0,0,0} };\n    assert(isWin(board3, 1) == false);\n    assert(isWin(board3, 2) == false);\n\n    std::vector<std::vector<int>> board4 = { {1,1,2,2,2,2,0},{2,1,1,0,0,0,0},{1,2,2,0,0,0,0},{2,1,2,0,0,0,0},{0,0,0,0,0,0,0} };\n    assert(isWin(board4, 1) == false);\n    assert(isWin(board4, 2) == true);\n\n    std::vector<std::vector<int>> board5 = { {1,2,1,1,0,0,0},{2,1,2,1,0,0,0},{1,2,1,1,0,0,0},{2,1,2,1,0,0,0},{1,2,1,1,0,0,0} };\n    assert(isWin(board5, 1) == true);\n    assert(isWin(board5, 2) == false);\n\n    return 0;\n}\n"}
{"language": "c++", "domain": "game", "source": "gpt4+人工筛选；源文件地址/data/xw/c++dataset/game/already/48.cpp", "prompt": "/*\n1. initGame 函数：初始化游戏的函数，返回一个初始化后的游戏状态对象。\n2. judgeWinLose 函数：接收一个游戏状态对象，判断当前游戏的胜负，并返回结果。\n3. changeState 函数：接收一个游戏状态对象，执行一次状态转移，并返回新的游戏状态。\n4. move 函数：接收一个游戏状态对象和一个方向字符，执行移动操作，并返回新的游戏状态。\n5. nextStep 函数：接收一个游戏状态对象，执行下一步操作，并返回新的游戏状态。\n*/\n", "solution": "typedef std::vector<std::vector<int>> GameState;\n\n// 游戏初始化\nGameState initGame(int size);\n\n// 胜负判定\nbool judgeWinLose(const GameState& state);\n\n// 状态变更\nGameState changeState(const GameState& state, int x, int y, int value);\n\n// 移动\nGameState move(const GameState& state, char direction);\n\n// 下一步\nGameState nextStep(const GameState& state);\n// input_end\n\n", "test": "GameState initGame(int size) {\n    return GameState(size, std::vector<int>(size, 0));\n}\n\nbool judgeWinLose(const GameState& state) {\n    for (const auto& row : state) {\n        for (int num : row) {\n            if (num == 2048) {\n                return true;\n            }\n        }\n    }\n    return false;\n}\n\nGameState changeState(const GameState& state, int x, int y, int value) {\n    GameState newState = state;\n    newState[x][y] = value;\n    return newState;\n}\n\nGameState move(const GameState& state, char direction) {\n    // 暂未实现，需要具体游戏规则进行实现\n}\n"}
{"language": "c++", "domain": "game", "source": "gpt4+人工筛选；源文件地址/data/xw/c++dataset/game/already/300.cpp", "prompt": "#include <iostream>\n#include <cstring>\n/*  \n初始化田字棋游戏盘面\nvoid initTicTacToeBoard(int board[3][3])\nboard是一个3x3的二维数组，初始化为全零\n*/\n", "solution": "void initTicTacToeBoard(int board[3][3]) {\n    memset(board, 0, 3*3*sizeof(int));\n}\n", "test": "#include<assert.h>\nint main() {\n    int board[3][3];\n    initTicTacToeBoard(board);\n    for(int i = 0; i < 3; i++) {\n        for(int j = 0; j < 3; j++) {\n            assert(board[i][j] == 0);\n        }\n    }\n    return 0;\n}\n"}
{"language": "c++", "domain": "game", "source": "gpt4+人工筛选；源文件地址/data/xw/c++dataset/game/already/354.cpp", "prompt": "#include <iostream>\n\nusing namespace std;\n\n/*实现一个简单的游戏函数，需找到数组中最大的数值\n函数的格式定义为：int findMax(int array[], int size）\narray是含有整数的数组,size是数组的大小\n返回一个表示数组中最大数值的整数\n\n注意：数组中的数值范围在-10000 ~ 10000之间.\n*/\n\n", "solution": "int findMax(int array[], int size){\n    int max = array[0];\n    for(int i = 1; i < size; ++i){\n        if(max < array[i]){\n            max = array[i];\n        }\n    }\n    return max;\n}\n", "test": "#include<assert.h>\nint main() {\n    int array1[5] = {1,2,3,4,5};\n    int array2[5] = {-1,-2,-3,-4,-5};\n    int array3[5] = {-1,0,1,0,-1};\n    int array4[5] = {10000,2,3,0,-10000};\n    int array5[5] = {0,0,0,0,0};\n\n    assert(findMax(array1,5)==5);\n    assert(findMax(array2,5)==-1);\n    assert(findMax(array3,5)==1);\n    assert(findMax(array4,5)==10000);\n    assert(findMax(array5,5)==0);\n    \n    return 0;\n}\n"}
{"language": "c++", "domain": "game", "source": "gpt4+人工筛选；源文件地址/data/xw/c++dataset/game/already/144.cpp", "prompt": "#include <iostream>\n# include <vector>\nusing namespace std;\n/*检查井字棋的获胜者\nchar detectWinner(vector<vector<char>>& gameBoard)\n给定一个井字棋的棋盘（3x3），检查是否有玩家（'X' 或 'O'）取得了胜利。\n如果有玩家胜出，则返回该玩家的字符；如果游戏还在进行中，则返回 ' ';如果没有玩家胜出则返回 'D'\n*/\n", "solution": "char detectWinner(vector<vector<char>>& gameBoard) {\n    // 检查行\n    for(int i = 0; i < 3; i++)\n        if(gameBoard[i][0] == gameBoard[i][1] && gameBoard[i][1] == gameBoard[i][2])\n            if(gameBoard[i][0]!='-')\n                return gameBoard[i][0];\n\n    // 检查列\n    for(int i = 0; i < 3; i++)\n        if(gameBoard[0][i] == gameBoard[1][i] && gameBoard[1][i] == gameBoard[2][i])\n            if(gameBoard[0][i]!='-')\n                return gameBoard[0][i];\n\n    // 检查对角线\n    if(gameBoard[0][0] == gameBoard[1][1] && gameBoard[1][1] == gameBoard[2][2])\n        if(gameBoard[0][0]!='-')\n            return gameBoard[0][0];\n    if(gameBoard[0][2] == gameBoard[1][1] && gameBoard[1][1] == gameBoard[2][0])\n        if(gameBoard[0][2]!='-')\n            return gameBoard[0][2];\n\n    // 检查是否还有剩余的空格\n    for(auto& row : gameBoard)\n        for(char c : row)\n            if(c == '-') return ' ';\n\n    // 如果没有剩余的空格，则返回 'D' 表示平局\n    return 'D';\n}\n", "test": "#include<assert.h>\nint main() {\n    vector<vector<char>> gameBoard1 = {{'X', 'O', 'X'}, {'-', 'X', '-'}, {'-', '-', 'O'}};\n    assert(detectWinner(gameBoard1) == ' '); \n    vector<vector<char>> gameBoard2 = {{'O', 'X', 'O'}, {'-', 'O', '-'}, {'-', '-', 'O'}};\n    assert(detectWinner(gameBoard2) == 'O'); // O 获胜\n    vector<vector<char>> gameBoard3 = {{'X', 'O', 'O'}, {'O', 'X', 'O'}, {'X', 'O', 'O'}};\n    assert(detectWinner(gameBoard3) == 'O'); \n    vector<vector<char>> gameBoard4 = {{'-', '-', '-'}, {'-', '-', '-'}, {'-', '-', '-'}};\n    assert(detectWinner(gameBoard4) == ' '); // 游戏还在进行中\n    vector<vector<char>> gameBoard5 = {{'-', '-', 'X'}, {'-', 'O', '-'}, {'-', '-', '-'}};\n    assert(detectWinner(gameBoard5) == ' '); // 游戏还在进行中\n}\n"}
{"language": "c++", "domain": "game", "source": "gpt4+人工筛选；源文件地址/data/xw/c++dataset/game/already/324.cpp", "prompt": "#include <iostream>\n#include <vector>\n/*判断井字游戏是否有人胜利，用于扫雷，井字等游戏胜利条件判断 \nbool isWin(std::vector<std::vector<int>> &board)\nboard是井字游戏的棋盘，盘上的元素是表示每个格子的状态，0为空，1表示\"X\"，-1表示\"O\"\n如果有玩家胜利，返回ture，否则返回false\n*/\n", "solution": "bool isWin(std::vector<std::vector<int>> &board) {\n    int n = board.size(); \n    for(int i=0;i<n;i++) {\n        if(board[i][0] != 0 && board[i][0]==board[i][1] && board[i][0]==board[i][2])  \n            return true;\n        if(board[0][i] != 0 && board[0][i]==board[1][i] && board[0][i]==board[2][i]) \n            return true;\n    }\n    if(board[0][0] != 0 && board[0][0]==board[1][1] && board[0][0]==board[2][2]) \n        return true;\n    if(board[0][2] != 0 && board[0][2]==board[1][1] && board[0][2]==board[2][0]) \n        return true;\n\n    return false;\n}\n", "test": "#include<assert.h>\nint main() {\n    std::vector<std::vector<int>> board1 = {{0, 0, 1}, {0, 1, 0}, {1, 0, 0}};\n    assert(isWin(board1)==true);\n    std::vector<std::vector<int>> board2 = {{1, 1, 1}, {0, 0, 0}, {0, 0, 0}};\n    assert(isWin(board2)==true);\n    std::vector<std::vector<int>> board3 = {{0, 0, 1}, {0, 1, 0}, {1, 0, 1}};\n    assert(isWin(board3)==true);\n    std::vector<std::vector<int>> board4 = {{0, 1, 0}, {1, 1, 1}, {0, 0, 0}};\n    assert(isWin(board4)==true);\n    std::vector<std::vector<int>> board5 = {{1, 0, 0}, {0, 1, 0}, {0, 0, 1}};\n    assert(isWin(board5)==true);\n    return 0;\n}\n"}
{"language": "c++", "domain": "game", "source": "gpt4+人工筛选；源文件地址/data/xw/c++dataset/game/already/27.cpp", "prompt": "#include<iostream>\n/*\n此程序主要是一个简单的井字游戏，主要包含以下功能：\n1. 游戏初始化函数\n    void initGame(char [3][3])\n    该函数主要是接受一个3x3的字符数组，将数组所有值初始化为' '。\n2. 检查游戏结果函数\n    char checkWin(char [3][3])\n    该函数接受一个3x3的字符数组(游戏盘)，如果有玩家胜利返回该玩家的标志，如果平局返回'd'，否则返回'n'。\n*/\n\n", "solution": "#include<cstdlib>\n#include<iostream>\nusing namespace std;\n\nvoid initGame(char gameBoard[3][3]){\n    for(int i=0;i<3;i++)\n        for(int j=0;j<3;j++)\n            gameBoard[i][j]=' ';\n}\n\nchar checkWin(char gameBoard[3][3]){\n    for(int i=0;i<3;i++)\n        if(gameBoard[i][0]==gameBoard[i][1]&&gameBoard[i][1]==gameBoard[i][2]&&gameBoard[i][0]!=' ')\n            return gameBoard[i][0];\n    for(int j=0;j<3;j++)\n        if(gameBoard[0][j]==gameBoard[1][j]&&gameBoard[1][j]==gameBoard[2][j]&&gameBoard[0][j]!=' ')\n            return gameBoard[0][j];\n    if(gameBoard[0][0]==gameBoard[1][1]&&gameBoard[1][1]==gameBoard[2][2]&&gameBoard[0][0]!=' ')\n        return gameBoard[0][0];\n    if(gameBoard[0][2]==gameBoard[1][1]&&gameBoard[1][1]==gameBoard[2][0]&&gameBoard[2][0]!=' ')\n        return gameBoard[2][0];\n    for(int i=0;i<3;i++)\n        for(int j=0;j<3;j++)\n            if(gameBoard[i][j]==' ')\n                return 'n';\n    return 'd';\n}\n", "test": "#include<assert.h>\n\nint main()\n{\n    char gameBoard[3][3];\n    \n    initGame(gameBoard);\n    for(int i=0;i<3;i++)\n        for(int j=0;j<3;j++)\n            assert(gameBoard[i][j]==' '); //初始化后gameBoard应该全部为空\n    \n    // playerMove(gameBoard, 'X');\n    // assert(gameBoard[0][0]=='X'); //玩家标记点应该为'X'\n\n    char res = checkWin(gameBoard);\n    assert(res == 'n'); //初始状态下应该无人胜利\n    gameBoard[0][0]='X';\n    gameBoard[0][1]='X';\n    gameBoard[0][2]='X';\n    res = checkWin(gameBoard);\n    assert(res == 'X'); //第一行全为X时，X玩家胜利\n\n    initGame(gameBoard);\n    for(int i=0;i<3;i++)\n        for(int j=0;j<3;j++)\n            gameBoard[i][j]='X';\n    gameBoard[1][1]='O';\n    res=checkWin(gameBoard);\n    assert(res=='X'); \n\n    return 0;\n}\n"}
{"language": "c++", "domain": "game", "source": "gpt4+人工筛选；源文件地址/data/xw/c++dataset/game/already/game6.cpp", "prompt": "#include<iostream>\n#include<ctime>\n#include<cstdlib>\n\nusing namespace std;\n/* 用于实现猜数字游戏的函数，游戏规则为：计算机随机生成一个1-100的数字，玩家进行猜测，\n如用户猜的数字比目标数字大，则返回1，比目标数字小，则返回-1，正好等于目标数字。则返回0。\n函数格式定义为：int guessNumber(int guess) */\n", "solution": "int randomNumber;\nvoid init() {\n    srand(time(0));\n    randomNumber = rand() % 100 + 1;\n}\nint guessNumber(int guess) {\n    if (guess < randomNumber) {\n        return -1;\n    } else if (guess > randomNumber) {\n        return 1;\n    } else {\n        return 0;\n    }\n}\n", "test": "#include<assert.h>\nint main() {\n    init();\n    int guess[] = {50,75,63,57,59};\n    for(int i = 0; i < 5; ++i) {\n        if(randomNumber > guess[i]) {\n            assert(guessNumber(guess[i]) == -1);\n        } else if(randomNumber < guess[i]) {\n            assert(guessNumber(guess[i]) == 1);\n        } else {\n            assert(guessNumber(guess[i]) == 0);\n        }\n    }\n    return 0;\n}\n"}
{"language": "c++", "domain": "game", "source": "gpt4+人工筛选；源文件地址/data/xw/c++dataset/game/already/195.cpp", "prompt": "#include<iostream>\n/*\n检查井字棋游戏胜负\nint checkGameResult(int board[3][3])\nboard是一个3x3的数组，表示井字棋的棋盘，其中0表示空，1表示玩家1的棋子，2表示玩家2的棋子，返回0表示平局，1表示玩家1胜，2表示玩家2胜\n*/\n", "solution": "int checkGameResult(int board[3][3]) {\n    for(int i=0; i<3; ++i) {\n        if(board[i][0]==board[i][1] && board[i][1]==board[i][2])\n            return board[i][0];\n        if(board[0][i]==board[1][i] && board[1][i]==board[2][i])\n            return board[0][i];\n    }\n    if(board[0][0]==board[1][1] && board[1][1]==board[2][2])\n        return board[0][0];\n    if(board[0][2]==board[1][1] && board[1][1]==board[2][0])\n        return board[0][2];\n    return 0;\n}\n", "test": "#include<assert.h>\nint main() {\n    int game1[3][3] = {{1, 2, 1}, {2, 1, 2}, {1, 2, 2}};\n    int game2[3][3] = {{1, 2, 0}, {0, 1, 2}, {2, 2, 1}};\n    int game3[3][3] = {{2, 2, 2}, {1, 1, 0}, {1, 2, 1}};\n    int game4[3][3] = {{1, 2, 1}, {2, 1, 0}, {0, 2, 2}};\n    assert(checkGameResult(game1)==1);\n    assert(checkGameResult(game2)==1);\n    assert(checkGameResult(game3)==2);\n    assert(checkGameResult(game4)==0);\n    return 0;\n}\n"}
{"language": "c++", "domain": "game", "source": "gpt4+人工筛选；源文件地址/data/xw/c++dataset/game/already/216.cpp", "prompt": "#include<iostream>\n#include<vector>\n/* \n 检查一个3x3的井字游戏的胜负情况\n int checkTicTacToeWin(std::vector<std::vector<int>>& board);\n board是一个3x3的二维数组，表示一个井字游戏的棋盘\n 其中0表示空位，1表示玩家1的棋子，2表示玩家2的棋子\n 返回值是-1表示游戏仍在进行，0表示平局，1表示玩家1获胜，2表示玩家2获胜。\n*/\n", "solution": "int checkTicTacToeWin(std::vector<std::vector<int>>& board) {\n    for (int i = 0; i < 3; ++i) {\n        if (board[i][0] == board[i][1] && board[i][1] == board[i][2] && board[i][0] != 0) {\n            return board[i][0];\n        }\n        if (board[0][i] == board[1][i] && board[1][i] == board[2][i] && board[0][i] != 0) {\n            return board[0][i];\n        }\n    }\n    if (board[0][0] == board[1][1] && board[1][1] == board[2][2] && board[0][0] != 0) {\n        return board[0][0];\n    }\n    if (board[0][2] == board[1][1] && board[1][1] == board[2][0] && board[0][2] != 0) {\n        return board[0][2];\n    }\n    for (const auto& row : board) {\n        for (const auto& col : row) {\n            if (col == 0) {\n                return -1;\n            }\n        }\n    }\n    return 0;\n}\n", "test": "#include<assert.h>\nint main() {\n    std::vector<std::vector<int>> board1{{1,2,0},{2,1,0},{2,1,1}};\n    assert(checkTicTacToeWin(board1)==1);\n    std::vector<std::vector<int>> board2{{2,2,2},{1,2,0},{1,0,1}};\n    assert(checkTicTacToeWin(board2)==2);\n    std::vector<std::vector<int>> board3{{1,1,2},{2,2,1},{1,2,1}};\n    assert(checkTicTacToeWin(board3)==0);\n    std::vector<std::vector<int>> board4{{1,1,0},{2,2,0},{0,0,0}};\n    assert(checkTicTacToeWin(board4)==-1);\n    std::vector<std::vector<int>> board5{{1,1,2},{2,2,1},{1,2,2}};\n    assert(checkTicTacToeWin(board5)==0);\n    return 0;\n}\n"}
{"language": "c++", "domain": "game", "source": "gpt4+人工筛选；源文件地址/data/xw/c++dataset/game/already/150.cpp", "prompt": "#include<iostream>\n#include<vector> \n/* \n初始化一个3*3的井字棋盘\nvoid bootstrapBoard(vector<vector<int>> &board);\n通过引用接受一个二维向量来表示棋盘的状态，每个元素可以为0，1或2，其中0表示该位置为空，1表示该位置由玩家1放置，2表示该位置由玩家2放置。\n*/\n", "solution": "void bootstrapBoard(std::vector<std::vector<int>> &board) {\n    board.resize(3, std::vector<int>(3, 0));\n}\n", "test": "#include<assert.h>\nint main() {\n    std::vector<std::vector<int>> board;\n    bootstrapBoard(board);\n    assert(board.size() == 3 && board[0].size() == 3);\n    for(int i=0;i<3;i++) {\n        for(int j=0;j<3;j++) {\n            assert(board[i][j] == 0);\n        }\n    }\n    std::vector<std::vector<int>> board1;\n    bootstrapBoard(board1);\n    assert(board1.size() == 3 && board1[0].size() == 3);\n    for(int i=0;i<3;i++) {\n        for(int j=0;j<3;j++) {\n            assert(board1[i][j] == 0);\n        }\n    }\n    std::vector<std::vector<int>> board2;\n    bootstrapBoard(board2);\n    assert(board2.size() == 3 && board2[0].size() == 3);\n    for(int i=0;i<3;i++) {\n        for(int j=0;j<3;j++) {\n            assert(board2[i][j] == 0);\n        }\n    }\n    std::vector<std::vector<int>> board3;\n    bootstrapBoard(board3);\n    assert(board3.size() == 3 && board3[0].size() == 3);\n    for(int i=0;i<3;i++) {\n        for(int j=0;j<3;j++) {\n            assert(board3[i][j] == 0);\n        }\n    }\n    std::vector<std::vector<int>> board4;\n    bootstrapBoard(board4);\n    assert(board4.size() == 3 && board4[0].size() == 3);\n    for(int i=0;i<3;i++) {\n        for(int j=0;j<3;j++) {\n            assert(board4[i][j] == 0);\n        }\n    }\n    return 0;\n}\n"}
{"language": "c++", "domain": "game", "source": "gpt4+人工筛选；源文件地址/data/xw/c++dataset/game/already/273.cpp", "prompt": "#include <iostream>\n#include <cmath>\n\nusing namespace std;\n\n/* 实现一个简单的猜数游戏，玩家在给定的猜测次数内猜出目标数字\n函数的格式定义为：bool GuessNumber(int guess, int target, int attempts)\nguess是玩家的猜测\ntarget是目标数字\nattempts是剩余的猜测次数\n如果玩家的猜测正确，返回true，否则返回false\n*/\n", "solution": "bool GuessNumber(int guess, int target, int attempts) {\n    if(attempts <= 0) {\n        return false;\n    }\n    if(guess == target) {\n        return true;\n    }\n    return GuessNumber(guess, target, attempts - 1);\n}\n", "test": "#include<assert.h>\nint main() {\n    assert(GuessNumber(10, 100, 1) == false);\n    assert(GuessNumber(100, 100, 100) == true);\n    assert(GuessNumber(12, 12, 0) == false);\n    assert(GuessNumber(100, 100, 0) == false);\n    assert(GuessNumber(99, 100, 1) == false);\n\n    return 0;\n}\n"}
{"language": "c++", "domain": "game", "source": "gpt4+人工筛选；源文件地址/data/xw/c++dataset/game/already/141.cpp", "prompt": "#include <iostream>\n\nusing namespace std;\n/*实现蛇行游戏的分数计算\n（n*n的矩阵，0表示没有果实，其他数字表示有果实的分数）\n函数的格式定义为：int SnakeGame(int[n][n] board)\nboard是一个n*n的矩阵，代表蛇行游戏中的果实状况\n返回一个表示游戏得分的数字（游戏进行中，蛇头会根据果实的状况获得相应的分数，没有果实则分数不变）\n*/\n", "solution": "int SnakeGame(int board[5][5], int n) {\n    int score = 0;\n    for(int i=0; i<n; i++){\n        for(int j=0; j<n; j++){\n            score += board[i][j];\n        }\n    }\n    return score;\n}\n", "test": "#include<assert.h>\nint main() {\n    int board1[5][5] = { {1, 1, 1, 1, 1},\n                         {1, 2, 3, 4, 5},\n                         {1, 2, 3, 4, 5},\n                         {1, 2, 3, 4, 5},\n                         {1, 1, 1, 1, 1} };\n    \n    int board2[5][5] = { {0, 0, 0, 0, 0},\n                         {0, 0, 0, 0, 0},\n                         {0, 0, 0, 0, 0},\n                         {0, 0, 0, 0, 0},\n                         {0, 0, 0, 0, 0} };\n    \n    int board3[5][5] = { {5, 7, 9, 11, 13},\n                         {4, 6, 8, 10, 12},\n                         {3, 5, 7, 9, 11},\n                         {2, 4, 6, 8, 10},\n                         {1, 3, 5, 7, 9} };\n    \n    int board4[5][5] = { {10, 10, 10, 10, 10},\n                         {20, 20, 20, 20, 20},\n                         {30, 30, 30, 30, 30},\n                         {40, 40, 40, 40, 40},\n                         {50, 50, 50, 50, 50} };\n\n    assert(SnakeGame(board1,5)==55);\n    assert(SnakeGame(board2,5)==0);\n    assert(SnakeGame(board3,5)==175);\n    assert(SnakeGame(board4,5)==750);\n\n    return 0;\n}\n"}
{"language": "c++", "domain": "game", "source": "gpt4+人工筛选；源文件地址/data/xw/c++dataset/game/already/369.cpp", "prompt": "#include <iostream>\n#include <vector>\n\n/*\n给定一个3x3的棋盘，检测是否有人赢得了井字棋游戏。 \nint ticTacToe(std::vector<std::vector<char>>& board) \n返回值：如果 'X' 赢得了游戏，返回 1；如果 'O' 赢得了游戏，返回 -1；如果还未分出胜负或者平局，返回 0。\n*/\n", "solution": "int ticTacToe(std::vector<std::vector<char>>& board) \n{\n    for(int i=0; i<3; i++){\n        if(board[i][0] == board[i][1] && board[i][1] == board[i][2]) {\n            if(board[i][0] == 'X')\n                return 1;\n            else if(board[i][0] == 'O')\n                return -1;\n        }\n        if(board[0][i] == board[1][i] && board[1][i] == board[2][i]) {\n            if(board[0][i] == 'X')\n                return 1;\n            else if(board[0][i] == 'O')\n                return -1;\n        }\n    }\n\n    if(board[0][0]==board[1][1] && board[1][1]==board[2][2]) {\n        if(board[0][0] == 'X')\n            return 1;\n        else if(board[0][0] == 'O')\n            return -1;\n    }\n\n    if(board[0][2]==board[1][1] && board[1][1]==board[2][0]) {\n        if(board[0][2] == 'X')\n            return 1;\n        else if(board[0][2] == 'O')\n            return -1;\n    }\n    \n    return 0;\n}\n", "test": "#include<assert.h>\nvoid testCaseticTacToe() \n{\n    std::vector<std::vector<char>> board1 = { {'X', 'O', 'X'}, {'O', 'X', 'O'}, {'O', 'O', 'X'} };\n    assert(ticTacToe(board1) == 1);\n\n    std::vector<std::vector<char>> board2 = { {'X', 'X', 'O'}, {'O', 'O', 'X'}, {'X', 'O', 'O'} };\n    assert(ticTacToe(board2) == 0);\n\n    std::vector<std::vector<char>> board3 = { {'X', 'X', 'O'}, {'O', 'O', 'X'}, {'X', 'O', ' '} };\n    assert(ticTacToe(board3) == 0);\n\n    std::vector<std::vector<char>> board4 = { {' ', ' ', ' '}, {' ', ' ', ' '}, {' ', ' ', ' '} };\n    assert(ticTacToe(board4) == 0);\n\n    std::vector<std::vector<char>> board5 = { {'O', 'X', 'O'}, {'X', 'O', 'X'}, {'X', 'O', 'O'} };\n    assert(ticTacToe(board5) == -1);\n}\n\nint main() \n{\n    testCaseticTacToe();\n    return 0;\n}\n"}
{"language": "c++", "domain": "game", "source": "gpt4+人工筛选；源文件地址/data/xw/c++dataset/game/already/game0.cpp", "prompt": "#include <iostream>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\n/*实现算24点游戏的函数\n输入是一个包含4个整数的vector，代表四个1-9之间的数\n函数的定义为：string calculate24Points(vector<int> points)\npoints - 一个包含4个1-9之间的数的vector\n返回一个字符串，显示是否可以通过加减乘除达到24，或者无解。\n*/\n", "solution": "bool DFS(vector<int>& a, int n) {\n    if(n == 1){\n        if(a[0] == 24)\n            return true;         \n        else \n            return false;\n    }\n\n    vector<int> b(a.begin(), a.begin() + n);\n    sort(b.begin(), b.end());\n    do{\n        for(int i = 0; i < n - 1; i++){\n            a[i] = b[i];\n        }\n        a[n-1] = b[n-1];\n\n        for (int i = 0; i < n-1; i++){\n            a[i] = b[i] + b[i + 1];\n            if (DFS(a, n - 1))\n                return true;\n            a[i] = b[i] - b[i + 1];\n            if (DFS(a, n - 1))\n                return true;\n            a[i] = b[i] * b[i + 1];\n            if (DFS(a, n - 1))\n                return true;\n            if (b[i + 1] != 0){\n                a[i] = b[i] / b[i + 1];\n                if (DFS(a, n - 1))\n                    return true;\n            }\n        }\n    }while (next_permutation(b.begin(), b.end()));\n\n    return false;\n}\n\nstring calculate24Points(vector<int> points) {\n    if(DFS(points, points.size()))\n        return \"Can calculate to 24.\";\n    else\n        return \"Cannot calculate to 24.\";\n}\n", "test": "#include<assert.h>\nint main() {\n    assert(calculate24Points({1,2,3,4})==\"Can calculate to 24.\");\n    assert(calculate24Points({1,1,1,1})==\"Cannot calculate to 24.\");\n    assert(calculate24Points({3,8,3,8})==\"Can calculate to 24.\");\n    assert(calculate24Points({2,5,2,5})==\"Can calculate to 24.\");\n    assert(calculate24Points({9,1,3,6})==\"Can calculate to 24.\");\n\n    return 0;\n}\n"}
{"language": "c++", "domain": "game", "source": "gpt4+人工筛选；源文件地址/data/xw/c++dataset/game/already/240.cpp", "prompt": "#include <stdbool.h>\n/*\n函数判定在井字棋游戏中，是否有玩家获胜。游戏的状态由一个3x3的二维字符数组表示，'X' 表示玩家一的棋子，'O' 表示玩家二的棋子，' ' 表示该位置还没有放置棋子。如果有玩家在横行、竖列或对角线上连续三个棋子，则该玩家获胜。如果没有玩家获胜，则返回 ' '。\n函数的格式定义为：char checkWinner(char board[3][3])\n其中 board 代表井字棋的游戏状态。\n*/\n", "solution": "char checkWinner(char board[3][3]) {\n    // check rows\n    for (int i = 0; i < 3; i++) {\n        if (board[i][0] == board[i][1] && board[i][1] == board[i][2]) {\n            return board[i][0];\n        }\n    }\n\n    // check columns\n    for (int j = 0; j < 3; j++) {\n        if (board[0][j] == board[1][j] && board[1][j] == board[2][j]) {\n            return board[0][j];\n        }\n    }\n\n    // check diagonals\n    if (board[0][0] == board[1][1] && board[1][1] == board[2][2]) {\n        return board[0][0];\n    }\n    if (board[0][2] == board[1][1] && board[1][1] == board[2][0]) {\n        return board[0][2];\n    }\n\n    // no winner\n    return ' ';\n}\n", "test": "#include <assert.h>\n\nint main() {\n    char board1[3][3] = {\n        {'X', 'O', 'X'},\n        {'O', 'X', 'O'},\n        {' ', 'O', 'X'}\n    };\n    assert(checkWinner(board1) == 'X');\n\n    char board2[3][3] = {\n        {'X', 'O', 'X'},\n        {'O', 'X', 'O'},\n        {' ', 'X', 'X'}\n    };\n    assert(checkWinner(board2) == 'X');\n\n    char board3[3][3] = {\n        {'O', 'O', 'O'},\n        {' ', 'X', 'X'},\n        {'X', 'X', 'O'}\n    };\n    assert(checkWinner(board3) == 'O');\n\n    char board4[3][3] = {\n        {' ', ' ', ' '},\n        {' ', ' ', ' '},\n        {' ', ' ', ' '}\n    };\n    assert(checkWinner(board4) == ' ');\n\n    char board5[3][3] = {\n        {'O', 'X', 'X'},\n        {'X', 'O', 'O'},\n        {'X', 'O', 'X'}\n    };\n    assert(checkWinner(board5) == ' ');\n\n    return 0;\n}\n"}
{"language": "c++", "domain": "game", "source": "gpt4+人工筛选；源文件地址/data/xw/c++dataset/game/already/42.cpp", "prompt": "#include <iostream>\n#include <assert.h>\n#include <string>\n\n// 表示游戏角色的初始位置\nstd::pair<int, int> player = {0, 0}; \n", "solution": "void move(std::string action);\n// input_end\n\n// solution_start\nvoid move(std::string action) {\n    if (action==\"up\")\n        player.second++;\n    else if (action==\"down\")\n        player.second--;\n    else if (action==\"left\")\n        player.first--;\n    else if (action==\"right\")\n        player.first++;\n    else \n        std::cout << \"Invalid action\" << std::endl;\n}\n// solution_end\n\n// test_start\nint main() {\n    move(\"up\");\n    assert(player == std::make_pair(0, 1)); \n\n    move(\"down\");\n    assert(player == std::make_pair(0, 0)); \n\n", "test": "\n    move(\"right\");\n    assert(player == std::make_pair(0, 0)); \n\n    move(\"jump\");\n    assert(player == std::make_pair(0, 0));  \n    \n    return 0;\n}\n// test_end"}
{"language": "c++", "domain": "game", "source": "gpt4+人工筛选；源文件地址/data/xw/c++dataset/game/already/255.cpp", "prompt": "#include<iostream>\n#include<vector>\n/*该函数 gameStatus 返回当前拥有棋子数的玩家是否已经获胜\nint gameStatus(std::vector<std::vector<int>>& boardState, int player)\nboardState 为二维数组，表示当前棋盘状态，其中0表示无棋子，1表示第一位玩家的棋子，2表示第二位玩家的棋子；\nplayer 表示当前玩家；\n返回1表示该玩家获胜，0表示未分出胜负，-1表示输入错误；\n*/\n", "solution": "int gameStatus(std::vector<std::vector<int>>& boardState, int player) {\n    if(player!=1 && player!=2) return -1; // 输入错误\n    int size=boardState.size();\n    for(int i=0; i<size; i++) {\n        for(int j=0; j<size-4; j++) {\n            if(boardState[i][j]==player && boardState[i][j+1]==player && boardState[i][j+2]==player & boardState[i][j+3]==player && boardState[i][j+4]==player) \n                return 1; // 该玩家水平连成五子，获胜\n            if(boardState[j][i]==player && boardState[j+1][i]==player && boardState[j+2][i]==player & boardState[j+3][i]==player && boardState[j+4][i]==player) \n                return 1; // 该玩家竖直连成五子，获胜\n        }\n    }\n    for(int i=0; i<size-4; i++) {\n        for(int j=0; j<size-4; j++) {\n            if(boardState[i][j]==player && boardState[i+1][j+1]==player && boardState[i+2][j+2]==player & boardState[i+3][j+3]==player && boardState[i+4][j+4]==player) \n                return 1; // 该玩家斜向右下方连成五子，获胜\n            if(boardState[i][j+4]==player && boardState[i+1][j+3]==player && boardState[i+2][j+2]==player & boardState[i+3][j+1]==player && boardState[i+4][j]==player) \n                return 1; // 该玩家斜向左下方连成五子，获胜\n        }\n    }\n    return 0; // 未分出胜负\n}\n", "test": "#include<assert.h>\nint main() {\n    std::vector<std::vector<int>> boardState1 = {\n         {1,2,1,0,0},\n         {2,1,2,0,0},\n         {1,2,1,0,0},\n         {2,1,2,0,0},\n         {1,2,1,0,0}};\n    assert(gameStatus(boardState1,1)==0);\n    assert(gameStatus(boardState1,2)==0);\n    std::vector<std::vector<int>> boardState2 = {\n         {1,1,1,1,1},\n         {2,1,1,1,1},\n         {1,2,1,1,1},\n         {1,2,1,1,0},\n         {1,1,2,1,2}};\n    assert(gameStatus(boardState2,1)==1);//player 1 wins\n    std::vector<std::vector<int>> boardState3 = {\n         {1,1,2,1,2},\n         {2,1,2,1,2},\n         {1,2,2,2,2},\n         {1,1,2,1,1},\n         {1,2,1,2,1}};\n    int currentPlayer = 2;\n    assert(gameStatus(boardState3, currentPlayer) == 0); //player 2 wins\n    std::vector<std::vector<int>> boardState4 = {\n         {0,0,0,0,0},\n         {0,0,0,0,0},\n         {0,0,0,0,0},\n         {0,0,0,0,0},\n         {0,0,0,0,0}};\n    assert(gameStatus(boardState4,1)==0);\n    assert(gameStatus(boardState4,3)==-1); //player 3 is invalid\n    return 0;\n}\n"}
{"language": "c++", "domain": "game", "source": "gpt4+人工筛选；源文件地址/data/xw/c++dataset/game/already/246.cpp", "prompt": "#include<iostream>\n\nusing namespace std;\n/* 用于实现井字棋游戏的函数，游戏规则为：3x3的棋盘上，有两位玩家轮流将自己的符号放在空的格子中，\n一方先让三格连着的方向（包括斜线）为同一符号的获胜。\n函数格式定义为：char judgeVictory(char board[3][3])，输入为3x3的字符数组，'X'代表玩家1，'O'代表玩家2，' '代表空格。*/\n", "solution": "char judgeVictory(char board[3][3]) {\n    for(int i = 0; i < 3; ++i) {\n        if(board[i][0] == board[i][1] && board[i][1] == board[i][2] && board[i][0] != ' ')\n            return board[i][0];\n        if(board[0][i] == board[1][i] && board[1][i] == board[2][i] && board[0][i] != ' ')\n            return board[0][i];\n    }\n    if(board[0][0] == board[1][1] && board[1][1] == board[2][2] && board[0][0] != ' ')\n        return board[0][0];\n    if(board[0][2] == board[1][1] && board[1][1] == board[2][0] && board[0][2] != ' ')\n        return board[0][2];\n    return ' ';\n}\n", "test": "#include<assert.h>\nint main() {\n    char board1[3][3] = {{'X', 'O', 'X'},{'O', 'X', 'O'},{'X', ' ', 'O'}};\n    char board2[3][3] = {{'X', 'O', 'X'},{'O', 'X', 'X'},{'O', 'X', 'O'}};\n    char board3[3][3] = {{'X', 'O', ' '},{'O', 'X', 'O'},{'X', ' ', 'X'}};\n    char board4[3][3] = {{'O', 'X', 'O'},{'O', 'O', 'X'},{'X', 'X', 'O'}};\n    char board5[3][3] = {{' ', 'X', 'O'},{'O', ' ', 'X'},{'X', 'O', ' '}};\n    assert(judgeVictory(board1) == 'X');\n    assert(judgeVictory(board2) == ' ');\n    assert(judgeVictory(board3) == 'X');\n    assert(judgeVictory(board4) == 'O');\n    assert(judgeVictory(board5) == ' ');\n    return 0;\n}\n"}
{"language": "c++", "domain": "game", "source": "gpt4+人工筛选；源文件地址/data/xw/c++dataset/game/already/219.cpp", "prompt": "#include <iostream>\n/*\n实现一个简单的游戏角色移动功能，角色处于一个2维的平面上，有x和y两个坐标，\n角色可以上下左右移动，每次移动一格，返回角色移动后的新坐标。\n角色的初始坐标为(0, 0), 上下左右移动的指令分别为 'U', 'D', 'L', 'R'\n函数定义为void move_character(char direction, int& x, int& y)\ndirection是方向指令, 'U', 'D', 'L', 'R'分别代表上，下，左，右\nx, y是角色的坐标，起始坐标为(0, 0)\n*/\n", "solution": "void move_character(char direction, int& x, int& y) {\n    switch (direction) {\n        case 'U':\n            ++y;\n            break;\n        case 'D':\n            --y;\n            break;\n        case 'L':\n            --x;\n            break;\n        case 'R':\n            ++x;\n            break;\n    }\n}\n", "test": "#include <cassert>\nint main() {\n    int x = 0, y = 0;\n    move_character('U', x, y);\n    assert(x == 0 && y == 1); // move up from (0, 0) to (0, 1)\n\n    move_character('D', x, y);\n    assert(x == 0 && y == 0); // move down from (0, 1) to (0, 0)\n\n    move_character('L', x, y);\n    assert(x == -1 && y == 0); // move left from (0, 0) to (-1, 0)\n\n    move_character('R', x, y);\n    assert(x == 0 && y == 0); // move right from (-1, 0) to (0, 0)\n\n    move_character('U', x, y);\n    move_character('U', x, y);\n    assert(x == 0 && y == 2); // move up twice from (0, 0) to (0, 2)\n}\n"}
{"language": "c++", "domain": "game", "source": "gpt4+人工筛选；源文件地址/data/xw/c++dataset/game/already/312.cpp", "prompt": "#include<iostream>\n#include<ctime>\n#include<cstdlib>\n\nusing namespace std;\n/* 用于实现走迷宫游戏的函数，游戏规则为：计算机随机生成一个二维数组作为迷宫地图，0表示通路，1表示墙壁，\n玩家通过输入方向进行移动，到达迷宫出口则获胜。\n函数格式定义为：bool move(char direction) */\n", "solution": "int maze[10][10];\nint playerX, playerY;\nvoid init() {\n    srand(time(0));\n    for (int i = 0; i < 10; i++) {\n        for (int j = 0; j < 10; j++) {\n            maze[i][j] = rand() % 2;\n        }\n    }\n    playerX = 0;\n    playerY = 0;\n    maze[0][0] = 0;\n    maze[9][9] = 0;\n}\nbool move(char direction) {\n    int dx = 0, dy = 0;\n    switch (direction) {\n    case 'l':dy = -1; break;\n    case 'r':dy = 1; break;\n    case 'u':dx = -1; break;\n    case 'd':dx = 1; break;\n    }\n    if (playerX+dx >=0 && playerX+dx <10 && playerY+dy >=0 && playerY+dy <10 && maze[playerX+dx][playerY+dy] == 0) {\n        playerX+=dx;\n        playerY+=dy;\n        return true;\n    }\n    return false;\n}\nbool isWin(){\n    return playerX == 9 && playerY == 9;\n}\n", "test": "#include<assert.h>\nint main() {\n    init();\n    char moves[] = { 'l', 'u', 'r', 'd', 'r' };\n    for (int i = 0; i < 5; ++i) {\n        move(moves[i]);\n    }\n    return 0;\n}\n"}
{"language": "c++", "domain": "game", "source": "gpt4+人工筛选；源文件地址/data/xw/c++dataset/game/already/108.cpp", "prompt": "#include <vector>\n\n/*\n判断井字棋游戏的胜者\n函数的格式定义为：char gameWinner(const std::vector<std::vector<char>>& board)\n其中, board是一个3*3的矩阵，代表井字棋的棋盘，数据类型为char，取值只能为'X', 'O' 或 ' '，后者代表该位置还没有下棋\n返回值是'X', 'O' 或 'D',分别代表X方获胜，O方获胜或者平局。\n井字棋规则：任意一方如果在水平、竖直或者对角线方向上先连成3个相同的棋子，则该方获胜。\n如果棋盘被下满，并且没有获胜的一方，则判定为平局，返回'D'\n*/\n", "solution": "char gameWinner(const std::vector<std::vector<char>>& board) {\n    // check rows\n    for (int i = 0; i < 3; ++i) {\n        if (board[i][0] != ' ' && board[i][0] == board[i][1] && board[i][1] == board[i][2]) {\n            return board[i][0];\n        }\n    }\n\n    // check columns\n    for (int i = 0; i < 3; ++i) {\n        if (board[0][i] != ' ' && board[0][i] == board[1][i] && board[1][i] == board[2][i]) {\n            return board[0][i];\n        }\n    }\n\n    // check diagonals\n    if ((board[0][0] != ' ' && board[0][0] == board[1][1] && board[1][1] == board[2][2]) ||\n        (board[0][2] != ' ' && board[0][2] == board[1][1] && board[1][1] == board[2][0])) {\n            return board[1][1];\n    }\n\n    // check for draw\n    for (const auto& row : board) {\n        for (const auto& val : row) {\n            if (val == ' ') {\n                return ' ';  // game is not over\n            }\n        }\n    }\n\n    return 'D';  // draw\n}\n", "test": "#include <cassert>\n\nint main() {\n    assert(gameWinner({\n        {'X', ' ', ' '},\n        {' ', 'X', ' '},\n        {' ', ' ', 'X'}}) == 'X');\n    assert(gameWinner({\n        {'O', 'O', 'O'},\n        {' ', ' ', ' '},\n        {' ', ' ', ' '}}) == 'O');\n    assert(gameWinner({\n        {'O', 'X', 'O'},\n        {'X', 'X', 'O'},\n        {'X', 'O', 'X'}}) == 'D');\n    assert(gameWinner({\n        {' ', ' ', ' '},\n        {' ', ' ', ' '},\n        {' ', ' ', ' '}}) == ' ');\n}\n"}
{"language": "c++", "domain": "game", "source": "gpt4+人工筛选；源文件地址/data/xw/c++dataset/game/already/168.cpp", "prompt": "#include<iostream>\n/* 判断井字游戏是否有人赢得游戏\nbool checkTicTacToe(int board[3][3])\nboard是一个3x3的二维数组，代表井字游戏的状态。\n1代表玩家1，2代表玩家2，0代表空格。返回true代表有人赢得游戏，false代表游戏未结束或者平局。\n*/\n", "solution": "bool checkTicTacToe(int board[3][3]) {\n    // 检查行\n    for (int i = 0; i < 3; i++) {\n        if (board[i][0] && board[i][0] == board[i][1] && board[i][0] == board[i][2]) return true;\n    }\n    // 检查列\n    for (int i = 0; i < 3; i++) {\n        if (board[0][i] && board[0][i] == board[1][i] && board[0][i] == board[2][i]) return true;\n    }\n    // 检查对角线\n    if (board[0][0] && board[0][0] == board[1][1] && board[0][0] == board[2][2]) return true;\n    if (board[0][2] && board[0][2] == board[1][1] && board[0][2] == board[2][0]) return true;\n    return false; //没有人赢得游戏\n}\n", "test": "#include<assert.h>\n\nint main() {\n    int board1[3][3] = {\n        {1, 2, 0},\n        {0, 1, 0},\n        {2, 0, 1}\n    };\n    assert(checkTicTacToe(board1) == true);\n    int board2[3][3] = {\n        {2, 2, 0},\n        {0, 1, 0},\n        {1, 0, 1}\n    };\n    assert(checkTicTacToe(board2) == false);\n    int board3[3][3] = {\n        {1, 1, 1},\n        {0, 2, 0},\n        {2, 0, 2}\n    };\n    assert(checkTicTacToe(board3) == true);\n    int board4[3][3] = {\n        {2, 2, 2},\n        {1, 1, 0},\n        {0, 0, 1}\n    };\n    assert(checkTicTacToe(board4) == true);\n    int board5[3][3] = {\n        {0, 0, 0},\n        {0, 0, 0},\n        {0, 0, 0}\n    };\n    assert(checkTicTacToe(board5) == false);\n    return 0;\n}\n"}
{"language": "c++", "domain": "game", "source": "gpt4+人工筛选；源文件地址/data/xw/c++dataset/game/already/game2.cpp", "prompt": "#include <iostream>\n#include <vector>\n\nusing namespace std;\n\n/*实现扑克牌游戏的函数\n函数的格式定义为：int playPoker(vector<int>& player1Cards, vector<int>& player2Cards)\nplayer1Cards和player2Cards的选择，分别表示玩家1和玩家2的牌（1-13，1表示2，2表示3，…，11表示Q，12表示K，13表示A）\n返回一个表示游戏结果的数字（0表示平局，1表示玩家1赢，2表示玩家2赢）\n*/\n", "solution": "int playPoker(vector<int>& player1Cards, vector<int>& player2Cards){\n    int sum1 = 0, sum2 = 0;\n    for(auto i: player1Cards) sum1 += i;\n    for(auto i: player2Cards) sum2 += i;\n\n    if (sum1 > sum2) {\n        return 1;\n    } else if (sum2 > sum1) {\n        return 2;\n    } else {\n        return 0;\n    }\n}\n", "test": "#include<assert.h>\nint main() {\n    vector<int> cards1_1 = {1, 2, 3, 4, 5};\n    vector<int> cards2_1 = {6, 7, 8, 9, 10};\n    assert(playPoker(cards1_1, cards2_1)==2);\n\n    vector<int> cards1_2 = {2, 3, 4, 5, 6};\n    vector<int> cards2_2 = {1, 2, 3, 4, 5};\n    assert(playPoker(cards1_2, cards2_2)==1);\n\n    vector<int> cards1_3 = {2, 4, 6, 8, 10};\n    vector<int> cards2_3 = {1, 3, 5, 7, 9};\n    assert(playPoker(cards1_3, cards2_3)==1);\n\n    vector<int> cards1_4 = {1, 3, 5, 7, 9};\n    vector<int> cards2_4 = {2, 4, 6, 8, 10};\n    assert(playPoker(cards1_4, cards2_4)==2);\n\n    vector<int> cards1_5 = {1, 1, 1, 1, 1};\n    vector<int> cards2_5 = {2, 2, 2, 2, 2};\n    assert(playPoker(cards1_5, cards2_5)==2);\n    return 0;\n}\n"}
{"language": "c++", "domain": "game", "source": "gpt4+人工筛选；源文件地址/data/xw/c++dataset/game/already/177.cpp", "prompt": "#include <iostream>\n#include <vector>\n#include <cassert>\n\nusing namespace std;\n\n/*实现判断井字棋胜负的功能\n输入是一个3x3的二维数组，代表井字棋的棋盘布局；\n函数的格式定义为：char judgeGameState(vector<vector<char> > board);\n返回一个字符，'X'代表X赢，'O'代表O赢，'D'代表平局，'N'代表游戏未结束\n*/\n", "solution": "char judgeGameState(vector<vector<char> > board) {\n    for (int i = 0; i<3; i++) {\n        if (board[i][0] != ' ' && board[i][0] == board[i][1] && board[i][1] == board[i][2])\n            return board[i][0] == 'X' ? 'X' : 'O';\n        if (board[0][i] != ' ' && board[0][i] == board[1][i] && board[1][i] == board[2][i])\n            return board[0][i] == 'X' ? 'X' : 'O';\n    }\n    if (board[0][0] != ' ' && board[0][0] == board[1][1] && board[1][1] == board[2][2])\n        return board[0][0] == 'X' ? 'X' : 'O';\n    if (board[2][0] != ' ' && board[2][0] == board[1][1] && board[1][1] == board[0][2])\n        return board[2][0] == 'X' ? 'X' : 'O';\n    \n    for(int i = 0; i < 3; i++)\n        for(int j = 0; j < 3; j++)\n            if(board[i][j] == ' ') return 'N';\n\n    return 'D';\n}\n", "test": "int main() {\n    vector<vector<char> > board1{\n        {'X', 'X', 'X'},\n        {' ', 'O', ' '},\n        {'O', ' ', 'O'}};\n    assert(judgeGameState(board1) == 'X');\n\n    vector<vector<char> > board2{\n        {'X', 'O', 'X'},\n        {'X', 'O', 'O'},\n        {'O', 'X', 'O'}};\n    assert(judgeGameState(board2) == 'D');\n\n    vector<vector<char> > board3{\n        {'X', 'O', 'X'},\n        {'X', 'O', 'O'},\n        {' ', ' ', ' '}};\n    assert(judgeGameState(board3) == 'N');\n    \n    vector<vector<char> > board4{\n        {'X', 'O', 'X'},\n        {'O', 'O', 'X'},\n        {'X', 'X', 'O'}};\n    assert(judgeGameState(board4) == 'D');\n\n    vector<vector<char> > board5{\n        {'X', ' ', 'X'},\n        {'O', 'O', 'O'},\n        {'X', 'X', 'O'}};\n    assert(judgeGameState(board5) == 'O');\n    \n    return 0;\n}\n"}
{"language": "c++", "domain": "game", "source": "gpt4+人工筛选；源文件地址/data/xw/c++dataset/game/already/234.cpp", "prompt": "#include<iostream>\n/* bool isPlayerWin(int playerScore, int computerScore)\n这个函数用于确定游戏的胜负。\n传入两个参数，playerScore是玩家的分数，computerScore是电脑的分数。\n函数返回一个布尔值，如果玩家胜利，则返回true；否则返回false。\n*/\n", "solution": "bool isPlayerWin(int playerScore, int computerScore) {\n  //如果玩家的分数高于电脑的分数，玩家胜利\n  if (playerScore > computerScore) {\n    return true;\n  }\n  //否则，电脑胜利\n  else {\n    return false;\n  }\n}\n", "test": "#include<assert.h>\nint main() {\n  assert(isPlayerWin(10, 9) == true);\n  assert(isPlayerWin(0, 0) == false);\n  assert(isPlayerWin(5, 5) == false);\n  assert(isPlayerWin(7, 8) == false);\n  assert(isPlayerWin(20, 19) == true);\n  return 0;\n}\n"}
{"language": "c++", "domain": "game", "source": "gpt4+人工筛选；源文件地址/data/xw/c++dataset/game/already/180.cpp", "prompt": "#include<iostream>\n\n/* 用于实现一个简单井字游戏的函数，游戏规则为：两名玩家在一个3x3的网格上进行游戏，\n每名玩家可以在任一空格处填入标识（O 或 X），当任一玩家的标识形成一行、一列或对角线时，该玩家即为胜者，\n如果所有空格均被填满但仍无玩家胜出，则游戏平手。函数输入为一个3x3的数组，其中0代表空格，1代表点，\n-1代表X，返回值为1表示点赢，-1表示X赢，0表示平手。\n函数格式定义为：int ticTacToe(int** board, int num_players, int num_rows, int num_cols) */\n", "solution": "int ticTacToe(int** board, int num_players, int num_rows, int num_cols) {\n    for (int i = 0; i < num_rows; ++i) {\n        int sum_row = 0;\n        for (int j = 0; j < num_cols; ++j) {\n            sum_row += board[i][j];\n        }\n        if (sum_row == num_players) {\n            return 1;\n        } else if (sum_row == -num_players) {\n            return -1;\n        }    \n    }\n    \n    for (int j = 0; j < num_cols; ++j) {\n        int sum_col = 0;\n        for (int i = 0; i < num_rows; ++i) {\n            sum_col += board[i][j];\n        }\n        if (sum_col == num_players) {\n            return 1;\n        } else if (sum_col == -num_players) {\n            return -1;\n        }    \n    }\n    \n    int sum_diag1 = 0;\n    int sum_diag2 = 0;\n    for (int i = 0; i < num_rows; ++i) {\n        sum_diag1 += board[i][i];\n        sum_diag2 += board[i][num_cols - 1 - i];\n    }\n    if (sum_diag1 == num_players || sum_diag2 == num_players) {\n        return 1;\n    } else if (sum_diag1 == -num_players || sum_diag2 == -num_players) {\n        return -1;\n    }   \n \n    return 0;\n}\n", "test": "#include<assert.h>\nint main() {\n    int board1[3][3] = {{1,-1,0},{-1,1,-1},{0,1,-1}};\n    int board2[3][3] = {{-1,-1,1},{1,1,-1},{-1,1,1}};\n    int board3[3][3] = {{1,1,1},{-1,-1,0},{0,0,-1}};\n    int board4[3][3] = {{-1,1,-1},{-1,1,-1},{-1,1,1}};\n    int board5[3][3] = {{0,0,0},{0,0,0},{0,0,0}};\n    assert(ticTacToe((int**)board1, 2, 3, 3) == -1);\n    assert(ticTacToe((int**)board2, 2, 3, 3) == 0);\n    assert(ticTacToe((int**)board3, 2, 3, 3) == 1);\n    assert(ticTacToe((int**)board4, 2, 3, 3) == -1);\n    assert(ticTacToe((int**)board5, 2, 3, 3) == 0);\n    return 0;\n}\n"}
{"language": "c++", "domain": "game", "source": "gpt4+人工筛选；源文件地址/data/xw/c++dataset/game/already/288.cpp", "prompt": "#include <iostream>\n\nusing namespace std;\n\n/*实现一个猜数字游戏的函数\n用户和电脑各输入一个1-10之间的数字，如果用户的数字比电脑大，返回1，否则返回2，如果两个数字一样大，则返回0表示平局。\n函数的格式定义为：int guessNumberGame(int userNumber, int computerNumber)\n用户的选择和电脑的选择都是1-10的数字。\n返回一个表示游戏结果的数字（0表示平局，1表示用户赢，2表示电脑赢）\n*/\n", "solution": "int guessNumberGame(int userNumber, int computerNumber) {\n    if (userNumber == computerNumber) {\n        return 0; \n    } else if (userNumber > computerNumber) {\n        return 1; \n    } else {\n        return 2; \n    }\n}\n", "test": "#include<assert.h>\nint main() {\n    assert(guessNumberGame(6,3)==1);\n    assert(guessNumberGame(7,9)==2);\n    assert(guessNumberGame(3,3)==0);\n    assert(guessNumberGame(10,1)==1);\n    assert(guessNumberGame(5,6)==2);\n\n    return 0;\n}\n"}
{"language": "c++", "domain": "game", "source": "gpt4+人工筛选；源文件地址/data/xw/c++dataset/game/already/213.cpp", "prompt": "#include <iostream>\n/*function moveCharacter(int &x, int &y, char direction)\n这个函数使得字符在二维平面上进行移动。通过更改x和y的值，可以模拟角色在二维地图上进行移动。\nx: 角色在二维地图的x坐标。\ny: 角色在二维地图的y坐标。\ndirection: 角色移动的方向。用单个字符表示移动的方向，'U'表示向上（y轴正方向），'D'表示向下（y轴负方向），'L'表示向左（x轴负方向），'R'表示向右（x轴正方向）。\n如果方向无效（不是 'U', 'D', 'L', 'R' 其中之一），此函数应该返回 false。否则，返回 true。\n*/\n", "solution": "bool moveCharacter(int &x, int &y, char direction) {\n    switch(direction) {\n        case 'U':\n            y += 1;\n            break;\n        case 'D':\n           y -= 1;\n           break;\n        case 'L':\n           x -= 1;\n           break;\n        case 'R':\n           x += 1;\n           break;\n        default:\n           return false;\n    }\n    return true;\n}\n", "test": "#include<assert.h>\nint main(){\n    int x = 0;\n    int y = 0;\n    assert(moveCharacter(x, y, 'U'));\n    assert(x==0 && y==1);\n    assert(moveCharacter(x, y, 'D'));\n    assert(x==0 && y==0);\n    assert(moveCharacter(x, y, 'L'));\n    assert(x==-1 && y==0);\n    assert(moveCharacter(x, y, 'R'));\n    assert(x==0 && y==0);\n    assert(!moveCharacter(x, y, 'A'));\n    assert(x==0 && y==0);\n    return 0;\n}\n"}
{"language": "c++", "domain": "game", "source": "gpt4+人工筛选；源文件地址/data/xw/c++dataset/game/already/363.cpp", "prompt": "#include <stdio.h>\n#include <stdlib.h>\n/*\n实现检测井字棋胜者\nint getTicTacToeWinner(char (*board)[3])\nboard是一个3x3的二维字符数组，代表井字棋的棋盘，其中，'X'代表玩家X的棋子，'O'代表玩家O的棋子，' '代表未下棋的地方。\n如果玩家X胜出，则返回1；如果玩家O胜出，则返回2；如果游戏还没有结束，则返回0；\n关于井字棋的规则，就是任何一方先在任一行、列、对角线上连成一线则为胜者。\n*/\n", "solution": "int getTicTacToeWinner(char (*board)[3]) {\n    // check each row\n    for (int i = 0; i < 3; i++) {\n        if (board[i][0] == board[i][1] && board[i][1] == board[i][2]) {\n            if (board[i][0] == 'X') return 1;\n            if (board[i][0] == 'O') return 2;\n        }\n    }\n\n    // check each column\n    for (int i = 0; i < 3; i++) {\n        if (board[0][i] == board[1][i] && board[1][i] == board[2][i]) {\n            if (board[0][i] == 'X') return 1;\n            if (board[0][i] == 'O') return 2;\n        }\n    }\n\n    // check diagonals\n    if (board[0][0] == board[1][1] && board[1][1] == board[2][2]) {\n        if (board[0][0] == 'X') return 1;\n        if (board[0][0] == 'O') return 2;\n    }\n    if (board[0][2] == board[1][1] && board[1][1] == board[2][0]) {\n        if (board[0][2] == 'X') return 1;\n        if (board[0][2] == 'O') return 2;\n    }\n\n    return 0;  // no winner yet\n}\n", "test": "#include <assert.h>\nint main(){\n    char board1[3][3] = {\n        {'X', 'O', 'X'},\n        {' ', 'X', 'O'},\n        {' ', ' ', 'X'} };\n    assert(getTicTacToeWinner(board1) == 1);\n\n    char board2[3][3] = {\n        {'X', 'O', 'X'},\n        {' ', 'O', 'X'},\n        {'O', ' ', 'X'} };\n    assert(getTicTacToeWinner(board2) == 1);\n\n    char board3[3][3] = {\n        {'X', 'O', 'X'},\n        {' ', ' ', 'O'},\n        {' ', ' ', 'X'} };\n    assert(getTicTacToeWinner(board3) == 0);\n\n    char board4[3][3] = {\n        {'O', 'O', 'O'},\n        {' ', 'X', ' '},\n        {'X', ' ', 'X'} };\n    assert(getTicTacToeWinner(board4) == 2);\n\n    char board5[3][3] = {\n        {'X', ' ', ' '},\n        {'O', 'X', ' '},\n        {'O', 'O', 'X'} };\n    assert(getTicTacToeWinner(board5) == 1);\n\n    return 0;\n}\n"}
{"language": "c++", "domain": "game", "source": "gpt4+人工筛选；源文件地址/data/xw/c++dataset/game/already/321.cpp", "prompt": "#include<iostream>\n/*游戏实现：简单实现一个剪刀石头布游戏。\nint determineWinner(int playerInput,int computerInput)\nplayerInput代表玩家的出拳情况，1代表剪刀，2代表石头，3代表布\ncomputerInput代表电脑随机出的拳，1代表剪刀，2代表石头，3代表布\n返回值情况：如果玩家胜利，返回1，平局返回0，玩家失利返回-1\n*/\n", "solution": "int determineWinner(int playerInput, int computerInput){\n    if(playerInput==computerInput) {\n        return 0;\n    }\n    if((playerInput==1 && computerInput==2) || \n       (playerInput==2 && computerInput==3) || \n       (playerInput==3 && computerInput==1)) {\n        return -1;\n    } else {\n        return 1;\n    }\n}\n", "test": "#include<assert.h>\nint main() {\n    assert(determineWinner(1, 1)==0);\n    assert(determineWinner(2, 1)==1);\n    assert(determineWinner(3, 3)==0);\n    assert(determineWinner(1, 3)==1);\n    assert(determineWinner(3, 2)==1);\n    return 0;\n}\n"}
{"language": "c++", "domain": "game", "source": "gpt4+人工筛选；源文件地址/data/xw/c++dataset/game/already/189.cpp", "prompt": "#include <iostream>\n#include <vector>\n/* 判断井字棋游戏胜负\n// bool checkTicTacToe(const std::vector<std::vector<int>>& board)\nboard 表示棋盘上的棋子布局，0表示没下棋，1表示玩家键入，2表示电脑输入，\n返回值是布尔值，如果有人胜出，返回true，否则返回false。\n*/\n", "solution": "bool checkTicTacToe(const std::vector<std::vector<int>>& board) {\n    int n = board.size();\n    // 检查行和列\n    for (int i = 0; i < n; ++i) {\n        if (board[i][0]!=0 && board[i][0] == board[i][1] && board[i][0] == board[i][2])\n           return true;\n        if (board[0][i]!=0 && board[0][i] == board[1][i] && board[0][i] == board[2][i])\n           return true;\n    }\n    // 检查对角线\n    if (board[0][0]!=0 && board[0][0] == board[1][1] && board[0][0] == board[2][2])\n        return true;\n    if (board[0][2]!=0 && board[0][2] == board[1][1] && board[0][2] == board[2][0])\n        return true;\n    return false;\n}\n", "test": "#include<assert.h>\nint main() {\n    std::vector<std::vector<int>> board = {{0,0,0},{0,0,0},{0,0,0}};\n    assert(checkTicTacToe(board)==false);\n    board = {{1,1,1},{0,0,0},{0,0,0}};\n    assert(checkTicTacToe(board)==true);\n    board = {{2,0,1},{2,0,0},{2,0,0}};\n    assert(checkTicTacToe(board)==true);\n    board = {{1,2,0},{2,1,0},{0,0,1}};\n    assert(checkTicTacToe(board)==true);\n    board = {{0,2,1},{0,1,2},{1,0,0}};\n    assert(checkTicTacToe(board)==true);\n    return 0;\n}\n"}
{"language": "c++", "domain": "game", "source": "gpt4+人工筛选；源文件地址/data/xw/c++dataset/game/already/243.cpp", "prompt": "#include <iostream>\n#include <vector>\n#include <cassert>\n\nusing namespace std;\n\n/*实现一个判断井字游戏是否有人获胜的函数\n输入是一个3x3的字母矩阵，里面的元素只有'O'、'X'和' '三种可能，分别代表O方、X方和空位\n函数的格式定义为：char checkWin(vector<vector<char>>& board);\n返回一个char值，表示当前的胜利者，'O'表示O方胜利，'X'表示X方胜利，' '表示还没有人胜利\n*/\n", "solution": "\nchar checkWin(vector<vector<char>>& board) {\n    for (int i = 0; i < 3; i++) {\n        if (board[i][0] == board[i][1] && board[i][0] == board[i][2] && board[i][0] != ' ') {\n            return board[i][0];\n        }\n        if (board[0][i] == board[1][i] && board[0][i] == board[2][i] && board[0][i] != ' ') {\n            return board[0][i];\n        }\n    }\n    if (board[0][0] == board[1][1] && board[0][0] == board[2][2] && board[0][0] != ' ') {\n        return board[0][0];\n    }\n    if (board[0][2] == board[1][1] && board[0][2] == board[2][0] && board[0][2] != ' ') {\n        return board[0][2];\n    }\n    return ' ';\n}\n", "test": "int main() {\n    vector<vector<char>> board1{ {'O', 'X', 'O'},\n                                 {'X', 'O', 'X'},\n                                 {'O', ' ', 'X'}};\n    assert(checkWin(board1) == 'O');\n\n    vector<vector<char>> board2{ {'O', 'X', ' '},\n                                 {'X', 'O', 'X'},\n                                 {' ', ' ', 'X'}};\n    assert(checkWin(board2) == ' ');\n\n    vector<vector<char>> board3{ {'O', 'X', ' '},\n                                 {' ', 'O', ' '},\n                                 {'X', 'X', 'X'}};\n    assert(checkWin(board3) == 'X');\n\n    vector<vector<char>> board4{ {'X', 'X', 'O'},\n                                 {'X', 'O', 'X'},\n                                 {' ', 'X', ' '}};\n    assert(checkWin(board4) == ' ');\n\n    vector<vector<char>> board5{ {' ', ' ', ' '},\n                                 {' ', ' ', ' '},\n                                 {' ', ' ', ' '}};\n    assert(checkWin(board5) == ' ');\n\n    return 0;\n}\n"}
{"language": "c++", "domain": "game", "source": "gpt4+人工筛选；源文件地址/data/xw/c++dataset/game/already/336.cpp", "prompt": "#include <iostream>\n#include <vector>\n\nusing namespace std;\n\n/*实现一个简单的贪吃蛇游戏的函数\n函数定义为：int snakeGame(vector<pair<int,int>>& foodLocations, pair<int,int>& snakeStart, pair<int,int>& direction)\nfoodLocations是食物的坐标，snakeStart是蛇的初始位置，direction是蛇头的初始移动方向（可以是上、下、左、右，分别表示为（-1,0），（1,0），（0,-1），（0,1））\n每次移动，蛇会根据方向移动一步，如果遇到食物则吃掉并加1分，如果碰到边界或自己的身体则游戏结束\n返回最后的得分\n*/\n", "solution": "int snakeGame(vector<pair<int,int>>& foodLocations, pair<int,int> snakeStart, pair<int,int> direction){\n    vector<pair<int, int>> snakeBody;\n    snakeBody.push_back(snakeStart);\n    int score = 0;\n\n    while (true) {\n        pair<int,int> nextStep = make_pair(snakeBody[0].first + direction.first, snakeBody[0].second + direction.second);\n\n        // Check if the snake hits the boundary\n        if ((nextStep.first < 0) || (nextStep.first > 10) || (nextStep.second < 0) || (nextStep.second > 10)) {\n            return score;\n        }\n\n        // Check if the snake hits itself\n        for (auto it = snakeBody.begin(); it != snakeBody.end(); ++it) {\n            if ((it->first == nextStep.first) && (it->second == nextStep.second)) {\n                return score;\n            }\n        }\n\n        // Update snake's body\n        snakeBody.insert(snakeBody.begin(), nextStep);\n\n        // Check if the snake finds food\n        for (auto it = foodLocations.begin(); it != foodLocations.end(); ++it) {\n            if ((it->first == nextStep.first) && (it->second == nextStep.second)) {\n                ++score;\n                foodLocations.erase(it);\n                break;\n            }\n        }\n\n        // If the snake doesn't find food, remove the tail of the snake\n        if (score != (int)snakeBody.size() - 1) {\n            snakeBody.pop_back();\n        }\n\n        // Change direction randomly for simulation purposes\n        int randNr = rand() % 4;\n        if (randNr == 0) direction = make_pair(-1,0);\n        else if (randNr == 1) direction = make_pair(1,0);\n        else if (randNr == 2) direction = make_pair(0,-1);\n        else if (randNr == 3) direction = make_pair(0,1);\n    }\n    return score;\n}\n", "test": "#include<assert.h>\nint main() {\n    vector<pair<int,int>> foodLocations = {{1, 2}, {3, 4}, {5, 6}, {7, 8}, {9,10}};\n    pair<int,int> snakeStart = {0, 0};\n    pair<int,int> direction = {0, 1};\n\n    int score = snakeGame(foodLocations, snakeStart, direction);\n    assert(score<=5); // The max score can be 5 but because snake change its direction randomly maybe it can't eat all the food.\n\n    return 0;\n}\n"}
{"language": "c++", "domain": "game", "source": "gpt4+人工筛选；源文件地址/data/xw/c++dataset/game/already/game7.cpp", "prompt": "#include <iostream>\n#include <algorithm>\n\nusing namespace std;\n\n/*实现扑克牌小游戏的函数，计算四张扑克牌可以通过加减乘除得到24点的方法\n函数的格式定义为：bool pokerGame(int array[4])\narray 数组是玩家手中的四张扑克牌(1-13，代表扑克牌上的A到K)\n返回一个布尔值(thrue/false)，表示是否可以通过加减乘除得到24点\n*/\n", "solution": "bool pokerGame(int array[4]) {\n    sort(array, array + 4);\n    do {\n        for (int i = 0; i < 64; ++i) {\n            int num[3] = { i % 4, i / 4 % 4, i / 16 };\n            double result = array[0];\n            for (int j = 0; j < 3; ++j) {\n                if (num[j] == 0) result += array[j + 1];\n                else if (num[j] == 1) result -= array[j + 1];\n                else if (num[j] == 2) result *= array[j + 1];\n                else if (num[j] == 3) result /= array[j + 1];\n            }\n            if (abs(result - 24) < 1e-6) {\n                return true;\n            }\n        }\n    } while (next_permutation(array, array + 4));\n    return false;\n}\n", "test": "#include<assert.h>\nint main() {\n    int array1[4] = {1,6,7,10};\n    int array2[4] = {1,4,5,2};\n    int array3[4] = {1,2,3,4};\n    int array4[4] = {10,10,2,2};\n\n    assert(pokerGame(array1)==true);\n    assert(pokerGame(array2)==true);\n    assert(pokerGame(array3)==true);\n    assert(pokerGame(array4)==true);\n\n    return 0;\n}\n"}
{"language": "c++", "domain": "game", "source": "gpt4+人工筛选；源文件地址/data/xw/c++dataset/game/already/game1.cpp", "prompt": "#include <iostream>\n#include <cstdlib>\n#include <ctime>\n\nusing namespace std;\n\n/*实现扑克牌抽卡游戏的函数\n两个玩家，每个人随机抽一张卡，分别是1-52的数（1表示黑桃A，52表示红桃K）\n函数的定义：int cardGame();\n不需要输入参数\n返回一个表示游戏结果的数字（0表示平局，1表示玩家1赢，2表示玩家2赢）\n*/\n", "solution": "int cardGame() {\n    srand(time(NULL));\n    int player1Choice = rand() % 52 + 1;\n    int player2Choice = rand() % 52 + 1;\n    if (player1Choice == player2Choice) {\n        return 0; \n    } else if (player1Choice > player2Choice) {\n        return 1; \n    } else {\n        return 2; \n    }\n}\n", "test": "#include<assert.h>\nint main() {\n    int result = cardGame();\n    assert(result >= 0 && result <= 2);\n    // Due to the randomness of the game, we can only guarantee the result is within the expected range.                \n    return 0;\n}\n"}
{"language": "c++", "domain": "game", "source": "gpt4+人工筛选；源文件地址/data/xw/c++dataset/game/already/231.cpp", "prompt": "#include <stdio.h>\n/* \n实现初始化棋盘函数\nvoid initBoard(int board[3][3])\nboard是一个3*3的数组，代表一个井字棋盘。其中0代表为空，1代表为玩家1的棋子，2代表为玩家2的棋子。\n函数的功能是将棋盘初始化，全部清零。\n*/\n", "solution": "void initBoard(int board[3][3]) {\n    for(int i=0;i<3;i++){\n        for(int j=0;j<3;j++){\n            board[i][j] = 0;\n        }\n    }\n}\n", "test": "#include <assert.h>\nint main(){\n    int board1[3][3] = {{1,2,0},{2,1,0},{0,0,0}};\n    initBoard(board1);\n    for(int i=0;i<3;i++){\n        for(int j=0;j<3;j++){\n            assert(board1[i][j]==0);\n        }\n    }\n\n    int board2[3][3] = {{1,1,1},{2,2,2},{1,1,1}};\n    initBoard(board2);\n    for(int i=0;i<3;i++){\n        for(int j=0;j<3;j++){\n            assert(board2[i][j]==0);\n        }\n    }\n\n    int board3[3][3] = {{2,2,2},{1,1,1},{2,2,2}};\n    initBoard(board3);\n    for(int i=0;i<3;i++){\n        for(int j=0;j<3;j++){\n            assert(board3[i][j]==0);\n        }\n    }\n\n    int board4[3][3] = {{0,0,0},{0,0,0},{0,0,0}};\n    initBoard(board4);\n    for(int i=0;i<3;i++){\n        for(int j=0;j<3;j++){\n            assert(board4[i][j]==0);\n        }\n    }\n\n    int board5[3][3] = {{1,0,2},{2,0,1},{1,2,0}};\n    initBoard(board5);\n    for(int i=0;i<3;i++){\n        for(int j=0;j<3;j++){\n            assert(board5[i][j]==0);\n        }\n    }\n\n    return 0;\n}\n"}
{"language": "c++", "domain": "game", "source": "gpt4+人工筛选；源文件地址/data/xw/c++dataset/game/already/366.cpp", "prompt": "#include <iostream>\n/*判断井字棋游戏的胜负\nchar checkWinningCondition(char board[3][3])\n传入一个3x3的井字棋盘，返回赢家。'X'表示玩家'X'赢，'O'表示玩家'O'赢，'D'代表平局，'N'则代表游戏未结束\n每个位置的值要么为'X'，要么为'O'，要么为空' '\n*/\n", "solution": "char checkWinningCondition(char board[3][3]) {\n    for (int i = 0; i < 3; ++i) {\n        if (board[i][0] != ' ' && board[i][0] == board[i][1] && board[i][1] == board[i][2])\n            return board[i][0];\n        if (board[0][i] != ' ' && board[0][i] == board[1][i] && board[1][i] == board[2][i])\n            return board[0][i];\n    }\n    if (board[0][0] != ' ' && board[0][0] == board[1][1] && board[1][1] == board[2][2])\n        return board[0][0];\n    if (board[0][2] != ' ' && board[0][2] == board[1][1] && board[1][1] == board[2][0])\n        return board[0][2];\n    for (int i = 0; i < 3; ++i)\n        for (int j = 0; j < 3; ++j)\n            if (board[i][j] == ' ')\n                return 'N';\n    return 'D';\n}\n", "test": "#include<assert.h>\nint main() {\n    char board1[3][3] = {{'X', 'X', 'X'}, {' ', 'O', ' '}, {'O', 'X', 'O'}};\n    assert(checkWinningCondition(board1) == 'X');\n    char board2[3][3] = {{'O', 'O', 'X'}, {'X', 'O', ' '}, {'X', 'X', ' '}};\n    assert(checkWinningCondition(board2) == 'N');\n    char board3[3][3] = {{'O', 'X', 'O'}, {'O', 'X', 'X'}, {'X', 'O', 'X'}};\n    assert(checkWinningCondition(board3) == 'D');\n    char board4[3][3] = {{' ', ' ', ' '}, {' ', ' ', ' '}, {' ', ' ', ' '}};\n    assert(checkWinningCondition(board4) == 'N');\n    char board5[3][3] = {{'X', 'O', 'O'}, {'O', 'X', 'X'}, {' ', 'O', 'X'}};\n    assert(checkWinningCondition(board5) == 'X');\n    return 0;\n}\n"}
{"language": "c++", "domain": "game", "source": "gpt4+人工筛选；源文件地址/data/xw/c++dataset/game/already/192.cpp", "prompt": "#include <iostream>\n#include <vector>\n/*\n以井字棋（Tic-tac-toe）为例，设计一个函数\nbool checkWinGame(const std::vector<std::vector<int>> &board)\n该函数的输入为一个3x3的整数矩阵，0代表空格，1代表玩家1所下的棋，2代表玩家2所下的棋\n如果玩家1或玩家2的棋子在行、列、对角线形成连城一线，那么该玩家获胜，函数返回true, 否则返回false\n*/\n", "solution": "bool checkWinGame(const std::vector<std::vector<int>> &board) {\n    for(int i=0; i<3; ++i){\n        if(board[i][0] == board[i][1] && board[i][1] == board[i][2] && board[i][0] != 0) return true;\n        if(board[0][i] == board[1][i] && board[1][i] == board[2][i] && board[0][i] != 0) return true;\n    }\n    if(board[0][0] == board[1][1] && board[1][1] == board[2][2] && board[0][0] != 0) return true;\n    if(board[2][0] == board[1][1] && board[1][1] == board[0][2] && board[2][0] != 0) return true;\n    return false;\n}\n", "test": "#include<assert.h>\nint main() {\n    std::vector<std::vector<int>> board1 = {{1, 2, 1}, {0, 1, 0}, {2, 0, 0}};\n    assert(checkWinGame(board1)==false);\n\n    std::vector<std::vector<int>> board2 = {{1, 1, 1}, {2, 0, 2}, {2, 1, 0}};\n    assert(checkWinGame(board2)==true);\n\n    std::vector<std::vector<int>> board3 = {{2, 1, 2}, {2, 1, 0}, {2, 0, 1}};\n    assert(checkWinGame(board3)==true);\n\n    std::vector<std::vector<int>> board4 = {{1, 2, 1}, {2, 1, 2}, {1, 1, 2}};\n    assert(checkWinGame(board4)==true);\n\n    std::vector<std::vector<int>> board5 = {{1, 2, 0}, {2, 0, 2}, {1, 0, 1}};\n    assert(checkWinGame(board5)==false);\n\n    return 0;\n}\n"}
{"language": "c++", "domain": "game", "source": "gpt4+人工筛选；源文件地址/data/xw/c++dataset/game/already/123.cpp", "prompt": "#include <iostream>\n#include <vector>\n/* 获取井字游戏的状态\nint ticTacToeResult(const std::vector<std::vector<int>>& board)\n传入的board是一个3x3的二维矢量，表示的是一个进行中的井字棋游戏的棋盘。\n空格被编码为 0，X玩家的棋子被编码为 1，O玩家的棋子被编码为2。\n如果X玩家赢了，返回 1，如果O玩家赢了，返回 2，如果游戏还没有结束，返回 0，如果是平局，返回 3。\n*/\n", "solution": "int ticTacToeResult(const std::vector<std::vector<int>>& board) {\n    for(int i = 0; i < 3; i++) {\n        if(board[i][0] == board[i][1] && board[i][1] == board[i][2] && board[i][0]) {\n            return board[i][0];\n        }\n        if(board[0][i] == board[1][i] && board[1][i] == board[2][i] && board[0][i]) {\n            return board[0][i];\n        }\n    }\n    if(board[0][0] == board[1][1] && board[1][1] == board[2][2] && board[0][0]) {\n        return board[0][0];\n    }\n    if(board[0][2] == board[1][1] && board[1][1] == board[2][0] && board[0][2]) {\n        return board[0][2];\n    }\n\n    for(int i = 0; i < 3; i++) {\n        for(int j = 0; j < 3; j++) {\n            if(board[i][j] == 0) {\n                return 0;\n            }\n        }\n    }\n    return 3;\n}\n", "test": "#include<assert.h>\nint main() {\n    assert(ticTacToeResult({{1,1,1},{0,2,0},{0,2,0}})==1);\n    assert(ticTacToeResult({{2,0,1},{2,1,0},{2,1,1}})==2);\n    assert(ticTacToeResult({{1,2,0},{2,1,0},{0,0,0}})==0);\n    assert(ticTacToeResult({{1,2,2},{2,1,0},{1,1,1}})==1);\n    return 0;\n}\n"}
{"language": "c++", "domain": "game", "source": "gpt4+人工筛选；源文件地址/data/xw/c++dataset/game/already/249.cpp", "prompt": "#include <iostream>\n#include <algorithm>\n\nusing namespace std;\n\n/*实现一个双人棋盘游戏的胜负判断函数。\n规则：拥有连续三个棋子的一方胜利，并且在一个二维平面上，连续棋子必须形成一条直线。\n函数的格式定义为：string judgeGame(char board[3][3])\nboard 是一个3*3的二维数组，代表棋盘，\"X\" 代表第一个玩家的棋子，\"O\" 代表第二个玩家的棋子, 未下棋的位置为 \" \".\n函数返回一个字符串：\"X\" 表示第一个玩家赢，\"O\" 表示第二个玩家赢，\" \" 表示平局，\"Undecided\" 表示游戏尚未结束。\n*/\n", "solution": "string judgeGame(char board[3][3]) {\n    //行和列检查\n    for (int i = 0; i < 3; ++i) {\n        if (board[i][0] == board[i][1] && board[i][1] == board[i][2]) {\n            if(board[i][0]!=' ')\n                return string(1,board[i][0]);\n        }\n        if (board[0][i] == board[1][i] && board[1][i] == board[2][i]) {\n            if(board[0][i]!=' ')\n                return string(1,board[0][i]);\n        }\n    }\n    //对角线检查\n    if (board[0][0] == board[1][1] && board[1][1] == board[2][2]) {\n        if(board[0][0]!=' ')\n            return string(1,board[0][0]);\n    }\n    if (board[0][2] == board[1][1] && board[1][1] == board[2][0]) {\n        if(board[0][2]!=' ')\n            return string(1,board[0][2]);\n    }\n    // 检查游戏是否平局或者尚未结束\n    bool full = true;\n    for(int i=0;i<3;++i){\n        for(int j=0;j<3;++j){\n            if(board[i][j] == ' '){\n                full = false;\n            }\n        }\n    }\n    if(full){\n        return \" \";\n    }else{\n        return \"Undecided\";\n    }\n}\n", "test": "#include<assert.h>\nint main() {\n    char board1[3][3] = {{'X','O','X'},{'O','X','O'},{' ',' ','X'}};\n    char board2[3][3] = {{'X','X','O'},{'O','O','X'},{'X','O','X'}};\n    char board3[3][3] = {{'O','X','O'},{' ','O','X'},{'X','O',' '}};\n    char board4[3][3] = {{'X','O','X'},{'O','X','O'},{'O','X','O'}};\n    char board5[3][3] = {{' ','O',' '},{' ',' ',' '},{' ',' ',' '}};\n\n    assert(judgeGame(board1)==\"X\");\n    assert(judgeGame(board2)==\" \");\n    assert(judgeGame(board3)==\"Undecided\");\n    assert(judgeGame(board4)==\" \");\n    assert(judgeGame(board5)==\"Undecided\");\n\n    return 0;\n}\n"}
{"language": "c++", "domain": "game", "source": "gpt4+人工筛选；源文件地址/data/xw/c++dataset/game/already/201.cpp", "prompt": "#include <iostream>\n\nusing namespace std;\n\n/* 实现一个简单的猜数字游戏函数\n函数格式定义为：int guessNumber(int target)\ntarget为目标数字，介于0和100之间。\n函数返回猜的次数。\n如果猜到正确的数字，则返回猜的次数，如果没有猜到则继续猜，直到猜到为止。\n每次猜测都取目标数字中间值进行。\n*/\n", "solution": "int guessNumber(int target) {\n    int left = 0, right = 100, mid;\n    int count = 0;\n    while (left <= right) {\n        mid = left + (right - left) / 2;\n        if (mid == target) {\n            break;\n        } else if (mid < target) {\n            left = mid + 1;\n        } else {\n            right = mid - 1;\n        }\n        count++;\n    }\n    return count;\n}\n", "test": "#include<assert.h>\nint main() {\n    assert(guessNumber(50) == 0);\n    assert(guessNumber(23) == 6);\n    assert(guessNumber(75) == 1);\n    assert(guessNumber(100) == 6);\n    assert(guessNumber(0) == 5);\n\n    return 0;\n}\n"}
{"language": "c++", "domain": "game", "source": "gpt4+人工筛选；源文件地址/data/xw/c++dataset/game/already/330.cpp", "prompt": "#include <iostream>\n#include <vector>\n\nusing namespace std;\n\n/* \n实现一个简单的2048游戏的移动逻辑，在此游戏中，玩家需要通过上下左右滑动将数字堆积在一起，当有两个相同的数字碰撞时，它们会合并成它们的和。\n例如，如果我们有一个1*4的网格，有两个2，当我们向左滑动时，这两个2会合并成一个4.\n我们需要主要实现的函数是2048游戏的向左滑动的逻辑，名称为moveLeft。\n*/\n", "solution": "\nvector<int> moveLeft(vector<int>& grid) {\n    vector<int> new_grid(4, 0);\n    for (int i = 0, j = 0; i < 4; ++i) {\n        if (grid[i] == 0)\n            continue;\n        if (j > 0 && grid[i] == new_grid[j-1])\n            new_grid[j-1] *= 2;\n        else\n            new_grid[j++] = grid[i];\n    }\n    return new_grid;\n}\n", "test": "#include<assert.h>\n\nint main() {\n    vector<int> test1 = {0, 0, 2, 2};\n    vector<int> res1 = {4, 0, 0, 0};\n    vector<int> test2 = {2, 2, 2, 2};\n    vector<int> res2 = {4, 4, 0, 0};\n    vector<int> test3 = {2, 0, 2, 0};\n    vector<int> res3 = {4, 0, 0, 0};\n    vector<int> test4 = {0, 2, 0, 2};\n    vector<int> res4 = {4, 0, 0, 0};\n    vector<int> test5 = {2, 2, 0, 0};\n    vector<int> res5 = {4, 0, 0, 0};\n\n    assert(moveLeft(test1) == res1);\n    assert(moveLeft(test2) == res2);\n    assert(moveLeft(test3) == res3);\n    assert(moveLeft(test4) == res4);\n    assert(moveLeft(test5) == res5);\n\n    return 0;\n}\n"}
{"language": "c++", "domain": "game", "source": "gpt4+人工筛选；源文件地址/data/xw/c++dataset/game/already/game8.cpp", "prompt": "#include <iostream>\n\nusing namespace std;\n\n/*实现五子棋游戏的函数\n（5*5的矩阵，0表示空，1表示玩家1，2表示玩家2）\n函数的格式定义为：int GobangGame(int[5][5] board)\nboard是一个5*5的矩阵，代表棋盘上的棋子状况\n返回一个表示游戏结果的数字（0表示没有决出胜者，1表示玩家1赢，2表示玩家2赢）\n*/\n", "solution": "int GobangGame(int board[5][5]) {\n    for(int i=0; i<=4; i++){\n        for(int j=0; j<=4; j++){\n            if(j + 4 <= 4){\n                if (board[i][j] == board[i][j+1] && \n                    board[i][j+1] == board[i][j+2] && \n                    board[i][j+2] == board[i][j+3] &&\n                    board[i][j+3] == board[i][j+4] && \n                    board[i][j] != 0){\n                        return board[i][j];\n                    }\n            }\n            if(i + 4 <= 4){\n                if (board[i][j] == board[i+1][j] && \n                    board[i+1][j] == board[i+2][j] && \n                    board[i+2][j] == board[i+3][j] &&\n                    board[i+3][j] == board[i+4][j] && \n                    board[i][j] != 0){\n                        return board[i][j];\n                    }\n            }\n            if(i + 4 <= 4 && j + 4 <= 4){\n                if (board[i][j] == board[i+1][j+1] && \n                    board[i+1][j+1] == board[i+2][j+2] && \n                    board[i+2][j+2] == board[i+3][j+3] &&\n                    board[i+3][j+3] == board[i+4][j+4] && \n                    board[i][j] != 0){\n                        return board[i][j];\n                    }\n            }\n        }\n    }\n    return 0;\n}\n", "test": "#include<assert.h>\nint main() {\n    int board1[5][5] = { {1, 0, 0, 0, 0},\n                         {0, 1, 0, 0, 0},\n                         {0, 0, 1, 0, 0},\n                         {0, 0, 0, 1, 0},\n                         {0, 0, 0, 0, 1} };\n    \n    int board2[5][5] = { {0, 0, 0, 0, 0},\n                         {1, 1, 1, 1, 1},\n                         {0, 0, 0, 0, 0},\n                         {0, 0, 0, 0, 0},\n                         {0, 0, 0, 0, 0} };\n    \n    int board3[5][5] = { {0, 0, 2, 0, 0},\n                         {0, 1, 2, 1, 1},\n                         {0, 0, 2, 2, 0},\n                         {0, 0, 2, 0, 2},\n                         {0, 0, 2, 0, 0} };\n    \n    int board4[5][5] = { {0, 0, 0, 0, 0},\n                         {0, 1, 2, 1, 1},\n                         {0, 0, 2, 2, 0},\n                         {0, 0, 0, 0, 2},\n                         {0, 0, 0, 0, 0} };\n\n    assert(GobangGame(board1)==1);\n    assert(GobangGame(board2)==1);\n    assert(GobangGame(board3)==2);\n    assert(GobangGame(board4)==0);\n\n    return 0;\n}\n"}
{"language": "c++", "domain": "game", "source": "gpt4+人工筛选；源文件地址/data/xw/c++dataset/game/already/174.cpp", "prompt": "#include <stdio.h>\n#include <stdlib.h>\n#define N 3\n/*\n实现井字棋的赢局判定，判定9宫格中是否存在有三个格子在同一行、同一列或者同一对角线上且都为同一玩家的棋子，是的话就返回用户对应的用户编号\n函数的格式定义为：int ticTacToeWinCheck(char board[N][N])\n其中，board用来存储井字棋的棋盘状态，'X'和'O'分别代表两个玩家，' '代表还未落子的格子，函数返回值为1表示'X'玩家胜，返回值为2表示'O'玩家胜，0表示还没有玩家胜出\n*/\n", "solution": "int ticTacToeWinCheck(char board[N][N]) {\n    int i, j;\n    for (i = 0; i < N; i++) {\n        if (board[i][0] != ' ' && board[i][0] == board[i][1] && board[i][1] == board[i][2]) {\n            if(board[i][0] == 'X')\n                return 1;\n            else\n                return 2;\n        }\n    }\n    for (j = 0; j < N; j++) {\n        if (board[0][j] != ' ' && board[0][j] == board[1][j] && board[1][j] == board[2][j]) {\n            if(board[0][j] == 'X')\n                return 1;\n            else\n                return 2;\n        }\n    }\n    if (board[0][0] != ' ' && board[0][0] == board[1][1] && board[1][1] == board[2][2]) {\n        if(board[0][0] == 'X')\n            return 1;\n        else\n            return 2;\n    }\n    if (board[0][2] != ' ' && board[0][2] == board[1][1] && board[1][1] == board[2][0]) {\n        if(board[0][2] == 'X')\n            return 1;\n        else\n            return 2;\n    }\n    return 0;\n}\n", "test": "{\n    // test case 1:\n    char board1[N][N] = {\n        {'X', 'X', 'X'},\n        {'O', ' ', ' '},\n        {'O', ' ', ' '}\n    };\n    assert(ticTacToeWinCheck(board1) == 1);\n\n    // test case 2:\n    char board2[N][N] = {\n        {'O', 'X', 'O'},\n        {'X', 'O', ' '},\n        {'X', ' ', 'X'}\n    };\n    assert(ticTacToeWinCheck(board2) == 0);\n\n    // test case 3:\n    char board3[N][N] = {\n        {'X', ' ', ' '},\n        {'O', 'X', ' '},\n        {'O', ' ', 'X'}\n    };\n    assert(ticTacToeWinCheck(board3) == 1);\n\n    // test case 4:\n    char board4[N][N] = {\n        {'X', 'O', 'X'},\n        {'O', 'O', 'X'},\n        {'O', 'X', 'O'}\n    };\n    assert(ticTacToeWinCheck(board4) == 0);\n\n    // test case 5:\n    char board5[N][N] = {\n        {' ', ' ', ' '},\n        {' ', ' ', ' '},\n        {' ', ' ', ' '}\n    };\n    assert(ticTacToeWinCheck(board5) == 0);\n}\n"}
{"language": "c++", "domain": "game", "source": "gpt4+人工筛选；源文件地址/data/xw/c++dataset/game/already/129.cpp", "prompt": "#include <iostream>\n#include <vector>\n/*\n检查四子棋中是否有人获胜\nbool checkWin(std::vector<std::vector<char>>& board)\nboard 是一个二维字符矩阵，代表棋盘，其中 'X' 代表玩家 X 的棋，'O' 代表玩家 O 的棋，' ' 代表空位。\n如果其中一个玩家在任何方向（水平、垂直、对角）上有连续的四个棋子，则该玩家赢，函数返回 true ，否则返回 false。\n*/\n", "solution": "bool checkWin(std::vector<std::vector<char>>& board) {\n    int n = board.size();\n    int m = board[0].size();\n    for(int i = 0; i < n; i++) {\n        for(int j = 0; j < m; j++) {\n            if(board[i][j] == ' ')\n                continue;\n            if(j+3<m && board[i][j]==board[i][j+1] && board[i][j]==board[i][j+2] && board[i][j]==board[i][j+3])\n                return true;\n            if(i+3<n && board[i][j]==board[i+1][j] && board[i][j]==board[i+2][j] && board[i][j]==board[i+3][j])\n                return true;\n            if(j+3<m && i+3<n && board[i][j]==board[i+1][j+1] && board[i][j]==board[i+2][j+2] && board[i][j]==board[i+3][j+3])\n                return true;\n            if(j>2 && i+3<n && board[i][j]==board[i+1][j-1] && board[i][j]==board[i+2][j-2] && board[i][j]==board[i+3][j-3])\n                return true;\n        }\n    }\n    return false;\n}\n", "test": "#include<assert.h>\nint main() {\n    std::vector<std::vector<char>> board1 = {\n        {' ',' ',' ',' ',' '},\n        {' ',' ',' ',' ',' '},\n        {' ',' ','X',' ',' '},\n        {' ','X','O',' ',' '},\n        {'X','O','O',' ','X'}\n    };\n    std::vector<std::vector<char>> board2 = {\n        {' ',' ',' ',' ',' '},\n        {' ',' ',' ',' ',' '},\n        {' ',' ','O','O',' '},\n        {' ','O','O','O','O'},\n        {'X','X','X','O','X'}\n    };\n    std::vector<std::vector<char>> board3 = {\n        {'O',' ',' ',' ',' '},\n        {' ','O',' ',' ',' '},\n        {' ',' ','O',' ',' '},\n        {' ',' ',' ','O',' '},\n        {' ',' ',' ',' ',' '}\n    };\n    assert(checkWin(board1)==false);\n    assert(checkWin(board2)==true);\n    assert(checkWin(board3)==true);\n    return 0;\n}\n"}
{"language": "c++", "domain": "game", "source": "gpt4+人工筛选；源文件地址/data/xw/c++dataset/game/already/351.cpp", "prompt": "#include <stdio.h>\n#include <stdlib.h>\n\n/* \n移动2D游戏的角色。传入当前角色的x，y坐标，需要移动的dx和dy。返回更新后的x和y坐标。\n\n函数定义为：void move_character(int* x, int* y, int dx, int dy)\n其中，x和y是角色当前坐标，dx和dy是需要移动的距离。\n*/\n", "solution": "void move_character(int* x, int* y, int dx, int dy) {\n    *x += dx;\n    *y += dy;\n}\n", "test": "#include <assert.h>\nint main() {\n    int x = 5, y = 6;\n    move_character(&x, &y, 1, -2);\n    assert(x == 6 && y == 4);\n\n    x = -1, y = 0;\n    move_character(&x, &y, -2, 3);\n    assert(x == -3 && y == 3);\n\n    x = 0, y = 0;\n    move_character(&x, &y, 0, 0);\n    assert(x == 0 && y == 0);\n\n    x = 10, y = 10;\n    move_character(&x, &y, -10, -10);\n    assert(x == 0 && y == 0);\n\n    x = 100, y = 200;\n    move_character(&x, &y, -50, 50);\n    assert(x == 50 && y == 250);\n}\n"}
{"language": "c++", "domain": "game", "source": "gpt4+人工筛选；源文件地址/data/xw/c++dataset/game/already/303.cpp", "prompt": "#include <iostream>\n#include <vector>\n#include <cassert>\n\nusing namespace std;\n\n/* 判定井字棋的胜者\nchar judge_tic_tac_toe_winner(vector<vector<char>> board)\n board是一个3x3的字符数组，其中'X'代表玩家1，'O'代表玩家2，空格代表尚未落子。\n 该函数的功能是判断当前的棋局是否已经有玩家胜出，如有，返回胜方的字符('X'或者'O')，否则返回' '。\n */\n", "solution": "char judge_tic_tac_toe_winner(vector<vector<char>> board) \n{\n    for(int i = 0; i < 3; i++)\n    {\n        if(board[i][0] != ' ' && board[i][0] == board[i][1] && board[i][0] == board[i][2])\n            return board[i][0];\n        if(board[0][i] != ' ' && board[0][i] == board[1][i] && board[0][i] == board[2][i])\n            return board[0][i];\n    }\n\n    if(board[0][0] != ' ' && board[0][0] == board[1][1] && board[0][0] == board[2][2])\n            return board[0][0];\n    if(board[2][0] != ' ' && board[2][0] == board[1][1] && board[2][0] == board[0][2])\n            return board[2][0];\n\n    return ' ';\n}\n", "test": "int main() \n{\n    vector<vector<char>> board1 ={\n        {'X', ' ', 'O'},\n        {' ', 'X', 'O'},\n        {' ', ' ', 'X'},\n    };\n    assert(judge_tic_tac_toe_winner(board1) == 'X');\n\n    vector<vector<char>> board2 ={\n        {'O', 'X', 'X'},\n        {'X', 'O', 'X'},\n        {'X', ' ', 'O'},\n    };\n    assert(judge_tic_tac_toe_winner(board2) == 'O');\n\n    vector<vector<char>> board3 ={\n        {'X', 'O', 'X'},\n        {'O', ' ', 'O'},\n        {'X', 'O', 'O'},\n    };\n    assert(judge_tic_tac_toe_winner(board3) == ' ');\n\n    vector<vector<char>> board4 ={\n        {'O', 'O', 'X'},\n        {'X', 'X', 'O'},\n        {'O', 'X', 'X'},\n    };\n    assert(judge_tic_tac_toe_winner(board4) == ' ');\n\n    vector<vector<char>> board5 ={\n        {' ', ' ', ' '},\n        {' ', ' ', ' '},\n        {' ', ' ', ' '},\n    };\n    assert(judge_tic_tac_toe_winner(board5) == ' ');\n\n    return 0;\n}\n"}
{"language": "c++", "domain": "game", "source": "gpt4+人工筛选；源文件地址/data/xw/c++dataset/game/already/327.cpp", "prompt": "#include <vector>\n/*\n如果棋盘满了或某人连成一行,则游戏结束\nbool isGameOver(const vector<vector<int> >& board)\nboard棋盘,9个位置用0，1，2表示, 0表示空，1表示为player1棋子,2表示player2棋子。如果棋盘满了或某人连成一行，则返回true,反之则返回false。\n*/\n", "solution": "bool isGameOver(std::vector<std::vector<int> > &board) {\n    // 检查行\n    for(int i = 0; i < 3; ++i) {\n        if(board[i][0] == board[i][1] && board[i][1] == board[i][2] && board[i][0] != 0) {\n            return true;\n        }\n    }\n    \n    // 检查列\n    for(int i = 0; i < 3; ++i) {\n        if(board[0][i] == board[1][i] && board[1][i] == board[2][i] && board[0][i] != 0) {\n            return true;\n        }\n    }\n     \n    // 检查对角线\n    if(board[0][0] == board[1][1] && board[1][1] == board[2][2] && board[0][0] != 0) {\n        return true;\n    }\n    if(board[0][2] == board[1][1] && board[1][1] == board[2][0] && board[0][2] != 0) {\n        return true;\n    }\n    \n    // 检查棋盘是否已满，如果满了，返回true，游戏结束\n    for(int i = 0; i < 3; ++i) {\n        for(int j = 0; j < 3; ++j) {\n            if(board[i][j] == 0) {\n                return false;\n            }\n        }\n    }\n    return true;\n}\n", "test": "#include<assert.h>\nint main() {\n    std::vector<std::vector<int> > board1 { {1,1,1}, {2,0,2}, {2,1,2} };\n    std::vector<std::vector<int> > board2 { {2,1,2}, {1,2,1}, {2,1,2} };\n    std::vector<std::vector<int> > board3 { {1,2,1}, {2,1,2}, {2,1,2} };\n    std::vector<std::vector<int> > board4 { {1,2,1}, {1,2,2}, {1,1,2} };\n    std::vector<std::vector<int> > board5 { {1,0,1}, {0,1,0}, {2,1,2} };\n    assert(isGameOver(board1)==true);\n    assert(isGameOver(board2)==true);\n    assert(isGameOver(board3)==true);\n    assert(isGameOver(board4)==true);\n    assert(isGameOver(board5)==false);\n    return 0;\n}\n"}
{"language": "c++", "domain": "game", "source": "gpt4+人工筛选；源文件地址/data/xw/c++dataset/game/already/276.cpp", "prompt": "#include<iostream>\n#include<vector>\n#include<assert.h>\n/*判定井字游戏胜负\nbool GameOver(std::vector<std::vector<char>>& board)\n输入：3x3的字符向量，空位为' ', 'X'为玩家一，'O'为玩家二\n输出：如果任何玩家赢得游戏，或者全部填满则返回true，否则返回false\n*/\n", "solution": "bool GameOver(std::vector<std::vector<char>>& board) {\n    // 校验行\n    for(int i = 0; i < 3; ++i) {\n        if(board[i][0] != ' ' && board[i][0] == board[i][1] && board[i][0] == board[i][2]) {\n            return true;\n        }\n    }\n    // 校验列\n    for(int i = 0; i < 3; ++i) {\n        if(board[0][i] != ' ' && board[0][i] == board[1][i] && board[0][i] == board[2][i]) {\n            return true;\n        }\n    }\n    // 校验对角线\n    if(board[0][0] != ' ' && board[0][0] == board[1][1] && board[0][0] == board[2][2]) {\n        return true;\n    }\n    if(board[0][2] != ' ' && board[0][2] == board[1][1] && board[0][2] == board[2][0]) {\n        return true;\n    }\n    // 校验是否全部填满\n    for(int i = 0; i < 3; ++i) {\n        for(int j = 0; j < 3; ++j) {\n            if(board[i][j] == ' ') {\n                return false;\n            }\n        }\n    }\n    return true;\n}\n", "test": "int main() {\n    std::vector<std::vector<char>> test1 = {{'X', 'X', 'X'}, {'O', 'O', ' '}, {' ', ' ', ' '}};\n    assert(GameOver(test1) == true); // 玩家一赢\n    std::vector<std::vector<char>> test2 = {{'X', 'O', ' '}, {'X', 'O', ' '}, {'X', ' ', 'O'}};\n    assert(GameOver(test2) == true); // 玩家一赢\n    std::vector<std::vector<char>> test3 = {{' ', 'O', 'X'}, {' ', 'O', 'X'}, {'O', ' ', 'X'}};\n    assert(GameOver(test3) == true); // 玩家二赢\n    std::vector<std::vector<char>> test4 = {{'X', 'O', ' '}, {'O', 'X', ' '}, {' ', ' ', 'O'}};\n    assert(GameOver(test4) == false); // 玩家二赢\n    std::vector<std::vector<char>> test5 = {{'X', 'O', 'X'}, {'X', 'X', 'O'}, {'O', 'X', 'O'}};\n    assert(GameOver(test5) == true); // 平局 \n    return 0;\n}\n"}
{"language": "c++", "domain": "game", "source": "gpt4+人工筛选；源文件地址/data/xw/c++dataset/game/already/171.cpp", "prompt": "#include <iostream>\n#include <vector>\n#include <assert.h>\n\n/*\n判断井字棋的胜利者\nchar check_tic_tac_toe_winner(const std::vector<std::vector<char> >& board)\nboard是一个3x3的字符矩阵，表示井字棋的棋盘，'X'表示玩家X，'O'表示玩家O，'_'表示未下子的位置。返回胜利者的字符\n*/\n", "solution": "char check_tic_tac_toe_winner(const std::vector<std::vector<char> >& board) {\n    for (int i = 0; i < 3; i++) {\n        if (board[i][0] != '_' && board[i][0] == board[i][1] && board[i][0] == board[i][2]) {\n            return board[i][0];\n        }\n        if (board[0][i] != '_' && board[0][i] == board[1][i] && board[0][i] == board[2][i]) {\n            return board[0][i];\n        }\n    }\n    if (board[0][0] != '_' && board[0][0] == board[1][1] && board[0][0] == board[2][2]) {\n        return board[0][0];\n    }\n    if (board[0][2] != '_' && board[0][2] == board[1][1] && board[0][2] == board[2][0]) {\n        return board[0][2];\n    }\n    return '_';\n}\n", "test": "int main() {\n    std::vector<std::vector<char> > board1{\n        {'O', 'X', 'X'},\n        {'_', 'O', 'X'},\n        {'_', '_', 'O'}\n    };\n    assert(check_tic_tac_toe_winner(board1) == 'O');\n\n    std::vector<std::vector<char> > board2{\n        {'O', 'X', 'X'},\n        {'O', 'O', 'X'},\n        {'O', '_', '_'}\n    };\n    assert(check_tic_tac_toe_winner(board2) == 'O');\n\n    std::vector<std::vector<char> > board3{\n        {'O', 'X', 'X'},\n        {'_', 'O', 'X'},\n        {'X', '_', 'O'}\n    };\n    assert(check_tic_tac_toe_winner(board3) == 'O');\n\n    std::vector<std::vector<char> > board4{\n        {'O', 'X', 'X'},\n        {'O', 'X', 'X'},\n        {'_', '_', '_'}\n    };\n    assert(check_tic_tac_toe_winner(board4) == '_');\n\n    std::vector<std::vector<char> > board5{\n        {'O', 'X', 'O'},\n        {'X', 'O', 'X'},\n        {'O', 'X', 'O'}\n    };\n    assert(check_tic_tac_toe_winner(board5) == 'O');\n\n    return 0;\n}\n"}
{"language": "c++", "domain": "game", "source": "gpt4+人工筛选；源文件地址/data/xw/c++dataset/game/already/45.cpp", "prompt": "// input_start\n/*\n1. 初始化函数 initGame：接收行和列数量，生成指定大小的游戏区域，并将其填充为指定的初始值。\n2. 状态变换函数 changeState：接收待改变的位置以及状态值，修改指定位置的状态。\n3. 移动函数 move：接收方向，更改指定方向状态。返回更改后的二维数组。\n4. 胜利检测函数 isWin：检查游戏是否胜利，返回是否胜利的布尔值。\n5. 随机生成数字函数 generateNum：在游戏区域的空白位上随机生成一个新数字。\n6. 打印游戏区域函数 printGameArea：打印当前游戏区域的状态。\n*/\n", "solution": "#include <cstdlib>\n\n// 初始化游戏\nstd::vector<std::vector<int>> initGame(int rows, int cols, int initVal = 0);\n\n// 改变指定位置的状态\nvoid changeState(std::vector<std::vector<int>>& gameArea, int x, int y, int state);\n\n// 在指定方向移动\nstd::vector<std::vector<int>> move(std::vector<std::vector<int>> gameArea, const std::string& direction);\n\n// 检测是否胜利\nbool isWin(const std::vector<std::vector<int>>& gameArea, int target = 2048);\n\n// 在空白位上随机生成一个新数字\nvoid generateNum(std::vector<std::vector<int>>& gameArea);\n\n", "test": "\n// solution_start\nstd::vector<std::vector<int>> initGame(int rows, int cols, int initVal) {\n    return std::vector<std::vector<int>>(rows, std::vector<int>(cols, initVal));\n}\n\nvoid changeState(std::vector<std::vector<int>>& gameArea, int x, int y, int state) {\n    gameArea[x][y] = state;\n}\n\nstd::vector<std::vector<int>> move(std::vector<std::vector<int>> gameArea, const std::string& direction) {\n    // 这里暂时未实现移动逻辑，留作作业\n    return gameArea;\n}\n\nbool isWin(const std::vector<std::vector<int>>& gameArea, int target) {\n    for (const auto& row : gameArea) {\n        if (std::find(row.begin(), row.end(), target) != row.end()) {\n            return true;\n        }\n    }\n    return false;\n}\n\nvoid generateNum(std::vector<std::vector<int>>& gameArea) {\n    std::vector<int> emptyPos;\n    for (int i = 0; i < gameArea.size(); i++) {\n        for (int j = 0; j < gameArea[i].size(); i++) {\n            if (gameArea[i][j] == 0) {\n                emptyPos.push_back(i * gameArea.size() + j); // 储存空白位的索引\n            }\n        }\n    }\n\n    // 生成新数字\n    if (!emptyPos.empty()) {\n        int newPosIndex = rand() % emptyPos.size(); // 随机选择一个索引\n        int newPos = emptyPos[newPosIndex];\n"}
{"language": "c++", "domain": "game", "source": "gpt4+人工筛选；源文件地址/data/xw/c++dataset/game/already/114.cpp", "prompt": "#include<iostream>\n/* 实现一个函数，检查给定的游戏盘中是否有连续4个相同号码的情况。\n游戏盘是一个7x6的二维数组，其中每个元素代表一个游戏的方格，可以是'X'，'O'或一个空格' '，\n代表玩家X，玩家O或者空格。函数格式定义为：bool isFourInRow(char board[6][7]) */\n", "solution": "bool isFourInRow(char board[6][7]) {\n    for(int i = 0; i < 6; ++i) {\n        for(int j = 0; j < 7; ++j) {\n            if(board[i][j] != ' ') {\n                if(j < 7 - 3 && board[i][j] == board[i][j + 1] && board[i][j] == board[i][j + 2] && board[i][j] == board[i][j + 3]) {\n                    return true;\n                }\n                if(i < 6 - 3 && board[i][j] == board[i + 1][j] && board[i][j] == board[i + 2][j] && board[i][j] == board[i + 3][j]) {\n                    return true;\n                }\n                if(i < 6 - 3 && j < 7 - 3 && board[i][j] == board[i + 1][j + 1] && board[i][j] == board[i + 2][j + 2] && board[i][j] == board[i + 3][j + 3]) {\n                    return true;\n                }\n                if(i >= 3 && j < 7 - 3 && board[i][j] == board[i - 1][j + 1] && board[i][j] == board[i - 2][j + 2] && board[i][j] == board[i - 3][j + 3]) {\n                    return true;\n                }\n            }\n        }\n    }\n    return false;\n}\n", "test": "#include<assert.h>\nint main() {\n    char test1[6][7] = {\n        {' ', ' ', ' ', ' ', ' ', ' ', ' '},\n        {' ', ' ', ' ', ' ', ' ', ' ', ' '},\n        {' ', ' ', ' ', ' ', ' ', ' ', ' '},\n        {' ', ' ', ' ', ' ', ' ', ' ', ' '},\n        {' ', ' ', ' ', ' ', ' ', ' ', ' '},\n        {'O', 'O', 'O', 'O', ' ', ' ', ' '},\n    };\n    assert(isFourInRow(test1) == true);\n\n    char test2[6][7] = {\n        {' ', ' ', ' ', ' ', ' ', ' ', ' '},\n        {' ', ' ', ' ', ' ', ' ', ' ', ' '},\n        {' ', ' ', ' ', ' ', ' ', ' ', ' '},\n        {' ', ' ', ' ', ' ', ' ', ' ', ' '},\n        {' ', ' ', ' ', ' ', ' ', ' ', ' '},\n        {'O', 'O', 'O', 'X', ' ', ' ', ' '},\n    };\n    assert(isFourInRow(test2) == false);\n\n    char test3[6][7] = {\n        {' ', ' ', ' ', ' ', ' ', ' ', ' '},\n        {' ', 'X', ' ', ' ', ' ', ' ', ' '},\n        {' ', 'X', ' ', ' ', ' ', ' ', ' '},\n        {' ', 'X', ' ', ' ', ' ', ' ', ' '},\n        {' ', 'X', ' ', ' ', ' ', ' ', ' '},\n        {'O', 'O', 'O', 'O', ' ', ' ', ' '},\n    };\n    assert(isFourInRow(test3) == true);\n\n    char test5[6][7] = {\n        {' ', ' ', ' ', ' ', ' ', ' ', ' '},\n        {' ', ' ', ' ', 'X', ' ', ' ', ' '},\n        {' ', ' ', 'X', ' ', ' ', ' ', ' '},\n        {' ', 'X', ' ', ' ', ' ', ' ', ' '},\n        {'X', ' ', ' ', ' ', ' ', ' ', ' '},\n        {'O', 'O', 'O', 'O', ' ', ' ', ' '},\n    };\n    assert(isFourInRow(test5) == true);\n    return 0;\n}\n"}
{"language": "c++", "domain": "game", "source": "gpt4+人工筛选；源文件地址/data/xw/c++dataset/game/already/342.cpp", "prompt": "#include <iostream>\n#include <vector>\n/*\nint checkWin(const std::vector<int> &board)\n输入一个表示棋盘状态的一维数组，其中每个元素可以是0（表示空位）、1（表示玩家1的棋子）、2（表示玩家2的棋子）\n棋盘是3*3的格子，数组长度为9，分别对应每个格子的状态。从左到右，从上到下。\n此函数将根据当前棋盘状态，判断是否有玩家赢得游戏，如果玩家1赢了，返回1，如果玩家2赢了，返回2，否则返回0表示游戏为结束。\n*/\n", "solution": "int checkWin(const std::vector<int> &board) {\n    //判断行和列\n    for(int i=0;i<3;i++){\n        if(board[i*3] == board[i*3+1] && board[i*3+1] == board[i*3+2] && board[i*3]!=0)\n            return board[i*3];\n        if(board[i] == board[i+3] && board[i+3] == board[i+6] && board[i]!=0)\n            return board[i];\n    }\n    //判断对角线\n    if(board[0] == board[4] && board[4] == board[8] && board[0]!=0)\n        return board[0];\n    if(board[2] == board[4] && board[4] == board[6] && board[2]!=0)\n        return board[2];\n    return 0; //没有玩家获胜\n}\n", "test": "#include<assert.h>\nint main() {\n    std::vector<int> board1={1,0,0,1,0,0,1,0,0};\n    assert(checkWin(board1) == 1);\n    std::vector<int> board2={0,2,0,0,2,0,0,2,0};\n    assert(checkWin(board2) == 2);\n    std::vector<int> board3={0,0,1,0,1,0,1,0,0};\n    assert(checkWin(board3) == 1);\n    std::vector<int> board4={2,0,0,0,2,0,0,0,2};\n    assert(checkWin(board4) == 2);\n    std::vector<int> board5={0,1,2,1,2,1,2,1,2};\n    assert(checkWin(board5) == 2);\n    return 0;\n}\n"}
{"language": "c++", "domain": "game", "source": "gpt4+人工筛选；源文件地址/data/xw/c++dataset/game/already/285.cpp", "prompt": "#include <time.h>\n#include <stdlib.h>\n\n/* \n实现一个可以模拟抛硬币的函数，该函数返回1表示正面，返回0表示反面。\n函数的格式定义为：int coin_flip()\n*/\n", "solution": "int coin_flip() {\n    srand(time(NULL));\n    return rand()%2;  \n}\n", "test": "#include<assert.h>\nint main() {\n    // 硬币翻转的结果只可能是0或1，其他结果均为异常\n    assert(coin_flip() == 0 || coin_flip() == 1);\n    assert(coin_flip() == 0 || coin_flip() == 1);\n    assert(coin_flip() == 0 || coin_flip() == 1);\n    assert(coin_flip() == 0 || coin_flip() == 1);\n    assert(coin_flip() == 0 || coin_flip() == 1);\n}\n"}
{"language": "c++", "domain": "game", "source": "gpt4+人工筛选；源文件地址/data/xw/c++dataset/game/already/147.cpp", "prompt": "#include <iostream>\n#include <vector>\nusing namespace std;\n/* \n    函数：vector<vector<int>> initBoard(int row, int col)\n    功能：该函数用于初始化游戏界面。将游戏界面设置为row行，col列，并且初始化为全0并返回。 \n    输入参数为游戏界面的行数和列数, 返回一个二维int型vector, 表示游戏的界面。 \n    row:游戏界面的行数，col:游戏界面的列数。\n*/\n", "solution": "vector<vector<int>> initBoard(int row, int col){\n    vector<vector<int> > board(row, vector<int>(col, 0));\n    return board;\n}\n", "test": "#include <assert.h>\nint main(){\n    vector<vector<int>> board = initBoard(5,5);\n    // 测试行数是否为5\n    assert(board.size()==5);\n    // 测试列数是否为5\n    assert(board[0].size()==5);\n    //测试初始化的值是否为0\n    for(int i = 0; i < 5; ++i){\n        for(int j = 0; j < 5; ++j){\n            assert(board[i][j]==0);\n        }\n    }\n    \n    return 0;\n}\n"}
{"language": "c++", "domain": "game", "source": "gpt4+人工筛选；源文件地址/data/xw/c++dataset/game/already/18.cpp", "prompt": "#include <iostream>\n#include <cstring>\n#include <cassert>\nusing namespace std;\n\n/*\n* 实现一个简单的井字棋游戏\n创建了一个井字棋的类。该类为游戏的初始状态，移动，胜利判定和游戏重置提供了方法。在测试部分，我们验证了无人胜利的初始状态，一手棋后仍然没有人胜利，一方胜利后游戏的判定以及新游戏开始后的状态。\n*/\nclass TicTacToe {\npublic:\n    TicTacToe();\n    void play(int player, int x, int y);\n    bool checkWin(int player);\n    void next();\n\nprivate:\n    char board[3][3];\n};\n\n", "solution": "TicTacToe::TicTacToe() {\n    memset(board, ' ', sizeof(board));\n}\n\nvoid TicTacToe::play(int player, int x, int y) {\n    board[x][y] = (player == 1) ? 'X' : 'O';\n}\n\nbool TicTacToe::checkWin(int player) {\n    char symbol = (player == 1) ? 'X' : 'O';\n\n    for (int i = 0; i < 3; ++i) {\n        if (board[i][0] == board[i][1] && board[i][1] == board[i][2] && board[i][0] == symbol)\n            return true;\n    }\n\n    for (int j = 0; j < 3; ++j) {\n        if (board[0][j] == board[1][j] && board[1][j] == board[2][j] && board[0][j] == symbol)\n            return true;\n    }\n\n    if (board[0][0] == board[1][1] && board[1][1] == board[2][2] && board[0][0] == symbol)\n        return true;\n\n    if (board[0][2] == board[1][1] && board[1][1] == board[2][0] && board[0][2] == symbol)\n        return true;\n\n    return false;\n}\n\nvoid TicTacToe::next() {\n    memset(board, ' ', sizeof(board));\n}\n\n", "test": "int main() {\n    TicTacToe game;\n\n    // Test 1: At the start of the game, no one has won yet.\n    assert(game.checkWin(1) == false);\n    assert(game.checkWin(2) == false);\n\n    // Test 2: After one move, player 1 has not won yet.\n    game.play(1, 1, 1);\n    assert(game.checkWin(1) == false);\n\n    // Test 3: If player 1 makes a winning move, the game recognizes it.\n    game.play(1, 0, 0);\n    game.play(1, 2, 2);\n    assert(game.checkWin(1) == true);\n\n    // Test 4: If we start a new game, neither player has won.\n    game.next();\n    assert(game.checkWin(1) == false);\n    assert(game.checkWin(2) == false);\n\n    // Test 5: Player 2 can also win.\n    game.play(2, 0, 0);\n    game.play(2, 0, 1);\n    game.play(2, 0, 2);\n    assert(game.checkWin(2) == true);\n\n    return 0;\n}\n\n"}
{"language": "c++", "domain": "game", "source": "gpt4+人工筛选；源文件地址/data/xw/c++dataset/game/already/120.cpp", "prompt": "#include <iostream>\n#include <vector>\n\nusing namespace std;\n\n/*实现一个简单的游戏，判断玩家是否在给定的9个格子中找到了3个连续的同样的数字（行，列，对角线都可以）\n函数的格式定义为：bool findThreeInARow(vector<int> grid)\ngrid的长度为9，代表一个3*3的格子，玩家可以在每个格子中放上1或者2，表示不同的玩家\n返回一个表示游戏结果的布尔值（如果找到3个连在一起的格子被同一玩家占据，则返回true，否则返回false）\n */\n", "solution": "bool findThreeInARow(vector<int> grid) {\n    //检查行\n    for (int i = 0; i < 9; i+=3) {\n        if (grid[i] == grid[i+1] && grid[i+1] == grid[i+2] && grid[i] != 0) {\n            return true;\n        }\n    }\n    \n    //检查列\n    for (int i = 0; i < 3; ++i) {\n        if (grid[i] == grid[i+3] && grid[i+3] == grid[i+6] && grid[i] != 0) {\n            return true;\n        }\n    }\n    //检查对角线\n    if ((grid[0] == grid[4] && grid[4] == grid[8]) || (grid[2] == grid[4] && grid[4] == grid[6]) && grid[4] != 0) {\n        return true;\n    }\n    //如果没有找到3个连续的格子，返回false\n    return false;\n}\n", "test": "#include<assert.h>\nint main() {\n    assert(findThreeInARow({1,0,2,0,1,0,2,0,1})== true);\n    assert(findThreeInARow({1,1,1,0,2,0,2,0,2})== true);\n    assert(findThreeInARow({2,2,1,1,1,2,2,1,1})== false);\n    assert(findThreeInARow({1,1,0,0,2,0,2,0,1})== false);\n\n    return 0;\n}\n"}
{"language": "c++", "domain": "game", "source": "gpt4+人工筛选；源文件地址/data/xw/c++dataset/game/already/126.cpp", "prompt": "#include <iostream>\n/*判断井字棋的游戏结果\nint ticTacToe(int board[3][3])\nboard是一个3*3的整数矩阵，表示井字棋的游戏棋盘，其中0表示空，1表示X，2表示O\nreshape(int x, int y)表示将X和Y进行井字棋皇后的观察，如果有一方赢则返回该方的值（1 或者 2），如果没有人胜利则返回0\n */\n", "solution": "bool checkLine(int board[3][3], int player) {\n    for (int i=0; i<3; ++i) {\n        if ((board[i][0] == player && board[i][1] == player && board[i][2] == player) || \n            (board[0][i] == player && board[1][i] == player && board[2][i] == player)) {\n            return true;\n        }\n    }\n    if ((board[0][0] == player && board[1][1] == player && board[2][2] == player) ||\n        (board[0][2] == player && board[1][1] == player && board[2][0] == player)) {\n        return true;\n    }\n    return false;\n}\n\nint ticTacToe(int board[3][3]) {\n    if (checkLine(board, 1)) return 1;\n    if (checkLine(board, 2)) return 2;\n    return 0;\n}\n", "test": "#include<assert.h>\nint main() {\n    int board1[3][3] = {{1,2,1},{2,1,0},{2,1,1}};\n    assert(ticTacToe(board1)==1);\n    int board2[3][3] = {{2,2,1},{1,1,2},{2,1,1}};\n    assert(ticTacToe(board2)==0);\n    int board3[3][3] = {{1,2,1},{2,1,2},{2,1,1}};\n    assert(ticTacToe(board3)==1);\n    int board4[3][3] = {{1,2,1},{2,2,2},{1,2,1}};\n    assert(ticTacToe(board4)==2);\n    int board5[3][3] = {{1,1,1},{2,1,2},{1,2,1}};\n    assert(ticTacToe(board5)==1);\n    return 0;\n}\n"}
{"language": "c++", "domain": "game", "source": "gpt4+人工筛选；源文件地址/data/xw/c++dataset/game/already/game3.cpp", "prompt": "#include <iostream>\n#include <random>\n#include <ctime>\n\nusing namespace std;\n\n/*实现扑克牌点数比大小游戏的函数\n函数的格式定义为：int comparePoker(int player1Card, int player2Card)\nplayer1Card和player2Card的选择(1-13，其中1表示A，11表示J，12表示Q，13表示K)\n返回一个表示游戏结果的数字（0表示平局，1表示玩家1赢，2表示玩家2赢）\n */\n", "solution": "int comparePoker(int player1Card, int player2Card) {\n    if (player1Card == player2Card) {\n        return 0; \n    } else if (player1Card > player2Card) {\n        return 1; \n    } else {\n        return 2; \n    }\n}\n", "test": "#include<assert.h>\nint main() {\n    assert(comparePoker(1,2)==2);\n    assert(comparePoker(5,5)==0);\n    assert(comparePoker(11,12)==2);\n    assert(comparePoker(13,11)==1);\n    assert(comparePoker(13,13)==0);\n\n    return 0;\n}\n"}
{"language": "c++", "domain": "game", "source": "gpt4+人工筛选；源文件地址/data/xw/c++dataset/game/already/315.cpp", "prompt": "#include <iostream>\n#include <vector>\n\nusing namespace std;\n\n/*设计一个函数checkGameStatus()来检测井字游戏（Tic-tac-toe）的状态\n该函数的输入是一个字符二维数组，代表井字游戏的棋盘状态\n函数签名定义如下：string checkGameStatus(vector<vector<char>> board)\nboard 是一个3x3的字符二维数组，' '表示空格，'X'表示玩家X，'O'表示玩家O\n该函数返回一个字符串表示游戏的状态：\n    如果玩家X赢，返回\"X wins\"\n    如果玩家O赢，返回\"O wins\"\n    如果游戏仍在进行，返回\"Game is not over\"\n    如果游戏结束且无人获胜，返回\"Draw\"\n*/\n", "solution": "string checkGameStatus(vector<vector<char>> board) {\n    for (int i = 0; i < 3; i++) {\n        if (board[i][0] == board[i][1] && board[i][1] == board[i][2]) {\n            if (board[i][0] == 'X') return \"X wins\";\n            if (board[i][0] == 'O') return \"O wins\";\n        }\n        if (board[0][i] == board[1][i] && board[1][i] == board[2][i]) {\n            if (board[0][i] == 'X') return \"X wins\";\n            if (board[0][i] == 'O') return \"O wins\";\n        }\n    }\n    if (board[0][0] == board[1][1] && board[1][1] == board[2][2]) {\n        if (board[0][0] == 'X') return \"X wins\";\n        if (board[0][0] == 'O') return \"O wins\";\n    }\n    if (board[0][2] == board[1][1] && board[1][1] == board[2][0]) {\n        if (board[0][2] == 'X') return \"X wins\";\n        if (board[0][2] == 'O') return \"O wins\";\n    }\n    for (int i = 0; i < 3; i++) {\n        for (int j = 0; j < 3; j++) {\n            if (board[i][j] == ' ') return \"Game is not over\";\n        }\n    }\n    return \"Draw\";\n}\n", "test": "#include<assert.h>\nint main() {\n    vector<vector<char>> board1 = {{' ',' ',' '}, {' ', ' ',' '}, {' ' ,' ', ' '}};\n    vector<vector<char>> board2 = {{'X','X','X'}, {'O', 'O',' '}, {' ' ,' ', ' '}};\n    vector<vector<char>> board3 = {{'O',' ',' '}, {'O', ' ','X'}, {'O' ,' ','X'}};\n    vector<vector<char>> board4 = {{'O','X',' '}, {'O', 'X',' '}, {'X' ,'O', ' '}};\n    vector<vector<char>> board5 = {{'O','X','X'}, {'X', 'O','O'}, {'X' ,'O', 'X'}};\n\n    assert(checkGameStatus(board1) == \"Game is not over\");\n    assert(checkGameStatus(board2) == \"X wins\");\n    assert(checkGameStatus(board3) == \"O wins\");\n    assert(checkGameStatus(board4) == \"Game is not over\");\n    assert(checkGameStatus(board5) == \"Draw\");\n\n    return 0;\n}\n"}
{"language": "c++", "domain": "game", "source": "gpt4+人工筛选；源文件地址/data/xw/c++dataset/game/already/333.cpp", "prompt": "#include <iostream>\n\nusing namespace std;\n\n/* 实现一个简单的井字游戏胜负判断函数\n函数的格式定义为：char ticTacToeCheck(char board[3][3])\nboard 是一个 3x3 的二维数组，代表井字游戏的棋盘，格子的取值为'X', 'O', 或者' ' ，代表玩家X，玩家O或者空\n如果玩家X胜, 返回'X'，如果玩家O胜，返回 'O'，如果还没有结果，返回 'N'\n*/\n", "solution": "char ticTacToeCheck(char board[3][3]) {\n    //检查行和列\n    for(int i=0; i<3; i++) {\n        if(board[i][0] != ' ' && board[i][0] == board[i][1] && board[i][1] == board[i][2]) \n            return board[i][0];\n        if(board[0][i] != ' ' && board[0][i] == board[1][i] && board[1][i] == board[2][i]) \n            return board[0][i];\n    }\n    //检查对角线\n    if(board[0][0] != ' ' && board[0][0] == board[1][1] && board[1][1] == board[2][2]) \n        return board[0][0];\n    if(board[0][2] != ' ' && board[0][2] == board[1][1] && board[1][1] == board[2][0]) \n        return board[0][2];\n\n    return 'N';\n}\n", "test": "#include<assert.h>\nint main() {\n    char board1[3][3] = {\n        {'X', 'O', 'X'},\n        {'O', 'X', 'O'},\n        {'O', ' ', 'X'}\n    };\n\n    char board2[3][3] = {\n        {'O', 'O', 'O'},\n        {'O', 'X', 'O'},\n        {'X', ' ', 'O'}\n    };\n  \n    char board3[3][3] = {\n        {'O', 'O', 'X'},\n        {'O', 'O', 'X'},\n        {'X', ' ', ' '}\n    };\n\n    assert(ticTacToeCheck(board1) == 'X');\n    assert(ticTacToeCheck(board2) == 'O');\n    assert(ticTacToeCheck(board3) == 'N');\n\n    return 0;\n}\n"}
{"language": "c++", "domain": "game", "source": "gpt4+人工筛选；源文件地址/data/xw/c++dataset/game/already/225.cpp", "prompt": "#include <iostream>\n#include <vector>\n\nusing namespace std;\n\n/* 实现一个猜数字游戏的函数\n输入是目标数字(target)和玩家所猜的数字(guess)。\n函数的定义为: string guessNumber(int target, int guess)\ntarget - 一个1-100之间的整数，表示目标数字\nguess - 一个1-100之间的整数，表示玩家的猜测\n返回一个字符串，显示玩家猜测结果是\"too high\", \"too low\", 或者 \"correct\"。\n*/\n", "solution": "string guessNumber(int target, int guess) {\n    if(guess > target)\n        return \"too high.\";\n    else if(guess < target)\n        return \"too low.\";\n    else \n        return \"correct.\";\n}\n", "test": "#include<assert.h>\nint main() {\n    assert(guessNumber(50,60)==\"too high.\");\n    assert(guessNumber(50,40)==\"too low.\");\n    assert(guessNumber(50,50)==\"correct.\");\n    assert(guessNumber(80,81)==\"too high.\");\n    assert(guessNumber(80,79)==\"too low.\");\n\n    return 0;\n}\n"}
{"language": "c++", "domain": "game", "source": "gpt4+人工筛选；源文件地址/data/xw/c++dataset/game/already/345.cpp", "prompt": "#include <iostream>\n#include <vector>\nusing namespace std;\n/* 调用vector库进行井字棋的胜利条件判断\nbool isTicTacToeWin(vector<vector<char> > board)\nboard是井字棋的棋盘，使用一个二维char类型的vector表示。'X'代表玩家X的棋子，'O'代表玩家O的棋子，' '代表该位置空格。\n如果玩家X胜利返回true，否则返回false\n*/\n", "solution": "bool isTicTacToeWin(vector<vector<char> > board){\n    for(int i = 0; i<3; i++){\n        if(board[i][0]=='X' && board[i][1]=='X' && board[i][2]=='X') return true;\n        if(board[0][i]=='X' && board[1][i]=='X' && board[2][i]=='X') return true;\n    }\n    if(board[0][0]=='X' && board[1][1]=='X' && board[2][2]=='X') return true;\n    if(board[2][0]=='X' && board[1][1]=='X' && board[0][2]=='X') return true;\n    return false;\n}\n", "test": "#include<assert.h>\nint main(){\n    vector<vector<char> > board1 = {{'X', ' ', ' '}, {' ', 'X', ' '}, {' ', ' ', 'X'}};\n    vector<vector<char> > board2 = {{'X', 'X', 'X'}, {' ', ' ', ' '}, {' ', ' ', ' '}};\n    vector<vector<char> > board3 = {{' ', ' ', ' '}, {'X', 'X', 'X'}, {' ', ' ', ' '}};\n    vector<vector<char> > board4 = {{' ', ' ', ' '}, {' ', ' ', ' '}, {'X', 'X', 'X'}};\n    vector<vector<char> > board5 = {{'X', ' ', ' '}, {'X', ' ', ' '}, {'X', ' ', ' '}};\n    assert(isTicTacToeWin(board1) == true);\n    assert(isTicTacToeWin(board2) == true);\n    assert(isTicTacToeWin(board3) == true);\n    assert(isTicTacToeWin(board4) == true);\n    assert(isTicTacToeWin(board5) == true);\n    return 0;\n}\n"}
{"language": "c++", "domain": "game", "source": "gpt4+人工筛选；源文件地址/data/xw/c++dataset/game/already/297.cpp", "prompt": "#include <iostream>\n#include <vector>\n/* \n实现井字游戏的胜利条件判定\nbool checkWin(const std::vector<std::vector<char>> &board)\nboard是一个二维字符数组，表示井字游戏的棋盘状态，'X'表示玩家X的棋子，'O'表示玩家O的棋子，' '表示空格。如果有玩家胜利，则返回true，否则返回false。\n*/\n", "solution": "bool checkWin(const std::vector<std::vector<char>> &board) {\n    for (int i = 0; i < 3; ++i) {\n        if (board[i][0] != ' ' && board[i][0] == board[i][1] && board[i][0] == board[i][2]) {\n            return true;\n        }\n        if (board[0][i] != ' ' && board[0][i] == board[1][i] && board[0][i] == board[2][i]) {\n            return true;\n        }\n    }\n    if (board[1][1] != ' ' && ((board[0][0] == board[1][1] && board[1][1] == board[2][2]) || (board[0][2] == board[1][1] && board[1][1] == board[2][0]))) {\n        return true;\n    }\n    return false;\n}\n", "test": "#include<assert.h>\nint main() {\n    assert(checkWin({{'X',' ',' '},{' ','X',' '},{' ',' ','X'}}) == true);\n    assert(checkWin({{'O','O','O'},{' ',' ',' '},{' ',' ',' '}}) == true);\n    assert(checkWin({{'O','X','O'},{'X','O',' '},{'X',' ','O'}}) == true);\n    assert(checkWin({{' ',' ',' '},{' ',' ',' '},{' ',' ',' '}}) == false);\n    assert(checkWin({{'O','O','X'},{'X','O','O'},{'X','X','O'}}) == true);\n    return 0;\n}\n"}
{"language": "c++", "domain": "game", "source": "gpt4+人工筛选；源文件地址/data/xw/c++dataset/game/already/267.cpp", "prompt": "#include <iostream>\n\nusing namespace std;\n\n/* 实现一个函数来检查游戏中角色是否达到了最后一个关卡\n函数的格式定义为：bool isFinalLevel(int currentLevel, int totalLevels)\ncurrentLevel 是当前的关卡数，totalLevels 是游戏中总的关卡数\n如果玩家已经达到了最后一个关卡，则返回true，否则返回false\n*/\n", "solution": "bool isFinalLevel(int currentLevel, int totalLevels) {\n    if (currentLevel == totalLevels)\n        return true;\n    else\n        return false;\n}\n", "test": "#include<assert.h>\nint main() {\n    assert(isFinalLevel(1, 10) == false);\n    assert(isFinalLevel(5, 5) == true);\n    assert(isFinalLevel(7, 10) == false);\n    assert(isFinalLevel(10, 10) == true);\n    assert(isFinalLevel(10, 20) == false);\n\n    return 0;\n}\n"}
{"language": "c++", "domain": "game", "source": "gpt4+人工筛选；源文件地址/data/xw/c++dataset/game/already/294.cpp", "prompt": "#include <iostream>\n#include <vector>\n\nusing namespace std;\n\n/*实现2048游戏的移动函数（向左移）\n每个玩家在一个4*4的网格上操作，初始化都是0，每次生成2或4，移动后，数值相同的两个格子将会合并。\n函数的定义：vector<vector<int>> moveLeft(vector<vector<int>> grid);\n输入参数是2048网格，输出是向左移动后的2048网格。\n请保证输入的网格是4*4的，且格子的值为2的n次方。\n*/\n", "solution": "vector<vector<int>> moveLeft(vector<vector<int>>& grid) {\n    for (auto& row : grid) {\n        // Move all the non-zero elements to the front of the row (Left)\n        for (int i = 0, j = 0; j < row.size(); j++) {\n            if (row[j] != 0) {\n                swap(row[i++], row[j]);\n            }\n        }\n        // Combine the numbers if they are the same\n        for (int i = 0; i < row.size() - 1; i++) {\n            if (row[i] != 0 && row[i] == row[i + 1]) {\n                row[i] *= 2;\n                row[i + 1] = 0;\n                i++;\n            }\n        }\n        // Move all the non-zero elements to the front of the row (Left) again\n        for (int i = 0, j = 0; j < row.size(); j++) {\n            if (row[j] != 0) {\n                swap(row[i++], row[j]);\n            }\n        }\n    }\n    return grid;\n}\n", "test": "#include<assert.h>\nint main() {\n    vector<vector<int>> grid = {\n        {2, 2, 4, 8},\n        {0, 0, 0, 2},\n        {0, 4, 4, 0},\n        {8, 2, 2, 2}\n\t} ;\n    vector<vector<int>> result = moveLeft(grid);\n    \n    vector<vector<int>> assertion = {\n        {4, 4, 8, 0},\n        {2, 0, 0, 0},\n        {8, 0, 0, 0},\n        {8, 4, 2, 0}\n\t} ;\n    assert(result == assertion);\n\n    return 0;\n}\n"}
