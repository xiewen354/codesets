{"language": "c", "domain": "algorithm", "source": "人工提问+gpt4生成代码+人工筛选；源文件地址/data/xw/c++dataset/1.6/copy/algro/46.c", "prompt": "\n/*\n功能说明：计算并返回 x 的平方根（向下取整）。\n输入参数：\n- int x: 需要计算平方根的非负整数\n\n返回值：x 的平方根的整数部分。\n*/\nint my_sqrt(int x);\n\n", "solution": "\nint my_sqrt(int x) {\n    if (x <= 1) {\n        return x;\n    }\n    int left = 0, right = x;\n    while (left <= right) {\n        long mid = left + (right - left) / 2;\n        long squared = mid * mid;\n        if (squared == x) {\n            return mid;\n        } else if (squared < x) {\n            left = mid + 1;\n        } else {\n            right = mid - 1;\n        }\n    }\n    return right;\n}\n\n", "test": "\n#include <assert.h>\n\nvoid test() {\n    // Test cases\n    assert(my_sqrt(0) == 0);  // Example 1\n    assert(my_sqrt(1) == 1);  // Example 2\n    assert(my_sqrt(4) == 2);  // Example 3\n    assert(my_sqrt(8) == 2);  // Example 4, since the square root of 8 is 2.82842..., and 2 is the floor value.\n    assert(my_sqrt(9) == 3);  // Example 5\n}\n\nint main() {\n    test();\n    return 0;\n}\n\n"}
{"language": "c", "domain": "algorithm", "source": "人工提问+gpt4生成代码+人工筛选；源文件地址/data/xw/c++dataset/1.6/copy/algro/36.c", "prompt": "\n/*\n功能说明：使用递归的方法对给定的二叉树进行前序遍历。\n输入参数：指向二叉树根节点的指针root。\n返回值：无返回值，但通过某种方式记录遍历的结果。\n*/\n#include <stddef.h>\nstruct TreeNode {\n    int val;\n    struct TreeNode *left;\n    struct TreeNode *right;\n};\n\nint results[100];\nint count = 0;\n\nvoid visit(struct TreeNode* node) {\n    if (count < 100) {\n        results[count++] = node->val;\n    }\n}\n\nvoid preorderTraversal(struct TreeNode* root, void (*visit)(struct TreeNode*));\n\n", "solution": "\nvoid preorderTraversal(struct TreeNode* root, void (*visit)(struct TreeNode*)) {\n    if (root == NULL) {\n        return;\n    }\n    visit(root);\n    preorderTraversal(root->left, visit);\n    preorderTraversal(root->right, visit);\n}\n\n", "test": "\n#include <assert.h>\n#include <stdlib.h>\n\nvoid resetResults() {\n    count = 0;\n    for (int i = 0; i < 100; i++) {\n        results[i] = 0;\n    }\n}\n\nvoid test() {\n    // Reset results before each test\n    resetResults();\n    \n    // Construct sample trees\n    struct TreeNode n1 = {1, NULL, NULL};\n    struct TreeNode n2 = {2, NULL, NULL};\n    struct TreeNode n3 = {3, NULL, NULL};\n    n1.left = &n2;\n    n1.right = &n3;\n\n    // Test 1: Expected preorder: 1, 2, 3\n    preorderTraversal(&n1, visit);\n    assert(results[0] == 1);\n    assert(results[1] == 2);\n    assert(results[2] == 3);\n\n    // Test 2: Test with single node tree\n    resetResults();\n    preorderTraversal(&n2, visit);\n    assert(results[0] == 2);\n\n    // Test 3: Test with NULL\n    resetResults();\n    preorderTraversal(NULL, visit);\n    assert(count == 0); // Count should remain 0 as there are no nodes to visit\n\n    // Test 4: Test with right skewed tree\n    struct TreeNode n4 = {4, NULL, NULL};\n    struct TreeNode n5 = {5, NULL, NULL};\n    n3.right = &n4;\n    n4.right = &n5;\n    resetResults();\n    // Expected preorder: 1, 2, 3, 4, 5\n    preorderTraversal(&n1, visit);\n    assert(results[0] == 1);\n    assert(results[1] == 2);\n    assert(results[2] == 3);\n    assert(results[3] == 4);\n    assert(results[4] == 5);\n\n    // Test 5: Test with left skewed tree\n    n1.left = &n3; n1.right = NULL;\n    n3.left = &n4; n3.right = NULL;\n    n4.left = &n5; n4.right = NULL;\n    resetResults();\n    // Expected preorder: 1, 3, 4, 5\n    preorderTraversal(&n1, visit);\n    assert(results[0] == 1);\n    assert(results[1] == 3);\n    assert(results[2] == 4);\n    assert(results[3] == 5);\n}\n\nint main() {\n    test();\n    return 0;\n}\n\n"}
{"language": "c", "domain": "algorithm", "source": "人工提问+gpt4生成代码+人工筛选；源文件地址/data/xw/c++dataset/1.6/copy/algro/52.c", "prompt": "\n/*\n功能说明：将整数转化为罗马数字。\n输入参数：\n- int num: 需要转换的整数，范围在1到3999之间。\n\n返回值：对应的罗马数字字符串。\n*/\n#include <stdlib.h>\n#include <string.h>\nchar* intToRoman(int num);\n\n", "solution": "\nchar* intToRoman(int num) {\n    char *romanNumerals[] = {\n        \"M\", \"CM\", \"D\", \"CD\", \"C\", \"XC\", \"L\", \"XL\", \"X\", \"IX\", \"V\", \"IV\", \"I\"\n    };\n    int values[] = {\n        1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1\n    };\n    char *result = malloc(sizeof(char) * 16);\n    int pos = 0;\n\n    for (int i = 0; i < 13; i++) {\n        while (num >= values[i]) {\n            num -= values[i];\n            int len = strlen(romanNumerals[i]);\n            memcpy(result + pos, romanNumerals[i], len);\n            pos += len;\n        }\n    }\n    result[pos] = '\\0';\n    \n    return result;\n}\n\n", "test": "\n#include <assert.h>\n#include <string.h>\n\nvoid test() {\n    // Test case 1\n    char *result1 = intToRoman(3);\n    assert(strcmp(result1, \"III\") == 0);\n    free(result1);\n\n    // Test case 2\n    char *result2 = intToRoman(4);\n    assert(strcmp(result2, \"IV\") == 0);\n    free(result2);\n\n    // Test case 3\n    char *result3 = intToRoman(9);\n    assert(strcmp(result3, \"IX\") == 0);\n    free(result3);\n\n    // Test case 4\n    char *result4 = intToRoman(58);\n    assert(strcmp(result4, \"LVIII\") == 0);\n    free(result4);\n\n    // Test case 5\n    char *result5 = intToRoman(1994);\n    assert(strcmp(result5, \"MCMXCIV\") == 0);\n    free(result5);\n}\n\nint main() {\n    test();\n    return 0;\n}\n\n"}
{"language": "c", "domain": "algorithm", "source": "人工提问+gpt4生成代码+人工筛选；源文件地址/data/xw/c++dataset/1.6/copy/algro/34.c", "prompt": "\n/*\n功能说明：使用插入排序算法对链表进行排序。\n输入参数：链表的头节点head。\n返回值：排序后的链表的头节点。\n*/\n#include <stddef.h>\nstruct ListNode {\n    int val;\n    struct ListNode *next;\n};\n\nstruct ListNode* insertionSortList(struct ListNode* head);\n\n", "solution": "\nstruct ListNode* insertionSortList(struct ListNode* head) {\n    if (head == NULL || head->next == NULL) {\n        return head;\n    }\n\n    struct ListNode *sorted = NULL, *current = head, *next = NULL, *prev = NULL;\n    \n    while (current != NULL) {\n        next = current->next;\n        \n        if (sorted == NULL || sorted->val >= current->val) {\n            current->next = sorted;\n            sorted = current;\n        } else {\n            prev = sorted;\n            while (prev->next != NULL && prev->next->val < current->val) {\n                prev = prev->next;\n            }\n            current->next = prev->next;\n            prev->next = current;\n        }\n        \n        current = next;\n    }\n    \n    return sorted;\n}\n\n", "test": "\n#include <assert.h>\n#include <stdlib.h>\n\nstruct ListNode* createNode(int val) {\n    struct ListNode* new_node = (struct ListNode*)malloc(sizeof(struct ListNode));\n    if (!new_node) return NULL;\n    new_node->val = val;\n    new_node->next = NULL;\n    return new_node;\n}\n\nvoid freeList(struct ListNode* head) {\n    struct ListNode* current = head;\n    while (current != NULL) {\n        struct ListNode* next = current->next;\n        free(current);\n        current = next;\n    }\n}\n\nvoid assertListEqual(struct ListNode* lhs, struct ListNode* rhs) {\n    while (lhs != NULL && rhs != NULL) {\n        assert(lhs->val == rhs->val);\n        lhs = lhs->next;\n        rhs = rhs->next;\n    }\n    assert(lhs == NULL && rhs == NULL);\n}\n\nvoid test() {\n    struct ListNode *node1, *node2, *node3, *node4, *sortedList;\n    \n    // Test with empty list\n    sortedList = insertionSortList(NULL);\n    assert(sortedList == NULL);\n\n    // Test with single element list\n    node1 = createNode(1);\n    sortedList = insertionSortList(node1);\n    assertListEqual(sortedList, node1);\n    freeList(sortedList);\n\n    // Test with two unsorted elements\n    node1 = createNode(2);\n    node1->next = createNode(1);\n    node2 = createNode(1);\n    node2->next = createNode(2);\n    sortedList = insertionSortList(node1);\n    assertListEqual(sortedList, node2);\n    freeList(sortedList);\n    freeList(node2);\n\n    // Test with multiple unsorted elements\n    node1 = createNode(3);\n    node1->next = createNode(1);\n    node1->next->next = createNode(2);\n    node2 = createNode(1);\n    node2->next = createNode(2);\n    node2->next->next = createNode(3);\n    sortedList = insertionSortList(node1);\n    assertListEqual(sortedList, node2);\n    freeList(sortedList);\n    freeList(node2);\n\n    // Test with already sorted list\n    node1 = createNode(1);\n    node1->next = createNode(2);\n    node1->next->next = createNode(3);\n    sortedList = insertionSortList(node1);\n    assertListEqual(sortedList, node1);\n    freeList(sortedList);\n}\n\nint main() {\n    test();\n    return 0;\n}\n\n"}
{"language": "c", "domain": "algorithm", "source": "人工提问+gpt4生成代码+人工筛选；源文件地址/data/xw/c++dataset/1.6/copy/algro/41.c", "prompt": "\n/*\n功能说明：给定一个二叉树，填充它的每个 next 指针，让这个指针指向其同一层的下一个右侧节点。如果找不到下一个右侧节点，则将 next 指针设置为 NULL。\n初始状态下，所有 next 指针都被设置为 NULL。\n结构定义：\nstruct TreeLinkNode {\n    TreeLinkNode *left;\n    TreeLinkNode *right;\n    TreeLinkNode *next;\n};\n输入参数：二叉树的根节点 root。\n*/\nstruct TreeLinkNode {\n    struct TreeLinkNode *left;\n    struct TreeLinkNode *right;\n    struct TreeLinkNode *next;\n};\n#include <stddef.h>\nvoid connect(struct TreeLinkNode *root);\n\n", "solution": "\nvoid connect(struct TreeLinkNode *root) {\n    if (!root) return;\n\n    struct TreeLinkNode *current = root;\n    struct TreeLinkNode *nextLevelHead = NULL;\n    struct TreeLinkNode *prev = NULL;\n\n    while (current) {\n        while (current) {\n            if (current->left) {\n                if (prev) {\n                    prev->next = current->left;\n                } else {\n                    nextLevelHead = current->left;\n                }\n                prev = current->left;\n            }\n\n            if (current->right) {\n                if (prev) {\n                    prev->next = current->right;\n                } else {\n                    nextLevelHead = current->right;\n                }\n                prev = current->right;\n            }\n\n            current = current->next;\n        }\n\n        current = nextLevelHead;\n        nextLevelHead = NULL;\n        prev = NULL;\n    }\n}\n\n", "test": "\n// Testing is a bit complex as it requires creating a binary tree,\n// linking the nodes, and checking if the `next` pointers are set correctly.\n// Usually, such tests would be written in a more feature-rich language\n// and might involve a function to traverse the tree and collect the values\n// of `next` pointers for verification.\n\n// For demonstration purposes, here's a simple way to test the first level:\n\n#include <assert.h>\n\nvoid test() {\n    // Example test\n    // Construct the binary tree:\n    //      1\n    //     / \\\n    //    2   3\n    struct TreeLinkNode a = {NULL, NULL, NULL};\n    struct TreeLinkNode b = {NULL, NULL, NULL};\n    struct TreeLinkNode c = {NULL, NULL, NULL};\n\n    a.left = &b;\n    a.right = &c;\n\n    // Connect nodes\n    connect(&a);\n\n    // Test if node '2' is connected to node '3'\n    assert(b.next == &c);\n    // Test if node '3' is connected to NULL\n    assert(c.next == NULL);\n    // As we cannot create a more complex test environment here,\n    // further testing would be needed in a proper test suite.\n}\n\nint main() {\n    test();\n    return 0;\n}\n\n"}
{"language": "c", "domain": "algorithm", "source": "人工提问+gpt4生成代码+人工筛选；源文件地址/data/xw/c++dataset/1.6/copy/algro/54.c", "prompt": "\n/*\n功能说明：判断字符串中的所有字符是否全都不同。\n输入参数：\n- string iniString: 输入的字符串。\n\n返回值：如果字符串中的所有字符全都不同，则返回true；如果存在相同的字符，则返回false。\n字符串中的字符为ASCII字符，字符串的长度小于等于3000。大小写字母算不同的字符。\n*/\n\n#include <stdbool.h>\n#include <string.h>\n\nbool isUniqueChars(char* iniString);\n\n", "solution": "\nbool isUniqueChars(char* iniString) {\n    // 由于ASCII字符集大小为128，如果字符串长度超过128，则必定有重复\n    if (strlen(iniString) > 128) return false;\n\n    // 使用一个整型变量作为位向量，每个位代表一个字符是否出现过\n    unsigned long checker = 0;\n    for (int i = 0; i < strlen(iniString); i++) {\n        int val = iniString[i] - 'A'; // 假设字符串全为大写字母，或者对应调整\n        if ((checker & (1 << val)) > 0) {\n            // 如果对应的位已经为1，表示该字符之前出现过\n            return false;\n        }\n        checker |= (1 << val); // 将对应的位设为1\n    }\n    return true;\n}\n\n", "test": "\n#include <assert.h>\n\nvoid test() {\n    // Test case 1\n    assert(isUniqueChars(\"aeiou\") == true);\n\n    // Test case 2\n    assert(isUniqueChars(\"BarackObama\") == false);\n\n    // Test case 3\n    assert(isUniqueChars(\"abcaBC\") == false);\n\n    // Test case 4\n    assert(isUniqueChars(\"1234567890\") == true);\n\n    // Test case 5\n    assert(isUniqueChars(\"\") == true); // 空字符串没有重复字符\n}\n\nint main() {\n    test();\n    return 0;\n}\n\n"}
{"language": "c", "domain": "algorithm", "source": "人工提问+gpt4生成代码+人工筛选；源文件地址/data/xw/c++dataset/1.6/copy/algro/17.c", "prompt": "\n/* 计算两个正整数的最小公倍数 (LCM)\n功能说明：给定两个正整数，返回它们的最小公倍数\n输入参数：两个整数a和b\n返回值：最小公倍数\n*/\n\nint leastCommonMultiple(int a, int b);\n\n", "solution": "\nint greatestCommonDivisor(int a, int b) {\n    // 辗转相除法求最大公约数\n    while(b != 0) {\n        int temp = b;\n        b = a % b;\n        a = temp;\n    }\n    return a;\n}\n\nint leastCommonMultiple(int a, int b) {\n    // 最小公倍数 = 两数的乘积 / 最大公约数\n    int gcd = greatestCommonDivisor(a, b);\n    return (a / gcd) * b;\n}\n\n", "test": "\n#include <assert.h>\n\nvoid test() {\n    assert(leastCommonMultiple(3, 5) == 15);\n    assert(leastCommonMultiple(10, 20) == 20);\n    assert(leastCommonMultiple(7, 13) == 91);\n    assert(leastCommonMultiple(21, 6) == 42);\n    assert(leastCommonMultiple(8, 9) == 72);\n}\n\nint main() {\n    test(); // 运行测试\n    return 0;\n}\n\n"}
{"language": "c", "domain": "algorithm", "source": "人工提问+gpt4生成代码+人工筛选；源文件地址/data/xw/c++dataset/1.6/copy/algro/10.c", "prompt": "\n/* 根据输入的字母判断星期几\n功能说明：输入星期几的第一个字母后，判断并返回对应的星期\n如果第一个字母一样，将需要第二个字母进行进一步判断\n输入参数：第一个字母i和可能需要的第二个字母j\n返回值：对应的星期字符串\n*/\n\nchar* whichDay(char i, char j);\n\n", "solution": "\nchar* whichDay(char i, char j) {\n    switch (i) {\n        case 'm':\n            return \"monday\";\n        case 'w':\n            return \"wednesday\";\n        case 'f':\n            return \"friday\";\n        case 't':\n            if (j == 'u') {\n                return \"tuesday\";\n            }\n            if (j == 'h') {\n                return \"thursday\";\n            }\n            return \"error\";\n        case 's':\n            if (j == 'a') {\n                return \"saturday\";\n            }\n            if (j == 'u') {\n                return \"sunday\";\n            }\n            return \"error\";\n        default:\n            return \"error\";\n    }\n}\n\n", "test": "\n#include <assert.h>\n#include <string.h>\n\nvoid test() {\n    assert(strcmp(whichDay('m', '\\0'), \"monday\") == 0);\n    assert(strcmp(whichDay('w', '\\0'), \"wednesday\") == 0);\n    assert(strcmp(whichDay('f', '\\0'), \"friday\") == 0);\n    assert(strcmp(whichDay('t', 'u'), \"tuesday\") == 0);\n    assert(strcmp(whichDay('t', 'h'), \"thursday\") == 0);\n    assert(strcmp(whichDay('s', 'a'), \"saturday\") == 0);\n    assert(strcmp(whichDay('s', 'u'), \"sunday\") == 0);\n    assert(strcmp(whichDay('x', '\\0'), \"error\") == 0); // 测试一个默认情况\n}\n\nint main() {\n    test(); // 运行测试\n    return 0;\n}\n\n"}
{"language": "c", "domain": "algorithm", "source": "人工提问+gpt4生成代码+人工筛选；源文件地址/data/xw/c++dataset/1.6/copy/algro/50.c", "prompt": "\n/*\n功能说明：查找字符串数组中的最长公共前缀。\n输入参数：\n- char ** strs: 字符串数组。\n- int strsSize: 数组中字符串的数量。\n\n返回值：最长公共前缀字符串。\n*/\n#include <stddef.h>\n#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\nchar * longestCommonPrefix(char ** strs, int strsSize);\n\n", "solution": "\nchar * longestCommonPrefix(char ** strs, int strsSize) {\n    if (strsSize == 0) return \"\";\n    // 公共前缀最长不会超过数组中第一个字符串的长度\n    // char *prefix = strs[0];\n    char *prefix = (char *)malloc(sizeof(char) * 100);\n    strcpy(prefix, strs[0]);\n    \n    for (int i = 1; i < strsSize; i++) {\n        int j = 0;\n        // 对比每个字符串与当前已找到的公共前缀\n        while (prefix[j] && strs[i][j] && prefix[j] == strs[i][j]) {\n            j++;\n        }\n        // 截断公共前缀到当前匹配的长度\n        // printf(\"%c\\n\",prefix[j]);\n        prefix[j] = '\\0';\n        // 如果公共前缀已经没有了，直接返回\n        if (j == 0) return \"\";\n    }\n    \n    return prefix;\n}\n\n", "test": "\n#include <assert.h>\n#include <stdio.h>\nvoid test() {\n    // Test case 1\n    char *strs1[] = {\"flower\",\"flow\",\"flight\"};\n    assert(strcmp(longestCommonPrefix(strs1, 3), \"fl\") == 0);\n    // Test case 2\n    char *strs2[] = {\"dog\",\"racecar\",\"car\"};\n    assert(strcmp(longestCommonPrefix(strs2, 3), \"\") == 0);\n\n    // Test case 3\n    char *strs3[] = {\"interspecies\",\"interstellar\",\"interstate\"};\n    assert(strcmp(longestCommonPrefix(strs3, 3), \"inters\") == 0);\n\n    // Test case 4\n    char *strs4[] = {\"throne\",\"throne\"};\n    assert(strcmp(longestCommonPrefix(strs4, 2), \"throne\") == 0);\n\n    // Test case 5\n    char *strs5[] = {\"abca\",\"abc\",\"abca\",\"abc\",\"abcc\"};\n    assert(strcmp(longestCommonPrefix(strs5, 5), \"abc\") == 0);\n}\n\nint main() {\n    test();\n    return 0;\n}\n\n"}
{"language": "c", "domain": "algorithm", "source": "人工提问+gpt4生成代码+人工筛选；源文件地址/data/xw/c++dataset/1.6/copy/algro/1.c", "prompt": "#include <stdio.h>\n\n/* 实现一个字符串大小写转换函数\n输入参数为一个字符串\n函数格式定义为：void convertCase(char *str)\nstr表示需要转换大小写的字符串\n转换算法是将每个大写字符转换成小写字符，每个小写字符转换成大写字符\n函数不返回任何值，直接在输入的字符串上进行大小写转换操作\n*/\n\n", "solution": "\nvoid convertCase(char *str) {\n    if (str == NULL) return; // 检查空指针\n\n    while(*str) {\n        if (*str >= 'a' && *str <= 'z') {\n            *str = *str - 'a' + 'A';\n        } else if (*str >= 'A' && *str <= 'Z') {\n            *str = *str - 'A' + 'a';\n        }\n        str++;  // 移动到字符串中的下一个字符\n    }\n}\n\n", "test": "\n#include <assert.h>\n\nint main() {\n    char testStr1[] = \"Hello, World!\";\n\n    convertCase(testStr1);\n    assert(testStr1[0] == 'h'); // 测试第一个字符是否正确转换\n    assert(testStr1[1] == 'E'); // 测试第二个字符是否正确转换\n    assert(testStr1[2] == 'L'); // 测试第三个字符是否正确转换\n    assert(testStr1[3] == 'L'); // 测试第四个字符是否正确转换\n    assert(testStr1[4] == 'O'); // 测试第五个字符是否正确转换\n\n    return 0;\n}\n"}
{"language": "c", "domain": "algorithm", "source": "人工提问+gpt4生成代码+人工筛选；源文件地址/data/xw/c++dataset/1.6/copy/algro/31.c", "prompt": "\n/*\n功能说明：将华氏温度转换为摄氏温度。\n输入参数：华氏温度F。\n返回值：摄氏温度C，结果保留两位小数。\n*/\n\ndouble fahrenheitToCelsius(double F);\n\n", "solution": "\ndouble fahrenheitToCelsius(double F) {\n    return 5.0 / 9.0 * (F - 32);\n}\n\n", "test": "\n#include <assert.h>\n#include <math.h>\n\n// 辅助函数，用于比较两个double类型的数值是否相等（允许有微小误差）\nint areDoublesEqual(double a, double b, double tolerance) {\n    return fabs(a - b) < tolerance;\n}\n\nvoid test() {\n    assert(areDoublesEqual(fahrenheitToCelsius(32), 0, 0.01));          // 水的冰点\n    assert(areDoublesEqual(fahrenheitToCelsius(212), 100, 0.01));        // 水的沸点\n    assert(areDoublesEqual(fahrenheitToCelsius(98.6), 37, 0.01));        // 人体温度\n    assert(areDoublesEqual(fahrenheitToCelsius(0), -17.78, 0.01));       // 零华氏度\n    assert(areDoublesEqual(fahrenheitToCelsius(68), 20, 0.01));          // 室温\n}\n\nint main() {\n    test(); // 运行测试\n    return 0;\n}\n\n"}
{"language": "c", "domain": "algorithm", "source": "人工提问+gpt4生成代码+人工筛选；源文件地址/data/xw/c++dataset/1.6/copy/algro/35.c", "prompt": "\n/*\n功能说明：使用递归的方法对给定的二叉树进行后序遍历。\n输入参数：指向二叉树根节点的指针root。\n返回值：无返回值，但通过vist记录遍历的结果。\n*/\n#include <stddef.h>\nint count = 0;\nint results[100];\nstruct TreeNode {\n    int val;\n    struct TreeNode *left;\n    struct TreeNode *right;\n};\n\nvoid visit(struct TreeNode* node) {\n    if (count < 100) {\n        results[count++] = node->val;\n    }\n}\nvoid postorderTraversal(struct TreeNode* root, void (*visit)(struct TreeNode*));\n\n", "solution": "\nvoid postorderTraversal(struct TreeNode* root, void (*visit)(struct TreeNode*)) {\n    if (root == NULL) {\n        return;\n    }\n    postorderTraversal(root->left, visit);\n    postorderTraversal(root->right, visit);\n    visit(root);\n}\n\n", "test": "\n#include <assert.h>\n#include <stdlib.h>\n\nvoid test() {\n    struct TreeNode n1 = {1, NULL, NULL};\n    struct TreeNode n2 = {2, NULL, NULL};\n    struct TreeNode n3 = {3, NULL, NULL};\n    \n    n1.left = &n2;\n    n1.right = &n3;\n\n    // Reset results\n    count = 0;\n    \n    // Expected postorder: 2, 3, 1\n    postorderTraversal(&n1, visit);\n    assert(results[0] == 2);\n    assert(results[1] == 3);\n    assert(results[2] == 1);\n    \n    // Test with single node tree\n    count = 0;\n    postorderTraversal(&n2, visit);\n    assert(results[0] == 2);\n\n    // Test with NULL\n    count = 0;\n    postorderTraversal(NULL, visit);\n    assert(count == 0); // Count should remain 0 as there are no nodes to visit\n\n    // Test with right skewed tree\n    struct TreeNode n4 = {4, NULL, NULL};\n    struct TreeNode n5 = {5, NULL, NULL};\n    n3.right = &n4;\n    n4.right = &n5;\n\n    count = 0;\n    // Expected postorder: 2, 4, 5, 3, 1\n    postorderTraversal(&n1, visit);\n    assert(results[0] == 2);\n    assert(results[1] == 5);\n    assert(results[2] == 4);\n    assert(results[3] == 3);\n    assert(results[4] == 1);\n}\n\nint main() {\n    test();\n    return 0;\n}\n\n"}
{"language": "c", "domain": "algorithm", "source": "人工提问+gpt4生成代码+人工筛选；源文件地址/data/xw/c++dataset/1.6/copy/algro/21.c", "prompt": "\n/*\n功能说明：将一个正整数分解质因数。\n输入参数：整数n（n>1）\n返回值：无返回值，直接打印分解结果。\n*/\n\nvoid factorize(int n);\n\n", "solution": "\n#include <stdio.h>\n\nvoid factorize(int n) {\n    int i = 2;\n    printf(\"%d=\", n);\n    while (i <= n) {\n        if (n % i == 0) {\n            printf(\"%d\", i);\n            n /= i;\n            if (n > 1) {\n                printf(\"*\");\n            }\n        } else {\n            i++;\n        }\n    }\n}\n\n", "test": "\n#include <assert.h>\n\n// 由于分解质因数结果不易用assert直接验证，我们转而验证分解后的质因数乘积是否等于原数\nvoid test() {\n    int n = 90;\n    int factors[] = {2, 3, 3, 5}; // 90的质因数\n    int product = 1;\n    for (int i = 0; i < sizeof(factors)/sizeof(factors[0]); i++) {\n        product *= factors[i];\n    }\n    assert(product == n);\n\n    n = 28;\n    int factors2[] = {2, 2, 7}; // 28的质因数\n    product = 1;\n    for (int i = 0; i < sizeof(factors2)/sizeof(factors2[0]); i++) {\n        product *= factors2[i];\n    }\n    assert(product == n);\n\n    n = 29;\n    int factors3[] = {29}; // 29的质因数\n    product = 1;\n    for (int i = 0; i < sizeof(factors3)/sizeof(factors3[0]); i++) {\n        product *= factors3[i];\n    }\n    assert(product == n);\n\n    n = 131;\n    int factors4[] = {131}; // 131的质因数\n    product = 1;\n    for (int i = 0; i < sizeof(factors4)/sizeof(factors4[0]); i++) {\n        product *= factors4[i];\n    }\n    assert(product == n);\n\n    n = 1001;\n    int factors5[] = {7, 11, 13}; // 1001的质因数\n    product = 1;\n    for (int i = 0; i < sizeof(factors5)/sizeof(factors5[0]); i++) {\n        product *= factors5[i];\n    }\n    assert(product == n);\n}\n\nint main() {\n    test(); // 运行测试\n    return 0;\n}\n\n"}
{"language": "c", "domain": "algorithm", "source": "人工提问+gpt4生成代码+人工筛选；源文件地址/data/xw/c++dataset/1.6/copy/algro/2.c", "prompt": "#include <stdio.h>\n\n/* 实现一个计算子网掩码有效主机数量的函数\n输入参数为子网掩码的位数（如24表示子网掩码为255.255.255.0）\n函数格式定义为：int calculateHosts(int maskBits)\nmaskBits表示子网掩码中1的位数\n返回值为该子网掩码下的有效主机数量（网络地址和广播地址除外）\n*/\n\n", "solution": "\nint calculateHosts(int maskBits) {\nif (maskBits <= 0 || maskBits >= 32) {\nreturn -1; // 返回-1表示输入不合法\n}\nreturn (1 << (32 - maskBits)) - 2; // 2的(32-maskBits)次幂减去2（网络地址和广播地址）\n}\n\n", "test": "\n#include <assert.h>\n\nint main() {\nassert(calculateHosts(24) == 254); // 255.255.255.0有254个可用IP地址\nassert(calculateHosts(25) == 126); // 255.255.255.128有126个可用IP地址\nassert(calculateHosts(30) == 2);   // 255.255.255.252有2个可用IP地址\nassert(calculateHosts(32) == -1);  // 不合法的输入\nassert(calculateHosts(0) == -1);   // 不合法的输入\n\nreturn 0;\n}\n"}
{"language": "c", "domain": "algorithm", "source": "人工提问+gpt4生成代码+人工筛选；源文件地址/data/xw/c++dataset/1.6/copy/algro/60.c", "prompt": "\n/*\n功能说明：给定一个字符串数组和一个长字符串，判断数组中的每个字符串是否为长字符串的子串。\n输入参数：\n- char* p[]: 字符串数组。\n- int n: 字符串数组中字符串的个数。\n- char* s: 长字符串。\n\n返回值：返回一个 bool 数组，每个元素对应字符串数组中的字符串是否为长字符串的子串。\n*/\n\n#include <stdbool.h>\n\nbool* isSubstring(char* p[], int n, char* s);\n\n", "solution": "\n#include <string.h>\n#include <stdlib.h>\n\nbool* isSubstring(char* p[], int n, char* s) {\n    bool* results = (bool*)malloc(n * sizeof(bool));\n    for (int i = 0; i < n; i++) {\n        if (strstr(s, p[i]) != NULL) {\n            results[i] = true;\n        } else {\n            results[i] = false;\n        }\n    }\n    return results;\n}\n\n", "test": "#include <assert.h>\n\nvoid test() {\n    char* patterns[] = {\"a\", \"b\", \"c\", \"d\"};\n    char* s = \"abc\";\n    bool* results = isSubstring(patterns, 4, s);\n    bool expected[] = {true, true, true, false};\n\n    for (int i = 0; i < 4; i++) {\n        assert(results[i] == expected[i]);\n    }\n    \n    free(results);\n}\n\nint main() {\n    test();\n    return 0;\n}\n\n"}
{"language": "c", "domain": "algorithm", "source": "人工提问+gpt4生成代码+人工筛选；源文件地址/data/xw/c++dataset/1.6/copy/algro/29.c", "prompt": "\n/*\n功能说明：逆序存放一维数组的元素。\n输入参数：int arr[] 要逆序的数组, int length 数组的长度\n返回值：无返回值，但数组arr[]将被原地逆序。\n*/\n\nvoid reverseArray(int arr[], int length);\n\n", "solution": "\nvoid reverseArray(int arr[], int length) {\n    int temp;\n    for (int i = 0; i < length / 2; ++i) {\n        temp = arr[i];\n        arr[i] = arr[length - 1 - i];\n        arr[length - 1 - i] = temp;\n    }\n}\n\n", "test": "\n#include <assert.h>\n#include <stdbool.h>\n\nbool arraysEqual(int *arr1, int *arr2, int length) {\n    for (int i = 0; i < length; i++) {\n        if (arr1[i] != arr2[i]) {\n            return false;\n        }\n    }\n    return true;\n}\n\nvoid test() {\n    int arr1[5] = {1, 2, 3, 4, 5};\n    int expected1[5] = {5, 4, 3, 2, 1};\n    reverseArray(arr1, 5);\n    assert(arraysEqual(arr1, expected1, 5));\n\n    int arr2[4] = {1, 2, 3, 4};\n    int expected2[4] = {4, 3, 2, 1};\n    reverseArray(arr2, 4);\n    assert(arraysEqual(arr2, expected2, 4));\n\n    int arr3[1] = {1};\n    int expected3[1] = {1};\n    reverseArray(arr3, 1);\n    assert(arraysEqual(arr3, expected3, 1));\n\n    int arr4[6] = {10, 20, 30, 40, 50, 60};\n    int expected4[6] = {60, 50, 40, 30, 20, 10};\n    reverseArray(arr4, 6);\n    assert(arraysEqual(arr4, expected4, 6));\n\n    int arr5[0] = {};\n    int expected5[0] = {};\n    reverseArray(arr5, 0);\n    assert(arraysEqual(arr5, expected5, 0));\n}\n\nint main() {\n    test(); // 运行测试\n    return 0;\n}\n\n"}
{"language": "c", "domain": "algorithm", "source": "人工提问+gpt4生成代码+人工筛选；源文件地址/data/xw/c++dataset/1.6/copy/algro/51.c", "prompt": "\n/*\n功能说明：将罗马数字转化为整数。\n输入参数：\n- char * s: 罗马数字字符串。\n\n返回值：对应的整数值。\n*/\n\nint romanToInt(char * s);\n\n", "solution": "\nint romanToInt(char * s) {\n    int nums[256] = {0};\n    nums['I'] = 1;\n    nums['V'] = 5;\n    nums['X'] = 10;\n    nums['L'] = 50;\n    nums['C'] = 100;\n    nums['D'] = 500;\n    nums['M'] = 1000;\n\n    int result = 0;\n    for (int i = 0; s[i] != '\\0'; i++) {\n        if (nums[s[i]] < nums[s[i+1]]) {\n            result -= nums[s[i]];\n        } else {\n            result += nums[s[i]];\n        }\n    }\n\n    return result;\n}\n\n", "test": "\n#include <assert.h>\n\nvoid test() {\n    // Test case 1\n    assert(romanToInt(\"III\") == 3);\n\n    // Test case 2\n    assert(romanToInt(\"IV\") == 4);\n\n    // Test case 3\n    assert(romanToInt(\"IX\") == 9);\n\n    // Test case 4\n    assert(romanToInt(\"LVIII\") == 58);\n\n    // Test case 5\n    assert(romanToInt(\"MCMXCVI\") == 1996);\n}\n\nint main() {\n    test();\n    return 0;\n}\n\n"}
{"language": "c", "domain": "algorithm", "source": "人工提问+gpt4生成代码+人工筛选；源文件地址/data/xw/c++dataset/1.6/copy/algro/23.c", "prompt": "\n/*\n功能说明：判断一个整数是否为完数。\n输入参数：整数n (n > 0)\n返回值：如果n是完数，返回1；否则返回0。\n*/\n\nint isPerfect(int n);\n\n", "solution": "\nint isPerfect(int n) {\n    int sum = 0;\n    for (int i = 1; i < n; i++) { // 只需要遍历到n-1即可\n        if (n % i == 0) {\n            sum += i;\n        }\n    }\n    if (sum == n) {\n        return 1; // n是完数\n    } else {\n        return 0; // n不是完数\n    }\n}\n\n", "test": "\n#include <assert.h>\n\nvoid test() {\n    assert(isPerfect(6) == 1); // 6是完数\n    assert(isPerfect(28) == 1); // 28是完数\n    assert(isPerfect(496) == 1); // 496是完数\n    assert(isPerfect(8128) == 1); // 8128是完数\n    assert(isPerfect(2) == 0); // 2不是完数\n}\n\nint main() {\n    test(); // 运行测试\n    return 0;\n}\n\n"}
{"language": "c", "domain": "algorithm", "source": "人工提问+gpt4生成代码+人工筛选；源文件地址/data/xw/c++dataset/1.6/copy/algro/32.c", "prompt": "\n/*\n功能说明：判断给定的年份是否是闰年。\n输入参数：年份year。\n返回值：如果是闰年返回1，否则返回0。\n*/\n\nint isLeapYear(int year);\n\n", "solution": "\nint isLeapYear(int year) {\n    if (year % 4 == 0) {\n        if (year % 100 == 0) {\n            if (year % 400 == 0) {\n                return 1; // Divisible by 400, leap year.\n            } else {\n                return 0; // Divisible by 100 but not by 400, not a leap year.\n            }\n        } else {\n            return 1; // Divisible by 4 but not by 100, leap year.\n        }\n    } else {\n        return 0; // Not divisible by 4, not a leap year.\n    }\n}\n\n", "test": "\n#include <assert.h>\n\nvoid test() {\n    assert(isLeapYear(2000) == 1); // Divisible by 400, leap year.\n    assert(isLeapYear(1900) == 0); // Divisible by 100 but not by 400, not a leap year.\n    assert(isLeapYear(2004) == 1); // Divisible by 4 but not by 100, leap year.\n    assert(isLeapYear(2001) == 0); // Not divisible by 4, not a leap year.\n    assert(isLeapYear(2400) == 1); // A future year divisible by 400, leap year.\n}\n\nint main() {\n    test(); // 运行测试\n    return 0;\n}\n\n"}
{"language": "c", "domain": "algorithm", "source": "人工提问+gpt4生成代码+人工筛选；源文件地址/data/xw/c++dataset/1.6/copy/algro/27.c", "prompt": "\n/*\n功能说明：计算区间[a, b)内不能被3整除的整数的和。\n输入参数：整数a和b，其中a <= b。\n返回值：返回计算得到的和。\n*/\n\nint sumNonDivisibleBy3(int a, int b);\n\n", "solution": "\nint sumNonDivisibleBy3(int a, int b) {\n    int sum = 0;\n    for (int i = a; i < b; ++i) {\n        if (i % 3 != 0) {\n            sum += i;\n        }\n    }\n    return sum;\n}\n\n", "test": "\n#include <assert.h>\n\nvoid test() {\n    assert(sumNonDivisibleBy3(0, 4) == 3); // 0, 1, 2, 3 -> 1 + 2 = 3\n    assert(sumNonDivisibleBy3(1, 5) == 7); // 1, 2, 3, 4 -> 1 + 2 + 4 = 7\n    assert(sumNonDivisibleBy3(3, 3) == 0); // 没有数字，和为0\n    assert(sumNonDivisibleBy3(10, 16) == 48); // 10, 11, 12, 13, 14, 15 -> 10 + 11 + 13 + 14 = 48\n    assert(sumNonDivisibleBy3(-5, 1) == -12); // -5, -4, -3, -2, -1, 0 -> -5 + -4 + -2 + -1 = -12\n}\n\nint main() {\n    test(); // 运行测试\n    return 0;\n}\n\n"}
{"language": "c", "domain": "algorithm", "source": "人工提问+gpt4生成代码+人工筛选；源文件地址/data/xw/c++dataset/1.6/copy/algro/14.c", "prompt": "\n/* 检查一个数是否是水仙花数\n功能说明：检查一个整数n（仅限于三位数）是否是一个水仙花数\n输入参数：整数n\n返回值：如果n是水仙花数返回1，不是水仙花数返回0\n*/\n\nint isNarcissisticNumber(int n);\n\n", "solution": "\nint isNarcissisticNumber(int n) {\n    if (n < 100 || n > 999) return 0; // 水仙花数只能是三位数\n\n    int original = n;\n    int sum = 0;\n    while (n > 0) {\n        int digit = n % 10;\n        sum += digit * digit * digit;\n        n /= 10;\n    }\n\n    return sum == original;\n}\n\n", "test": "\n#include <assert.h>\n\nvoid test() {\n    assert(isNarcissisticNumber(153) == 1); // 153是水仙花数\n    assert(isNarcissisticNumber(370) == 1); // 370是水仙花数\n    assert(isNarcissisticNumber(371) == 1); // 371是水仙花数\n    assert(isNarcissisticNumber(123) == 0); // 123不是水仙花数\n    assert(isNarcissisticNumber(9474) == 0); // 9474不是三位数，因此不是水仙花数\n}\n\nint main() {\n    test(); // 运行测试\n    return 0;\n}\n\n"}
{"language": "c", "domain": "algorithm", "source": "人工提问+gpt4生成代码+人工筛选；源文件地址/data/xw/c++dataset/1.6/copy/algro/28.c", "prompt": "\n/*\n功能说明：计算区间[a, b)内所有自然数中偶数的和。\n输入参数：整数a和b，其中a <= b。\n返回值：返回区间内所有偶数的和。\n*/\n\nint sumEvensInRange(int a, int b);\n\n", "solution": "\nint sumEvensInRange(int a, int b) {\n    int sum = 0;\n    // 如果a是奇数，从下一个偶数开始累加\n    if (a % 2 != 0) {\n        a++;\n    }\n    for (int i = a; i < b; i += 2) {\n        sum += i;\n    }\n    return sum;\n}\n\n", "test": "\n#include <assert.h>\n\nvoid test() {\n    assert(sumEvensInRange(0, 5) == 6);   // 0, 2, 4 -> 和为6\n    assert(sumEvensInRange(1, 5) == 6);   // 2, 4 -> 和为6\n    assert(sumEvensInRange(5, 5) == 0);   // 没有偶数，和为0\n    assert(sumEvensInRange(2, 10) == 20); // 2, 4, 6, 8 -> 和为20\n    assert(sumEvensInRange(-3, 4) == 0);  // -2, 0, 2 -> 和为0 (自然数从1开始，所以负数不计算在内)\n}\n\nint main() {\n    test(); // 运行测试\n    return 0;\n}\n\n"}
{"language": "c", "domain": "algorithm", "source": "人工提问+gpt4生成代码+人工筛选；源文件地址/data/xw/c++dataset/1.6/copy/algro/53.c", "prompt": "\n/*\n功能说明：判断给定的二叉树是否是平衡二叉树。\n输入参数：\n- struct TreeNode* root: 指向树根结点的指针。\n\n返回值：如果二叉树是平衡的，则返回true，否则返回false。\n定义结构体TreeNode表示树的节点。\n*/\n#include <stddef.h>\n#include <stdbool.h>\n#include <math.h>\nstruct TreeNode {\n    int val;\n    struct TreeNode *left;\n    struct TreeNode *right;\n};\n\nbool isBalanced(struct TreeNode* root);\n\n", "solution": "\nint height(struct TreeNode* node) {\n    if (node == NULL) return 0;\n    int leftHeight = height(node->left);\n    if (leftHeight == -1) return -1; // 不平衡状态传递\n    int rightHeight = height(node->right);\n    if (rightHeight == -1) return -1; // 不平衡状态传递\n\n    if (abs(leftHeight - rightHeight) > 1) return -1; // 当前节点不平衡\n    return fmax(leftHeight, rightHeight) + 1; // 返回当前节点的高度\n}\n\nbool isBalanced(struct TreeNode* root) {\n    return height(root) != -1;\n}\n\n", "test": "\n#include <assert.h>\n#include <stdlib.h>\n\nstruct TreeNode* newNode(int val) {\n    struct TreeNode* node = (struct TreeNode*) malloc(sizeof(struct TreeNode));\n    node->val = val;\n    node->left = NULL;\n    node->right = NULL;\n    return node;\n}\n\nvoid test() {\n    // Test case 1: Balanced binary tree\n    struct TreeNode* root1 = newNode(1);\n    root1->left = newNode(2);\n    root1->right = newNode(2);\n    root1->left->left = newNode(3);\n    root1->left->right = newNode(3);\n    root1->left->left->left = newNode(4);\n    root1->left->left->right = newNode(4);\n    assert(isBalanced(root1) == false);\n\n    // Test case 2: Completely unbalanced binary tree\n    struct TreeNode* root2 = newNode(1);\n    root2->right = newNode(2);\n    root2->right->right = newNode(3);\n    assert(isBalanced(root2) == false);\n\n    // Test case 3: Only one node\n    struct TreeNode* root3 = newNode(1);\n    assert(isBalanced(root3) == true);\n\n    // Test case 4: Two nodes, balanced\n    struct TreeNode* root4 = newNode(1);\n    root4->left = newNode(2);\n    assert(isBalanced(root4) == true);\n\n    // Test case 5: Balanced binary tree of height 3\n    struct TreeNode* root5 = newNode(1);\n    root5->left = newNode(2);\n    root5->right = newNode(2);\n    root5->left->left = newNode(3);\n    root5->left->right = newNode(3);\n    assert(isBalanced(root5) == true);\n}\n\nint main() {\n    test();\n    return 0;\n}\n\n"}
{"language": "c", "domain": "algorithm", "source": "人工提问+gpt4生成代码+人工筛选；源文件地址/data/xw/c++dataset/1.6/copy/algro/55.c", "prompt": "\n/*\n功能说明：将0到1之间的实数转换成32位以内的二进制字符串表示。\n输入参数：\n- double num: 需要转换的实数，范围是0到1之间（不包括0和1）。\n\n返回值：如果能在32位以内表示出其二进制值，则返回该二进制字符串；否则返回字符串\"Error\"。\n*/\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\nchar* realNumberToBinaryString(double num);\n\n", "solution": "\nchar* realNumberToBinaryString(double num) {\n    if (num <= 0 || num >= 1) {\n        return \"Error\";\n    }\n\n    static char binary[33];\n    binary[0] = '0';\n    binary[1] = '.';\n    int i = 2;\n    double frac = 0.5;\n\n    while (num > 0) {\n        if (i >= 32) {\n            return \"Error\";\n        }\n\n        if (num >= frac) {\n            binary[i++] = '1';\n            num -= frac;\n        } else {\n            binary[i++] = '0';\n        }\n\n        frac /= 2;\n    }\n\n    binary[i] = '\\0';\n    return binary;\n}\n\n", "test": "\n#include <assert.h>\n#include <string.h>\n\nvoid test() {\n    // Test case 1\n    assert(strcmp(realNumberToBinaryString(0.625), \"0.101\") == 0);\n\n    // Test case 2\n    assert(strcmp(realNumberToBinaryString(0.1), \"Error\") == 0);\n\n    // Test case 3\n    assert(strcmp(realNumberToBinaryString(0.5), \"0.1\") == 0);\n\n    // Test case 4\n    assert(strcmp(realNumberToBinaryString(0.75), \"0.11\") == 0);\n\n    // Test case 5\n    assert(strcmp(realNumberToBinaryString(0.875), \"0.111\") == 0);\n}\n\nint main() {\n    test();\n    return 0;\n}\n\n"}
{"language": "c", "domain": "algorithm", "source": "人工提问+gpt4生成代码+人工筛选；源文件地址/data/xw/c++dataset/1.6/copy/algro/6.c", "prompt": "#include <stdio.h>\n#include <string.h>\n\n/* 实现一个字符串数组按字典顺序排序的函数\n输入参数为字符串数组和数组中字符串的数量\n函数格式定义为：void dictionarySort(char *strArray[], int length)\nstrArray表示字符串数组，每个元素是一个指向字符的指针\nlength表示数组中字符串的数量\n函数不返回任何值，直接在输入的数组上进行排序操作\n*/\n\n", "solution": "\nvoid dictionarySort(char *strArray[], int length) {\nint i, j;\nchar *temp;\n\nfor (i = 0; i < length - 1; i++) {\n    int minIndex = i;\n    for (j = i + 1; j < length; j++) {\n        if (strcmp(strArray[j], strArray[minIndex]) < 0) {\n            minIndex = j;\n        }\n    }\n\n    // 交换数组中的两个字符串\n    if (minIndex != i) {\n        temp = strArray[i];\n        strArray[i] = strArray[minIndex];\n        strArray[minIndex] = temp;\n    }\n}\n}\n\n", "test": "\n#include <assert.h>\n\nint main() {\nchar *testStrArray[] = {\"banana\", \"apple\", \"cherry\"};\nchar *sortedStrArray[] = {\"apple\", \"banana\", \"cherry\"};\n\ndictionarySort(testStrArray, 3);\n\n// 验证排序后的数组是否正确\nfor (int i = 0; i < 3; ++i) {\n    assert(strcmp(testStrArray[i], sortedStrArray[i]) == 0);\n}\n\nprintf(\"All tests passed.\\n\"); // 如果所有测试都通过，则打印消息\n\nreturn 0;\n}\n\n"}
{"language": "c", "domain": "algorithm", "source": "人工提问+gpt4生成代码+人工筛选；源文件地址/data/xw/c++dataset/1.6/copy/algro/44.c", "prompt": "\n/*\n功能说明：给定一个 m x n 矩阵，如果一个元素为 0，则将其所在行和列的所有元素都设为 0。请使用原地算法进行操作。\n输入参数：\n- int** matrix: 二维整数数组的指针，指向 m x n 矩阵\n- int matrixRowSize: 矩阵的行数\n- int matrixColSize: 矩阵的列数\n\n注意：需要直接修改输入的矩阵数组。\n*/\n\nvoid setZeroes(int** matrix, int matrixRowSize, int matrixColSize);\n\n", "solution": "\nvoid setZeroes(int** matrix, int matrixRowSize, int matrixColSize) {\n    int col0 = 1;\n    for (int i = 0; i < matrixRowSize; i++) {\n        if (matrix[i][0] == 0) col0 = 0;\n        for (int j = 1; j < matrixColSize; j++) {\n            if (matrix[i][j] == 0) {\n                matrix[i][0] = matrix[0][j] = 0;\n            }\n        }\n    }\n\n    for (int i = matrixRowSize - 1; i >= 0; i--) {\n        for (int j = matrixColSize - 1; j >= 1; j--) {\n            if (matrix[i][0] == 0 || matrix[0][j] == 0) {\n                matrix[i][j] = 0;\n            }\n        }\n        if (col0 == 0) matrix[i][0] = 0;\n    }\n}\n\n", "test": "\n#include <assert.h>\n#include <stdlib.h>\n\nvoid assertMatrix(int** matrix, int** expected, int rowSize, int colSize) {\n    for (int i = 0; i < rowSize; i++) {\n        for (int j = 0; j < colSize; j++) {\n            assert(matrix[i][j] == expected[i][j]);\n        }\n    }\n}\n\nvoid test() {\n    // Example 1\n    int m1[3][3] = {{1, 1, 1}, {1, 0, 1}, {1, 1, 1}};\n    int* matrix1[3] = {m1[0], m1[1], m1[2]};\n    int e1[3][3] = {{1, 0, 1}, {0, 0, 0}, {1, 0, 1}};\n    int* expected1[3] = {e1[0], e1[1], e1[2]};\n    setZeroes(matrix1, 3, 3);\n    assertMatrix(matrix1, expected1, 3, 3);\n\n    // Example 2\n    int m2[3][4] = {{0, 1, 2, 0}, {3, 4, 5, 2}, {1, 3, 1, 5}};\n    int* matrix2[3] = {m2[0], m2[1], m2[2]};\n    int e2[3][4] = {{0, 0, 0, 0}, {0, 4, 5, 0}, {0, 3, 1, 0}};\n    int* expected2[3] = {e2[0], e2[1], e2[2]};\n    setZeroes(matrix2, 3, 4);\n    assertMatrix(matrix2, expected2, 3, 4);\n\n    // Example 3\n    int m3[1][1] = {{0}};\n    int* matrix3[1] = {m3[0]};\n    int e3[1][1] = {{0}};\n    int* expected3[1] = {e3[0]};\n    setZeroes(matrix3, 1, 1);\n    assertMatrix(matrix3, expected3, 1, 1);\n\n    // Example 4\n    int m4[2][2] = {{1, 1}, {0, 1}};\n    int* matrix4[2] = {m4[0], m4[1]};\n    int e4[2][2] = {{0, 1}, {0, 0}};\n    int* expected4[2] = {e4[0], e4[1]};\n    setZeroes(matrix4, 2, 2);\n    assertMatrix(matrix4, expected4, 2, 2);\n\n    // Example 5\n    int m5[3][3] = {{1, 2, 3}, {4, 0, 6}, {7, 8, 9}};\n    int* matrix5[3] = {m5[0], m5[1], m5[2]};\n    int e5[3][3] = {{1, 0, 3}, {0, 0, 0}, {7, 0, 9}};\n    int* expected5[3] = {e5[0], e5[1], e5[2]};\n    setZeroes(matrix5, 3, 3);\n    assertMatrix(matrix5, expected5, 3, 3);\n}\n\nint main() {\n    test();\n    return 0;\n}\n\n"}
{"language": "c", "domain": "algorithm", "source": "人工提问+gpt4生成代码+人工筛选；源文件地址/data/xw/c++dataset/1.6/copy/algro/26.c", "prompt": "\n/*\n功能说明：找出不大于n的最大的能被17整除的自然数。\n输入参数：整数n\n返回值：返回不超过n的最大的能被17整除的数；如果不存在，则返回0。\n*/\n\nint maxDivisibleBy17(int n);\n\n", "solution": "\nint maxDivisibleBy17(int n) {\n    // 检查n是否大于0\n    if (n <= 0) {\n        return 0;\n    }\n    \n    // 从n开始向下查找第一个能被17整除的数\n    for (int i = n; i >= 0; --i) {\n        if (i % 17 == 0) {\n            return i;\n        }\n    }\n    return 0;\n}\n\n", "test": "\n#include <assert.h>\n\nvoid test() {\n    // 测试用例\n    assert(maxDivisibleBy17(0) == 0); // 没有自然数能被17整除\n    assert(maxDivisibleBy17(16) == 0); // 没有小于等于16的数能被17整除\n    assert(maxDivisibleBy17(17) == 17); // 17能被17整除\n    assert(maxDivisibleBy17(34) == 34); // 34能被17整除\n    assert(maxDivisibleBy17(100) == 85); // 85是小于等于100的最大数能被17整除\n}\n\nint main() {\n    test(); // 运行测试\n    return 0;\n}\n\n"}
{"language": "c", "domain": "algorithm", "source": "人工提问+gpt4生成代码+人工筛选；源文件地址/data/xw/c++dataset/1.6/copy/algro/56.c", "prompt": "\n/*\n功能说明：交换一个整数二进制表示中的奇数位和偶数位。\n输入参数：\n- int x: 需要交换奇偶位的整数。\n\n返回值：返回交换奇偶位后的整数。\n*/\n\nint swapOddEvenBits(int x);\n\n", "solution": "\nint swapOddEvenBits(int x) {\n    // 0xAAAAAAAA is a 32-bit number with all even bits set to 1 (101010...10)\n    // 0x55555555 is a 32-bit number with all odd bits set to 1 (010101...01)\n    return ((x & 0xAAAAAAAA) >> 1) | ((x & 0x55555555) << 1);\n}\n\n", "test": "\n#include <assert.h>\n#include <stdio.h>\nvoid test() {\n    // Test case 1: The binary representation of 10 is 1010, swapping odd and even bits gives 0101 which is 5.\n    assert(swapOddEvenBits(10) == 5);\n\n    // Test case 2: The binary representation of 21 is 10101, swapping odd and even bits gives 11010 which is 22.\n    assert(swapOddEvenBits(21) == 42);\n\n    // Test case 3: The binary representation of 2 is 10, swapping odd and even bits gives 01 which is 1.\n    assert(swapOddEvenBits(2) == 1);\n\n    // Test case 4: The binary representation of 0 is 0, swapping odd and even bits still gives 0.\n    assert(swapOddEvenBits(0) == 0);\n\n    // Test case 5: The binary representation of 1 is 1, swapping odd and even bits still gives 1.\n    // Since all the bits except the least significant bit (which is odd) are 0,\n    // the swap doesn't change the number.\n    assert(swapOddEvenBits(1) == 2);\n}\n\nint main() {\n    test();\n    return 0;\n}\n\n"}
{"language": "c", "domain": "algorithm", "source": "人工提问+gpt4生成代码+人工筛选；源文件地址/data/xw/c++dataset/1.6/copy/algro/18.c", "prompt": "\n/* 检查一个整数是否有亲密数,一个整数 X 的全部因子（包括1，不包括 X 本身）之和等于 Y；并且整数 Y 的全部因子（包括1，不包括 Y 本身）之和等于 X ，则将整数 X 和 Y 称为亲密数。\n功能说明：给定整数n，判断它是否有亲密数\n输入参数：整数n\n返回值：如果n有亲密数，则返回其亲密数y，否则返回0\n*/\n\nint findAmicableNumber(int n);\n\n", "solution": "\nint sumOfDivisors(int n) {\n    int sum = 0;\n    for (int i = 1; i <= n / 2; i++) {\n        if (n % i == 0) {\n            sum += i;\n        }\n    }\n    return sum;\n}\n\nint findAmicableNumber(int n) {\n    int y = sumOfDivisors(n); // 求n的因子之和\n    if (y != n && sumOfDivisors(y) == n) {\n        return y; // 如果y的因子之和为n，则n与y亲密\n    }\n    return 0; // 没有找到亲密数\n}\n\n", "test": "\n#include <assert.h>\n\nvoid test() {\n    // 已知亲密数对\n    assert(findAmicableNumber(220) == 284);\n    assert(findAmicableNumber(1184) == 1210);\n    assert(findAmicableNumber(2620) == 2924);\n    assert(findAmicableNumber(5020) == 5564);\n    assert(findAmicableNumber(6232) == 6368);\n    // 非亲密数\n    assert(findAmicableNumber(10) == 0);\n    assert(findAmicableNumber(100) == 0);\n    assert(findAmicableNumber(1000) == 0);\n}\n\nint main() {\n    test(); // 运行测试\n    return 0;\n}\n\n"}
{"language": "c", "domain": "algorithm", "source": "人工提问+gpt4生成代码+人工筛选；源文件地址/data/xw/c++dataset/1.6/copy/algro/7.c", "prompt": "#include <stdio.h>\n\n/* 生成互不相同且无重复数字的三位数\n功能说明：使用1,2,3,4这四个数字，生成所有可能的互不相同且无重复数字的三位数\n函数名：int generateUniqueThreeDigitNumbers()\n参数：无\n返回值：三位数的个数\n*/\n\n", "solution": "\nint generateUniqueThreeDigitNumbers() {\n    int i, j, k;\n    int count=0;\n    for (i = 1; i < 5; i++) { // 可能的百位\n        for (j = 1; j < 5; j++) { // 可能的十位\n            for (k = 1; k < 5; k++) { // 可能的个位\n                if (i != k && i != j && j != k) { // 确保i、j、k三位互不相同\n                count+=1;\n                }\n            }\n        }\n    }\n    return count;\n}\n\n", "test": "\n#include <assert.h>\n\nint main() {\n\n    int count=generateUniqueThreeDigitNumbers();\n    assert(count == 24);\n\n    return 0;\n}\n\n"}
{"language": "c", "domain": "algorithm", "source": "人工提问+gpt4生成代码+人工筛选；源文件地址/data/xw/c++dataset/1.6/copy/algro/8.c", "prompt": "\n/* 判断一个数是否为回文数\n功能说明：判断一个整数是否从左到右读和从右到左读是一样的\n输入参数：一个整数num\n返回值：如果是回文数返回true，否则返回false\n*/\n#include <stdbool.h>\nbool isPalindrome(int num);\n", "solution": "\nbool isPalindrome(int num) {\n    if (num < 0) num = -num; // 按照传统定义，回文数不包括负数，这里将其转为正数处理，可根据需求调整\n    int reversed = 0, original = num, remainder;\n    \n    while (num > 0) {\n        remainder = num % 10;\n        reversed = reversed * 10 + remainder;\n        num /= 10;\n    }\n\n    return original == reversed;\n}\n\n", "test": "\n#include <assert.h>\n\nvoid test() {\n    assert(isPalindrome(12321) == true); // 12321是回文数\n    assert(isPalindrome(12531) == false); // 12531不是回文数\n    assert(isPalindrome(0) == true); // 0是回文数\n    assert(isPalindrome(-121) == true); // -121视为不是回文数\n    assert(isPalindrome(123454321) == true); // 123454321是回文数\n}\n\nint main() {\n    test(); // 运行测试\n    return 0;\n}\n\n"}
{"language": "c", "domain": "algorithm", "source": "人工提问+gpt4生成代码+人工筛选；源文件地址/data/xw/c++dataset/1.6/copy/algro/48.c", "prompt": "\n/*\n功能说明：使用就地算法删除数组中所有等于给定值的元素，并返回新数组的长度。\n输入参数：\n- int* nums: 一个整数数组。\n- int numsSize: 数组的长度。\n- int val: 要删除的目标值。\n\n返回值：处理后数组的新长度。\n*/\n\nint removeElement(int* nums, int numsSize, int val);\n\n", "solution": "\nint removeElement(int* nums, int numsSize, int val) {\n    int i = 0;\n    for (int j = 0; j < numsSize; j++) {\n        if (nums[j] != val) {\n            nums[i] = nums[j];\n            i++;\n        }\n    }\n    return i;\n}\n\n", "test": "\n#include <assert.h>\n\nvoid test() {\n    // Test case 1\n    int nums1[] = {3, 2, 2, 3};\n    int len1 = removeElement(nums1, 4, 3);\n    assert(len1 == 2);\n\n    // Test case 2\n    int nums2[] = {0, 1, 2, 2, 3, 0, 4, 2};\n    int len2 = removeElement(nums2, 8, 2);\n    assert(len2 == 5);\n\n    // Test case 3\n    int nums3[] = {1, 2, 3, 4, 5};\n    int len3 = removeElement(nums3, 5, 4);\n    assert(len3 == 4);\n\n    // Test case 4\n    int nums4[] = {1};\n    int len4 = removeElement(nums4, 1, 1);\n    assert(len4 == 0);\n\n    // Test case 5\n    int nums5[] = {2, 3, 3};\n    int len5 = removeElement(nums5, 3, 3);\n    assert(len5 == 1);\n}\n\nint main() {\n    test();\n    return 0;\n}\n\n"}
{"language": "c", "domain": "algorithm", "source": "人工提问+gpt4生成代码+人工筛选；源文件地址/data/xw/c++dataset/1.6/copy/algro/57.c", "prompt": "\n/*\n功能说明：判断直角坐标系上的两条直线是否会相交（重合也算相交）。\n输入参数：\n- double s1: 直线1的斜率。\n- double s2: 直线2的斜率。\n- double y1: 直线1的截距。\n- double y2: 直线2的截距。\n\n返回值：如果两条直线会相交（包括重合）则返回 true，否则返回 false。\n*/\n\n#include <stdbool.h>\n\nbool willIntersect(double s1, double s2, double y1, double y2);\n\n", "solution": "\nbool willIntersect(double s1, double s2, double y1, double y2) {\n    // 如果斜率不同，直线一定相交\n    // 如果斜率相同，但截距不同，直线平行不相交\n    // 如果斜率相同，且截距也相同，直线重合\n    return s1 != s2 || y1 == y2;\n}\n\n", "test": "\n#include <assert.h>\n#include <math.h>\nvoid test() {\n    // Test case 1: Same slope, different intercepts, lines are parallel and do not intersect.\n    assert(willIntersect(3.14, 3.14, 1, 2) == false);\n\n    // Test case 2: Different slopes, lines do intersect.\n    assert(willIntersect(2.0, 3.0, 1, 2) == true);\n\n    // Test case 3: Same slope, same intercepts, lines coincide.\n    assert(willIntersect(2.0, 2.0, 3, 3) == true);\n\n    // Test case 4: One line is vertical (slope is infinite), and the other is not vertical, they intersect.\n    assert(willIntersect(INFINITY, 1.5, 0, 0) == true);\n\n    // Test case 5: Both lines are vertical and have different intercepts, they do not intersect.\n    assert(willIntersect(INFINITY, INFINITY, 1, 2) == false);\n}\n\nint main() {\n    test();\n    return 0;\n}\n\n"}
{"language": "c", "domain": "algorithm", "source": "人工提问+gpt4生成代码+人工筛选；源文件地址/data/xw/c++dataset/1.6/copy/algro/16.c", "prompt": "\n/* 求杨辉三角第n行第n/2位置的值\n功能说明：给定行数n，返回杨辉三角第n行第n/2位置的值\n输入参数：整数n\n返回值：第n行第n/2位置的值\n*/\n\nint pascalTriangleValue(int n);\n\n", "solution": "\nint pascalTriangleValue(int n) {\n    if (n % 2 != 0) {\n        // n/2位置仅适用于偶数行\n        return -1;\n    }\n  \n    int index = n / 2; // 我们需要找到的位置\n    int value = 1;     // 杨辉三角的第一位置总是1\n\n    // 用组合数公式计算第n行第index位置的值\n    for (int i = 1; i <= index; i++) {\n        value = value * (n - i) / i;\n    }\n\n    return value;\n}\n\n", "test": "\n#include <assert.h>\n#include <stdio.h>\n\nvoid test() {\n    // 注意：杨辉三角的行数从0开始，因此第n行实际上是人类通常所说的第n+1行\n    assert(pascalTriangleValue(2) == 1); // 第2行的中间值是1\n    // printf(\"%d,%d,%d,%d\",pascalTriangleValue(4),pascalTriangleValue(6),pascalTriangleValue(8),pascalTriangleValue(10));\n    assert(pascalTriangleValue(4) == 3); // 第4行的中间位置的值是6\n    assert(pascalTriangleValue(6) == 10); // 第6行的中间位置的值是20\n    assert(pascalTriangleValue(8) == 35); // 第8行的中间位置的值是70\n    assert(pascalTriangleValue(10) == 126); // 第10行的中间位置的值是252\n    // 当输入非偶数行时，返回-1\n    assert(pascalTriangleValue(5) == -1); // 第5行没有中间位置，函数设定返回-1\n}\n\nint main() {\n    test(); // 运行测试\n    return 0;\n}\n\n"}
{"language": "c", "domain": "algorithm", "source": "人工提问+gpt4生成代码+人工筛选；源文件地址/data/xw/c++dataset/1.6/copy/algro/59.c", "prompt": "\n/*\n功能说明：给定一个整数数组，找出数组中每个元素比它大的下一个元素，若不存在则为-1。\n输入参数：\n- int A[]: 给定的整数数组。\n- int n: 数组中的元素个数。\n\n返回值：返回一个新的整数数组，其中每个元素代表原数组中对应元素后面第一个较大的元素。\n*/\n#include <stdlib.h>\nint* nextGreaterElement(int A[], int n);\n\n", "solution": "\nint* nextGreaterElement(int A[], int n) {\n    int* result = (int*)malloc(n * sizeof(int));\n    for (int i = 0; i < n; i++) {\n        result[i] = -1;\n        for (int j = i + 1; j < n; j++) {\n            if (A[j] > A[i]) {\n                result[i] = A[j];\n                break;\n            }\n        }\n    }\n    return result;\n}\n\n", "test": "\n#include <assert.h>\n#include <stdlib.h>\n\nvoid test() {\n    // Test case 1\n    int A1[] = {11, 13, 10, 5, 12, 21, 3};\n    int* result1 = nextGreaterElement(A1, 7);\n    int expected1[] = {13, 21, 12, 12, 21, -1, -1};\n    for (int i = 0; i < 7; i++) {\n        assert(result1[i] == expected1[i]);\n    }\n    free(result1);\n\n    // Test case 2\n    int A2[] = {4, 5, 2, 25};\n    int* result2 = nextGreaterElement(A2, 4);\n    int expected2[] = {5, 25, 25, -1};\n    for (int i = 0; i < 4; i++) {\n        assert(result2[i] == expected2[i]);\n    }\n    free(result2);\n\n    // Test case 3\n    int A3[] = {13, 7, 6, 12};\n    int* result3 = nextGreaterElement(A3, 4);\n    int expected3[] = {-1, 12, 12, -1};\n    for (int i = 0; i < 4; i++) {\n        assert(result3[i] == expected3[i]);\n    }\n    free(result3);\n\n    // Test case 4\n    int A4[] = {6, 7, 4, 3, 5, 2};\n    int* result4 = nextGreaterElement(A4, 6);\n    int expected4[] = {7, -1, 5, 5, -1, -1};\n    for (int i = 0; i < 6; i++) {\n        assert(result4[i] == expected4[i]);\n    }\n    free(result4);\n\n    // Test case 5\n    int A5[] = {1, 2, 3, 4, 5};\n    int* result5 = nextGreaterElement(A5, 5);\n    int expected5[] = {2, 3, 4, 5, -1};\n    for (int i = 0; i < 5; i++) {\n        assert(result5[i] == expected5[i]);\n    }\n    free(result5);\n}\n\nint main() {\n    test();\n    return 0;\n}\n\n"}
{"language": "c", "domain": "algorithm", "source": "人工提问+gpt4生成代码+人工筛选；源文件地址/data/xw/c++dataset/1.6/copy/algro/42.c", "prompt": "\n/*\n功能说明：将两个有序数组合并为一个有序数组。\n输入参数：\n- int* A: 指向第一个有序数组的指针\n- int ASize: 第一个有序数组的元素数量\n- int m: 第一个有序数组的实际元素数量\n- int* B: 指向第二个有序数组的指针\n- int BSize: 第二个有序数组的元素数量（A数组的大小已足够包含B数组）\n- int n: 第二个有序数组的实际元素数量\n注：数组A有足够的空间来存放数组B的元素。\n*/\n\nvoid merge(int* A, int ASize, int m, int* B, int BSize, int n);\n\n", "solution": "\nvoid merge(int* A, int ASize, int m, int* B, int BSize, int n) {\n    int i = m - 1;\n    int j = n - 1;\n    int k = m + n - 1;\n\n    while (i >= 0 && j >= 0) {\n        if (A[i] > B[j]) {\n            A[k--] = A[i--];\n        } else {\n            A[k--] = B[j--];\n        }\n    }\n\n    while (j >= 0) {\n        A[k--] = B[j--];\n    }\n}\n\n", "test": "\n#include <assert.h>\n\nvoid test() {\n    // Example 1\n    int A1[6] = {1, 2, 3, 0, 0, 0};\n    int B1[3] = {2, 5, 6};\n    merge(A1, 6, 3, B1, 3, 3);\n    int expected1[6] = {1, 2, 2, 3, 5, 6};\n    for (int i = 0; i < 6; i++) {\n        assert(A1[i] == expected1[i]);\n    }\n\n    // Example 2\n    int A2[1] = {0};\n    int B2[1] = {1};\n    merge(A2, 1, 0, B2, 1, 1);\n    int expected2[1] = {1};\n    for (int i = 0; i < 1; i++) {\n        assert(A2[i] == expected2[i]);\n    }\n\n    // Example 3\n    int A3[5] = {1, 3, 5, 0, 0};\n    int B3[2] = {2, 4};\n    merge(A3, 5, 3, B3, 2, 2);\n    int expected3[5] = {1, 2, 3, 4, 5};\n    for (int i = 0; i < 5; i++) {\n        assert(A3[i] == expected3[i]);\n    }\n\n    // Example 4\n    int A4[3] = {2, 0, 0};\n    int B4[2] = {1, 3};\n    merge(A4, 3, 1, B4, 2, 2);\n    int expected4[3] = {1, 2, 3};\n    for (int i = 0; i < 3; i++) {\n        assert(A4[i] == expected4[i]);\n    }\n\n    // Example 5\n    int A5[5] = {10, 20, 30, 0, 0};\n    int B5[2] = {25, 35};\n    merge(A5, 5, 3, B5, 2, 2);\n    int expected5[5] = {10, 20, 25, 30, 35};\n    for (int i = 0; i < 5; i++) {\n        assert(A5[i] == expected5[i]);\n    }\n}\n\nint main() {\n    test();\n    return 0;\n}\n\n"}
{"language": "c", "domain": "algorithm", "source": "人工提问+gpt4生成代码+人工筛选；源文件地址/data/xw/c++dataset/1.6/copy/algro/49.c", "prompt": "\n/*\n功能说明：判断给出的字符串是否是合法的括号序列。\n输入参数：\n- char * s: 一个仅包含字符'(',')','{','}','['和']'的字符串。\n\n返回值：如果字符串是合法的括号序列，则返回1，否则返回0。\n*/\n#include <stdlib.h>\n#include <string.h>\nint isValid(char * s);\n\n", "solution": "\nint isValid(char * s) {\n    int len = strlen(s);\n    char *stack = (char *)malloc(len + 1);\n    int top = -1;\n\n    for (int i = 0; s[i] != '\\0'; i++) {\n        char c = s[i];\n        switch (c) {\n            case '(':\n            case '[':\n            case '{':\n                stack[++top] = c;\n                break;\n            case ')':\n                if (top == -1 || stack[top] != '(') return 0;\n                else top--;\n                break;\n            case ']':\n                if (top == -1 || stack[top] != '[') return 0;\n                else top--;\n                break;\n            case '}':\n                if (top == -1 || stack[top] != '{') return 0;\n                else top--;\n                break;\n            default:\n                free(stack);\n                return 0;\n        }\n    }\n    int result = top == -1;\n    free(stack);\n    return result;\n}\n\n", "test": "\n#include <assert.h>\n#include <string.h>\n#include <stdlib.h>\n\nvoid test() {\n    // Test case 1\n    assert(isValid(\"()\") == 1); // Example 1\n\n    // Test case 2\n    assert(isValid(\"()[]{}\") == 1); // Example 2\n\n    // Test case 3\n    assert(isValid(\"(]\") == 0); // Example 3\n\n    // Test case 4\n    assert(isValid(\"([)]\") == 0); // Example 4\n\n    // Test case 5\n    assert(isValid(\"{[]}\") == 1); // Example 5\n}\n\nint main() {\n    test();\n    return 0;\n}\n\n"}
{"language": "c", "domain": "algorithm", "source": "人工提问+gpt4生成代码+人工筛选；源文件地址/data/xw/c++dataset/1.6/copy/algro/58.c", "prompt": "\n/*\n功能说明：给定一个整数数组和大小，找出其中连续数列相加的最大和。\n输入参数：\n- int A[]: 给定的整数数组。\n- int n: 数组中的元素个数。\n\n返回值：返回最大的连续数列和。\n*/\n\nint maxSubArray(int A[], int n);\n\n", "solution": "\nint maxSubArray(int A[], int n) {\n    int maxSum = A[0];\n    int currentSum = A[0];\n    \n    for (int i = 1; i < n; i++) {\n        currentSum = currentSum > 0 ? currentSum + A[i] : A[i];\n        maxSum = currentSum > maxSum ? currentSum : maxSum;\n    }\n    \n    return maxSum;\n}\n\n", "test": "\n#include <assert.h>\n\nvoid test() {\n    // Test case 1\n    int A1[] = {1, 2, 3, -6, 1};\n    assert(maxSubArray(A1, 5) == 6);\n\n    // Test case 2\n    int A2[] = {-1, -2, -3, -4};\n    assert(maxSubArray(A2, 4) == -1);\n\n    // Test case 3\n    int A3[] = {1, 2, -1, 2, 3, -5, 4};\n    assert(maxSubArray(A3, 7) == 7);\n\n    // Test case 4\n    int A4[] = {0, -1, 1, 2};\n    assert(maxSubArray(A4, 4) == 3);\n\n    // Test case 5\n    int A5[] = {-2, 1, -3, 4, -1, 2, 1, -5, 4};\n    assert(maxSubArray(A5, 9) == 6);\n}\n\nint main() {\n    test();\n    return 0;\n}\n\n"}
{"language": "c", "domain": "algorithm", "source": "人工提问+gpt4生成代码+人工筛选；源文件地址/data/xw/c++dataset/1.6/copy/algro/47.c", "prompt": "\n/*\n功能说明：给出用数字数组表示的一个非负整数，请对该整数加1。\n输入参数：\n- int* digits: 一个整数数组，每个位置存放一个数字，数组整体表示一个非负整数\n- int digitsSize: 数组的长度\n\n返回值：加1后的整数数组。可能需要重新分配空间以容纳额外的数字。\n*/\n#include <stdlib.h>\nint* plusOne(int* digits, int digitsSize, int* returnSize);\n\n", "solution": "\nint* plusOne(int* digits, int digitsSize, int* returnSize) {\n    for (int i = digitsSize - 1; i >= 0; i--) {\n        if (digits[i] < 9) {\n            digits[i]++;\n            *returnSize = digitsSize;\n            return digits;\n        }\n        digits[i] = 0;\n    }\n    \n    int* result = (int*)malloc((digitsSize + 1) * sizeof(int));\n    result[0] = 1;\n    for (int i = 1; i < digitsSize + 1; i++) {\n        result[i] = 0;\n    }\n    *returnSize = digitsSize + 1;\n    return result;\n}\n\n", "test": "\n#include <assert.h>\n#include <stdlib.h>\n#include <string.h>\n\nvoid test() {\n    // Test case 1\n    int digits1[] = {1};\n    int returnSize1;\n    int* result1 = plusOne(digits1, 1, &returnSize1);\n    int expected1[] = {2};\n    assert(memcmp(result1, expected1, returnSize1 * sizeof(int)) == 0);\n\n    // Test case 2\n    int digits2[] = {1, 2, 3};\n    int returnSize2;\n    int* result2 = plusOne(digits2, 3, &returnSize2);\n    int expected2[] = {1, 2, 4};\n    assert(memcmp(result2, expected2, returnSize2 * sizeof(int)) == 0);\n\n    // Test case 3\n    int digits3[] = {4, 3, 2, 1};\n    int returnSize3;\n    int* result3 = plusOne(digits3, 4, &returnSize3);\n    int expected3[] = {4, 3, 2, 2};\n    assert(memcmp(result3, expected3, returnSize3 * sizeof(int)) == 0);\n\n    // Test case 4\n    int digits4[] = {9};\n    int returnSize4;\n    int* result4 = plusOne(digits4, 1, &returnSize4);\n    int expected4[] = {1, 0};\n    assert(memcmp(result4, expected4, returnSize4 * sizeof(int)) == 0);\n\n    // Test case 5\n    int digits5[] = {9, 9, 9};\n    int returnSize5;\n    int* result5 = plusOne(digits5, 3, &returnSize5);\n    int expected5[] = {1, 0, 0, 0};\n    assert(memcmp(result5, expected5, returnSize5 * sizeof(int)) == 0);\n\n    // Free allocated memory for results that needed more space\n    free(result4);\n    free(result5);\n}\n\nint main() {\n    test();\n    return 0;\n}\n\n"}
{"language": "c", "domain": "algorithm", "source": "人工提问+gpt4生成代码+人工筛选；源文件地址/data/xw/c++dataset/1.6/copy/algro/15.c", "prompt": "\n/* 计算球的落地和反弹距离\n功能说明：计算一球从100米高度自由落下，每次落地后反弹回原高度的一半，\n           在第n次落地时，共经过的距离及第n次反弹的高度。\n输入参数：整数n，表示落地次数\n返回值：无返回值，但通过两个指针参数输出第n次落地时共经过的距离和第n次反弹的高度\n*/\n#include <stdio.h>\nvoid calculateFallAndBounce(int n, float *totalDistance, float *reboundHeight);\n\n", "solution": "\nvoid calculateFallAndBounce(int n, float *totalDistance, float *reboundHeight) {\n    float h = 100; // 初始高度\n    float s = 0;   // 经过的总距离初始化为0，因为开始时球还未落下\n\n    for (int i = 1; i <= n; i++) {\n        s += i == 1 ? h : 2 * h; // 第一次落地距离加100米，之后每次落地加2倍反弹高度\n        h /= 2;                  // 反弹高度减半\n    }\n\n    // 输出结果通过指针参数返回\n    *totalDistance = s;\n    *reboundHeight = h;\n}\n\n", "test": "\n#include <assert.h>\n\nvoid test() {\n    float totalDistance, reboundHeight;\n\n    calculateFallAndBounce(1, &totalDistance, &reboundHeight);\n    assert(totalDistance == 100);\n    assert(reboundHeight == 50);\n\n    calculateFallAndBounce(2, &totalDistance, &reboundHeight);\n    assert(totalDistance == 200);\n    assert(reboundHeight == 25);\n\n    calculateFallAndBounce(3, &totalDistance, &reboundHeight);\n    assert(totalDistance == 250);\n    assert(reboundHeight == 12.5);\n\n    calculateFallAndBounce(5, &totalDistance, &reboundHeight);\n    // printf(\"%f,%f\\n\",totalDistance, reboundHeight);\n    assert(totalDistance == 287.5);\n    assert(reboundHeight == 3.125);\n\n    calculateFallAndBounce(10, &totalDistance, &reboundHeight);\n    // printf(\"%f,%f\\n\",totalDistance, reboundHeight);\n    assert(totalDistance == 299.609375); // 第10次落地时共经过的距离\n    assert(reboundHeight == 0.09765625); // 第10次反弹的高度\n}\n\nint main() {\n    test(); // 运行测试\n    return 0;\n}\n\n"}
{"language": "c", "domain": "algorithm", "source": "人工提问+gpt4生成代码+人工筛选；源文件地址/data/xw/c++dataset/1.6/copy/algro/30.c", "prompt": "\n/*\n功能说明：计算一个正整数的阶乘。\n输入参数：正整数n。\n返回值：返回n的阶乘。\n*/\n\nunsigned long long factorial(int n);\n\n", "solution": "\nunsigned long long factorial(int n) {\n    if (n <= 1) return 1;\n    else return n * factorial(n - 1);\n}\n\n", "test": "\n#include <assert.h>\n\nvoid test() {\n    assert(factorial(1) == 1);          // 1! = 1\n    assert(factorial(2) == 2);          // 2! = 2\n    assert(factorial(3) == 6);          // 3! = 6\n    assert(factorial(4) == 24);         // 4! = 24\n    assert(factorial(5) == 120);        // 5! = 120\n}\n\nint main() {\n    test(); // 运行测试\n    return 0;\n}\n\n"}
{"language": "c", "domain": "algorithm", "source": "人工提问+gpt4生成代码+人工筛选；源文件地址/data/xw/c++dataset/1.6/copy/algro/20.c", "prompt": "\n/* 计算年月日对应的当年第几天\n功能说明：给定年份、月份和日期，返回这一天是这一年的第几天\n输入参数：年year, 月month, 日day\n返回值：这一天是这一年的第几天\n*/\n\nint dayOfYear(int year, int month, int day);\n\n", "solution": "\nint dayOfYear(int year, int month, int day) {\n    int sum, leap;\n    switch (month) {\n        case 1: sum = 0; break;\n        case 2: sum = 31; break;\n        case 3: sum = 59; break;\n        case 4: sum = 90; break;\n        case 5: sum = 120; break;\n        case 6: sum = 151; break;\n        case 7: sum = 181; break;\n        case 8: sum = 212; break;\n        case 9: sum = 243; break;\n        case 10: sum = 273; break;\n        case 11: sum = 304; break;\n        case 12: sum = 334; break;\n        default: return -1; // 输入月份不正确，返回错误标志\n    }\n    sum += day; // 加上天数\n\n    // 判断闰年\n    if ((year % 400 == 0) || (year % 4 == 0 && year % 100 != 0)) leap = 1;\n    else leap = 0;\n\n    // 如果是闰年且月份大于2，加一天\n    if (leap == 1 && month > 2) sum++;\n\n    return sum;\n}\n\n", "test": "\n#include <assert.h>\n\nvoid test() {\n    assert(dayOfYear(2020, 1, 1) == 1); // 2020年1月1日是第1天\n    assert(dayOfYear(2020, 3, 1) == 61); // 闰年2020年3月1日是第61天\n    assert(dayOfYear(2021, 3, 1) == 60); // 非闰年2021年3月1日是第60天\n    assert(dayOfYear(2020, 12, 31) == 366); // 闰年2020年12月31日是第366天\n    assert(dayOfYear(2021, 12, 31) == 365); // 非闰年2021年12月31日是第365天\n}\n\nint main() {\n    test(); // 运行测试\n    return 0;\n}\n\n"}
{"language": "c", "domain": "algorithm", "source": "人工提问+gpt4生成代码+人工筛选；源文件地址/data/xw/c++dataset/1.6/copy/algro/12.c", "prompt": "\n/* 将三个整数由小到大排序\n功能说明：对x, y, z三个整数进行排序，使得x <= y <= z\n输入参数：三个整数指针x, y, z\n返回值：无\n*/\n\nvoid sortAscending(int *x, int *y, int *z);\n\n", "solution": "\nvoid sortAscending(int *x, int *y, int *z) {\n    if (!x || !y || !z) return; // 检查空指针\n\n    int t;\n    if (*x > *y) {\n        t = *x;\n        *x = *y;\n        *y = t;\n    }\n    if (*x > *z) {\n        t = *z;\n        *z = *x;\n        *x = t;\n    }\n    if (*y > *z) {\n        t = *y;\n        *y = *z;\n        *z = t;\n    }\n}\n\n", "test": "\n#include <assert.h>\n\nvoid test() {\n    int a = 34, b = 12, c = 56;\n    sortAscending(&a, &b, &c);\n    assert(a == 12 && b == 34 && c == 56);\n\n    a = 22; b = 44; c = 33;\n    sortAscending(&a, &b, &c);\n    assert(a == 22 && b == 33 && c == 44);\n\n    a = 78; b = 88; c = 68;\n    sortAscending(&a, &b, &c);\n    assert(a == 68 && b == 78 && c == 88);\n\n    a = 2; b = 3; c = 1;\n    sortAscending(&a, &b, &c);\n    assert(a == 1 && b == 2 && c == 3);\n}\n\nint main() {\n    test(); // 运行测试\n    return 0;\n}\n\n"}
{"language": "c", "domain": "algorithm", "source": "人工提问+gpt4生成代码+人工筛选；源文件地址/data/xw/c++dataset/1.6/copy/algro/11.c", "prompt": "\n/* 反转给定的字符串\n功能说明：将输入的字符串s反转\n输入参数：字符指针s，指向要反转的字符串\n返回值：无\n*/\n#include <stddef.h>\nvoid reverse(char* s);\n\n", "solution": "\nvoid reverse(char* s) {\n    if (s == NULL)\n        return;\n\n    // 获取字符串长度\n    int len = 0;\n    char* p = s;\n    while (*p != '\\0') {\n        len++;\n        p++;\n    }\n\n    // 首尾交换字符\n    int i = 0;\n    char c;\n    while (i < len / 2) {\n        c = s[i];\n        s[i] = s[len - 1 - i];\n        s[len - 1 - i] = c;\n        i++;\n    }\n}\n\n", "test": "\n#include <assert.h>\n#include <string.h>\n\nvoid test() {\n    char test1[] = \"chenPiJavaLib\";\n    reverse(test1);\n    assert(strcmp(test1, \"biLavaJiPnehc\") == 0);\n\n    char test2[] = \"hello\";\n    reverse(test2);\n    assert(strcmp(test2, \"olleh\") == 0);\n\n    char test3[] = \"a\";\n    reverse(test3);\n    assert(strcmp(test3, \"a\") == 0);\n\n    char test4[] = \"\";\n    reverse(test4);\n    assert(strcmp(test4, \"\") == 0);\n}\n\nint main() {\n    test(); // 运行测试\n    return 0;\n}\n\n"}
{"language": "c", "domain": "algorithm", "source": "人工提问+gpt4生成代码+人工筛选；源文件地址/data/xw/c++dataset/1.6/copy/algro/33.c", "prompt": "\n/*\n功能说明：判断给定二叉树的最大深度。\n输入参数：指向二叉树根节点的指针root。\n返回值：二叉树的最大深度。\n*/\n#include <stddef.h>\nstruct TreeNode {\n    int val;\n    struct TreeNode *left;\n    struct TreeNode *right;\n};\n\nint maxDepth(struct TreeNode* root);\n\n", "solution": "\nint maxDepth(struct TreeNode* root) {\n    if (root == NULL) {\n        return 0;\n    } else {\n        int left_depth = maxDepth(root->left);\n        int right_depth = maxDepth(root->right);\n        return (left_depth > right_depth ? left_depth : right_depth) + 1;\n    }\n}\n\n", "test": "\n#include <assert.h>\n\nvoid test() {\n    struct TreeNode left = {1, NULL, NULL};\n    struct TreeNode right = {2, NULL, NULL};\n    struct TreeNode root = {3, &left, &right};\n\n    struct TreeNode root2 = {1, NULL, NULL};\n\n    struct TreeNode left21 = {2, NULL, NULL};\n    struct TreeNode right21 = {3, NULL, NULL};\n    struct TreeNode left2 = {1, &left21, &right21};\n    struct TreeNode root3 = {4, &left2, NULL};\n\n    assert(maxDepth(NULL) == 0);                     // An empty tree has depth of 0.\n    assert(maxDepth(&root2) == 1);                   // A tree with only one node has depth of 1.\n    assert(maxDepth(&root) == 2);                    // A tree with two children has depth of 2.\n    assert(maxDepth(&root3) == 3);                   // A tree with three levels has depth of 3.\n    // More complex tree construction could be added here for a deeper tree assertion.\n}\n\nint main() {\n    test(); // 运行测试\n    return 0;\n}\n\n"}
{"language": "c", "domain": "algorithm", "source": "人工提问+gpt4生成代码+人工筛选；源文件地址/data/xw/c++dataset/1.6/copy/algro/9.c", "prompt": "\n/* 生成互不相同且无重复数字的三位数\n功能说明：利用1、2、3、4、5这五个数字，组成互不相同且无重复数字的三位数\n输入参数：无\n返回值：返回这样的三位数的总数\n*/\n\nint generateUniqueThreeDigitNumbers(void);\n\n", "solution": "\nint generateUniqueThreeDigitNumbers(void) {\n    int i, j, k, count = 0;\n\n    for (i = 1; i <= 5; i++) {\n        for (j = 1; j <= 5; j++) {\n            for (k = 1; k <= 5; k++) {\n                if (i != k && i != j && j != k) {\n                    // printf(\"%d%d%d \", i, j, k);  // Uncomment this line to print each unique number\n                    count++;\n                }\n            }\n        }\n    }\n\n    return count;\n}\n\n", "test": "\n#include <assert.h>\n\nvoid test() {\n    // 5*4*3 = 60 unique combinations possible\n    assert(generateUniqueThreeDigitNumbers() == 60); \n}\n\nint main() {\n    test(); // 运行测试\n    return 0;\n}\n\n"}
{"language": "c", "domain": "algorithm", "source": "人工提问+gpt4生成代码+人工筛选；源文件地址/data/xw/c++dataset/1.6/copy/algro/22.c", "prompt": "\n/*\n功能说明：统计输入字符串中英文字母、空格、数字和其它字符的个数。\n输入参数：字符串s 中英文字母、空格、数字和其它字符的个数*letters,  *space, *digit, *others\n返回值：无\n*/\n\nvoid countCharacters(char *s,int *letters, int *space, int *digit, int *others);\n\n", "solution": "\n#include <stdio.h>\n\nvoid countCharacters(char *s,int *letters, int *space, int *digit, int *others) {\n    *letters = 0; *space = 0; *digit = 0; *others = 0;\n    int i = 0;\n    char c;\n\n    while ((c = s[i]) != '\\0') {\n        if ((c >= 'a' && c <= 'z') || (c >= 'A' && c <= 'Z'))\n            (*letters)++;\n        else if (c == ' ')\n            (*space)++;\n        else if (c >= '0' && c <= '9')\n            (*digit)++;\n        else\n            (*others)++;\n        i++;\n    }\n}\n\n", "test": "\n#include <assert.h>\n\nvoid test() {\n    char test1[] = \"Hello World! 123\";\n    char test2[] = \"1234567890\";\n    char test3[] = \"!@#$%^&*()\";\n    char test5[] = \"No Space\";\n    int letters=0, space=0, digit=0, others=0;\n\n    // Assertions to check if the counts are as expected\n    countCharacters(test1,&letters, &space, &digit, &others);\n    assert(letters==10 && space==2 && digit==3 && others==1);\n    // printf(\"%d,%d,%d,%d\\n\",letters, space, digit, others);\n\n    countCharacters(test2,&letters, &space, &digit, &others);\n    assert(letters==0 && space==0 && digit==10 && others==0);\n    // printf(\"%d,%d,%d,%d\\n\",letters, space, digit, others);\n\n    countCharacters(test3,&letters, &space, &digit, &others);\n    assert(letters==0 && space==0 && digit==0 && others==10);\n    // printf(\"%d,%d,%d,%d\\n\",letters, space, digit, others);\n\n    countCharacters(test5,&letters, &space, &digit, &others);\n    assert(letters==7 && space==1 && digit==0 && others==0);\n    // printf(\"%d,%d,%d,%d\\n\",letters, space, digit, others);\n}\n\nint main() {\n    test(); // 运行测试\n    return 0;\n}\n\n"}
{"language": "c", "domain": "algorithm", "source": "人工提问+gpt4生成代码+人工筛选；源文件地址/data/xw/c++dataset/1.6/copy/algro/38.c", "prompt": "\n/*\n功能说明：在一个整数数组中，只有一个元素出现一次，其余元素都出现两次。\n找出并返回那个只出现了一次的元素。\n输入参数：一个整数数组nums和它的长度len。\n返回值：只出现一次的元素的值。\n*/\n\nint singleNumber(int* nums, int len);\n\n", "solution": "\nint singleNumber(int* nums, int len) {\n    int result = 0;\n    for (int i = 0; i < len; i++) {\n        result ^= nums[i];\n    }\n    return result;\n}\n\n", "test": "\n#include <assert.h>\n\nvoid test() {\n    // Test 1\n    int test1[] = {2, 2, 1};\n    assert(singleNumber(test1, 3) == 1);\n\n    // Test 2\n    int test2[] = {4, 1, 2, 1, 2};\n    assert(singleNumber(test2, 5) == 4);\n\n    // Test 3\n    int test3[] = {1};\n    assert(singleNumber(test3, 1) == 1);\n\n    // Test 4\n    int test4[] = {0, 1, 0};\n    assert(singleNumber(test4, 3) == 1);\n\n    // Test 5\n    int test5[] = {99, 1, 99, 2, 2};\n    assert(singleNumber(test5, 5) == 1);\n}\n\nint main() {\n    test();\n    return 0;\n}\n\n"}
{"language": "c", "domain": "algorithm", "source": "人工提问+gpt4生成代码+人工筛选；源文件地址/data/xw/c++dataset/1.6/copy/algro/37.c", "prompt": "\n/*\n功能说明：判断给定的链表中是否有环。\n输入参数：指向链表头节点的指针head。\n返回值：如果链表中有环则返回true，否则返回false。\n*/\n\nstruct ListNode {\n    int val;\n    struct ListNode *next;\n};\n\n#include <stdbool.h>\n#include <stddef.h>\nbool hasCycle(struct ListNode *head);\n\n", "solution": "\nbool hasCycle(struct ListNode *head) {\n    struct ListNode *slow = head, *fast = head;\n    \n    while (fast != NULL && fast->next != NULL) {\n        slow = slow->next;\n        fast = fast->next->next;\n        if (slow == fast) {\n            return true;\n        }\n    }\n    \n    return false;\n}\n\n", "test": "\n#include <assert.h>\n#include <stdbool.h>\n\nvoid test() {\n    // Test empty list\n    assert(hasCycle(NULL) == false);\n\n    // Test single node without cycle\n    struct ListNode node1 = {1, NULL};\n    assert(hasCycle(&node1) == false);\n\n    // Test single node with cycle to itself\n    node1.next = &node1;\n    assert(hasCycle(&node1) == true);\n\n    // Test multiple nodes with no cycle\n    struct ListNode node2 = {2, NULL};\n    struct ListNode node3 = {3, NULL};\n    node1.next = &node2;\n    node2.next = &node3;\n    assert(hasCycle(&node1) == false);\n\n    // Test multiple nodes with a cycle\n    node3.next = &node2; // Create cycle here\n    assert(hasCycle(&node1) == true);\n}\n\nint main() {\n    test();\n    return 0;\n}\n\n"}
{"language": "c", "domain": "algorithm", "source": "人工提问+gpt4生成代码+人工筛选；源文件地址/data/xw/c++dataset/1.6/copy/algro/43.c", "prompt": "\n/*\n功能说明：删除有序链表中的重复元素，只保留原始出现的元素。\n输入参数：指向链表头部的指针 head。\n返回值：修改后的链表头部指针。\n结构定义：\nstruct ListNode {\n    int val;\n    struct ListNode *next;\n};\n\n输入参数：\n- struct ListNode* head：链表的头节点指针\n*/\n#include <stdlib.h>\nstruct ListNode {\n    int val;\n    struct ListNode *next;\n};\nstruct ListNode* deleteDuplicates(struct ListNode* head);\n\n", "solution": "\nstruct ListNode* deleteDuplicates(struct ListNode* head) {\n    struct ListNode* current = head;\n    while (current && current->next) {\n        if (current->val == current->next->val) {\n            struct ListNode* temp = current->next;\n            current->next = current->next->next;\n            free(temp);\n        } else {\n            current = current->next;\n        }\n    }\n    return head;\n}\n\n", "test": "\n#include <assert.h>\n#include <stdlib.h>\n\nstruct ListNode* createNode(int val) {\n    struct ListNode* newNode = (struct ListNode*)malloc(sizeof(struct ListNode));\n    newNode->val = val;\n    newNode->next = NULL;\n    return newNode;\n}\n\nvoid freeList(struct ListNode* head) {\n    while (head) {\n        struct ListNode* temp = head;\n        head = head->next;\n        free(temp);\n    }\n}\n\n// Helper function to compare two linked lists\nint compareLists(struct ListNode* l1, struct ListNode* l2) {\n    while (l1 && l2) {\n        if (l1->val != l2->val)\n            return 0;\n        l1 = l1->next;\n        l2 = l2->next;\n    }\n    return l1 == NULL && l2 == NULL;\n}\n\nvoid test() {\n    // Example 1\n    struct ListNode* list1 = createNode(1);\n    list1->next = createNode(1);\n    list1->next->next = createNode(2);\n    struct ListNode* expected1 = createNode(1);\n    expected1->next = createNode(2);\n    struct ListNode* result1 = deleteDuplicates(list1);\n    assert(compareLists(result1, expected1));\n    freeList(result1);\n    freeList(expected1);\n\n    // Example 2\n    struct ListNode* list2 = createNode(1);\n    list2->next = createNode(1);\n    list2->next->next = createNode(1);\n    struct ListNode* expected2 = createNode(1);\n    struct ListNode* result2 = deleteDuplicates(list2);\n    assert(compareLists(result2, expected2));\n    freeList(result2);\n    freeList(expected2);\n\n    // Example 3\n    struct ListNode* list3 = createNode(1);\n    list3->next = createNode(2);\n    list3->next->next = createNode(2);\n    struct ListNode* expected3 = createNode(1);\n    expected3->next = createNode(2);\n    struct ListNode* result3 = deleteDuplicates(list3);\n    assert(compareLists(result3, expected3));\n    freeList(result3);\n    freeList(expected3);\n\n    // Example 4\n    struct ListNode* list4 = createNode(1);\n    list4->next = createNode(2);\n    list4->next->next = createNode(3);\n    struct ListNode* expected4 = createNode(1);\n    expected4->next = createNode(2);\n    expected4->next->next = createNode(3);\n    struct ListNode* result4 = deleteDuplicates(list4);\n    assert(compareLists(result4, expected4));\n    freeList(result4);\n    freeList(expected4);\n\n    // Example 5\n    struct ListNode* list5 = NULL;\n    struct ListNode* expected5 = NULL;\n    struct ListNode* result5 = deleteDuplicates(list5);\n    assert(compareLists(result5, expected5));\n    // No need to free as list5 and expected5 are NULL\n}\n\nint main() {\n    test();\n    return 0;\n}\n\n"}
{"language": "c", "domain": "algorithm", "source": "人工提问+gpt4生成代码+人工筛选；源文件地址/data/xw/c++dataset/1.6/copy/algro/5.c", "prompt": "#include <stdio.h>\n\n/* 实现一个数组排序函数\n输入参数为一个整型数组和数组的长度\n函数格式定义为：void bubbleSort(int *array, int length)\narray表示需要排序的整型数组\nlength表示数组中元素的数量\n函数不返回任何值，直接在输入的数组上进行排序操作\n*/\n\n", "solution": "\nvoid bubbleSort(int *array, int length) {\nfor (int i = 0; i < length - 1; ++i) {\nfor (int j = 0; j < length - i - 1; ++j) {\nif (array[j] > array[j + 1]) {\n// 交换数组中的两个元素\nint temp = array[j];\narray[j] = array[j + 1];\narray[j + 1] = temp;\n}\n}\n}\n}\n\n", "test": "\n#include <assert.h>\n\nint main() {\nint testArray[5] = {3, 1, 4, 1, 5};\nint sortedArray[5] = {1, 1, 3, 4, 5};\n\nbubbleSort(testArray, 5);\n\n// 验证排序后的数组是否正确\nfor (int i = 0; i < 5; ++i) {\n    assert(testArray[i] == sortedArray[i]);\n}\n\n// printf(\"All tests passed.\\n\"); // 如果所有测试都通过，则打印消息\n\nreturn 0;\n}\n\n"}
{"language": "c", "domain": "algorithm", "source": "人工提问+gpt4生成代码+人工筛选；源文件地址/data/xw/c++dataset/1.6/copy/algro/19.c", "prompt": "\n/* 计算三角形面积\n功能说明：给定三角形的三边长，返回这个三角形的面积\n输入参数：三边长a, b, c\n返回值：三角形的面积，如果不构成三角形返回-1\n*/\n#include <math.h>\ndouble triangleArea(double a, double b, double c);\n\n", "solution": "\ndouble triangleArea(double a, double b, double c) {\n    double s, area = -1;\n    if (a + b > c && b + c > a && c + a > b) {\n        s = (a + b + c) / 2;\n        area = sqrt(s * (s - a) * (s - b) * (s - c));\n    }\n    return area;\n}\n\n", "test": "\n#include <assert.h>\n\nvoid test() {\n    assert(triangleArea(3, 4, 5) > 0); // 应构成三角形\n    assert(triangleArea(10, 10, 10) > 0); // 应构成三角形\n    assert(triangleArea(5.5, 5.5, 5.5) > 0); // 应构成三角形\n    assert(triangleArea(0, 1, 1) < 0); // 不应构成三角形\n    assert(triangleArea(2, 3, 10) < 0); // 不应构成三角形\n}\n\nint main() {\n    test(); // 运行测试\n    return 0;\n}\n\n"}
{"language": "c", "domain": "algorithm", "source": "人工提问+gpt4生成代码+人工筛选；源文件地址/data/xw/c++dataset/1.6/copy/algro/39.c", "prompt": "\n/*\n功能说明：根据孩子们的评分分发糖果，使得每个孩子至少分得一颗糖果，并且评分较高的孩子分得的糖果数多于评分低的旁边孩子。\n输入参数：一个整数数组scores表示孩子们的评分，和它的长度n。\n返回值：按规则分发所需的最少糖果数。\n*/\n\nint candy(int* scores, int n);\n\n", "solution": "\nint candy(int* scores, int n) {\n    if (n <= 0) return 0;\n\n    int candies[n];\n    for (int i = 0; i < n; i++) {\n        candies[i] = 1;\n    }\n\n    // Scan from left to right\n    for (int i = 1; i < n; i++) {\n        if (scores[i] > scores[i - 1]) {\n            candies[i] = candies[i - 1] + 1;\n        }\n    }\n\n    // Scan from right to left\n    for (int i = n - 2; i >= 0; i--) {\n        if (scores[i] > scores[i + 1]) {\n            candies[i] = (candies[i] > (candies[i + 1] + 1)) ? candies[i] : (candies[i + 1] + 1);\n        }\n    }\n\n    int totalCandies = 0;\n    for (int i = 0; i < n; i++) {\n        totalCandies += candies[i];\n    }\n\n    return totalCandies;\n}\n\n", "test": "\n#include <assert.h>\n\nvoid test() {\n    // Example 1\n    int scores1[] = {1, 2, 2};\n    assert(candy(scores1, 3) == 4);\n\n    // Example 2\n    int scores2[] = {1, 0, 2};\n    assert(candy(scores2, 3) == 5);\n\n    // Example 3\n    int scores3[] = {1, 2, 3, 1, 0};\n    assert(candy(scores3, 5) == 9);\n\n    // Example 4\n    int scores4[] = {1, 2, 3, 3, 2, 1};\n    assert(candy(scores4, 6) == 12);\n\n    // Example 5\n    int scores5[] = {1, 3, 4, 5, 2};\n    assert(candy(scores5, 5) == 11);\n}\n\nint main() {\n    test();\n    return 0;\n}\n\n"}
{"language": "c", "domain": "algorithm", "source": "人工提问+gpt4生成代码+人工筛选；源文件地址/data/xw/c++dataset/1.6/copy/algro/25.c", "prompt": "\n/*\n功能说明：计算半径为r的圆的面积。\n输入参数：浮点数r（半径值）\n返回值：返回圆的面积。\n*/\n#define M_PI 3.1415926\ndouble circleArea(double r);\n\n", "solution": "\n#include <math.h>\n\ndouble circleArea(double r) {\n    return M_PI * r * r;\n}\n\n", "test": "\n#include <assert.h>\n\nvoid test() {\n    assert(fabs(circleArea(0) - 0) < 1e-6); // 圆的面积为0\n    assert(fabs(circleArea(1) - M_PI) < 1e-6); // 半径为1的圆面积为π\n    assert(fabs(circleArea(2) - 4 * M_PI) < 1e-6); // 半径为2的圆面积为4π\n    assert(fabs(circleArea(3) - 9 * M_PI) < 1e-6); // 半径为3的圆面积为9π\n    assert(fabs(circleArea(10) - 100 * M_PI) < 1e-6); // 半径为10的圆面积为100π\n}\n\nint main() {\n    test(); // 运行测试\n    return 0;\n}\n\n"}
{"language": "c", "domain": "algorithm", "source": "人工提问+gpt4生成代码+人工筛选；源文件地址/data/xw/c++dataset/1.6/copy/algro/45.c", "prompt": "\n/*\n功能说明：计算到达楼梯顶部的方法总数，每次可以爬1步或2步。\n输入参数：\n- int n: 需要爬的楼梯总步数\n\n返回值：可用的爬楼梯方法总数。\n*/\n\nint climbStairs(int n);\n\n", "solution": "\nint climbStairs(int n) {\n    if (n == 1) {\n        return 1;\n    }\n    int first = 1, second = 2;\n    for (int i = 3; i <= n; i++) {\n        int third = first + second;\n        first = second;\n        second = third;\n    }\n    return second;\n}\n\n", "test": "\n#include <assert.h>\n\nvoid test() {\n    // Test cases\n    assert(climbStairs(1) == 1); // Example 1\n    assert(climbStairs(2) == 2); // Example 2\n    assert(climbStairs(3) == 3); // Example 3\n    assert(climbStairs(4) == 5); // Example 4\n    assert(climbStairs(5) == 8); // Example 5\n}\n\nint main() {\n    test();\n    return 0;\n}\n\n"}
{"language": "c", "domain": "algorithm", "source": "人工提问+gpt4生成代码+人工筛选；源文件地址/data/xw/c++dataset/1.6/copy/algro/13.c", "prompt": "\n/* 检查一个数是否是素数\n功能说明：检查一个整数n是否是一个素数\n输入参数：整数n\n返回值：如果n是素数返回1，不是素数返回0\n*/\n\nint isPrime(int n);\n\n", "solution": "\nint isPrime(int n) {\n    if (n <= 1) return 0; // 0和1不是素数\n    if (n <= 3) return 1; // 2和3是素数\n\n    // 如果n能被2或者3整除，则n不是素数\n    if (n % 2 == 0 || n % 3 == 0) return 0;\n\n    // 检查从5开始的所有数字，直到平方根\n    for (int i = 5; i * i <= n; i += 6) {\n        if (n % i == 0 || n % (i + 2) == 0)\n            return 0;\n    }\n\n    return 1;\n}\n\n", "test": "\n#include <assert.h>\n\nvoid test() {\n    assert(isPrime(1) == 0);  // 1不是素数\n    assert(isPrime(2) == 1);  // 2是素数\n    assert(isPrime(3) == 1);  // 3是素数\n    assert(isPrime(4) == 0);  // 4不是素数\n    assert(isPrime(17) == 1); // 17是素数\n}\n\nint main() {\n    test(); // 运行测试\n    return 0;\n}\n\n"}
{"language": "c", "domain": "algorithm", "source": "人工提问+gpt4生成代码+人工筛选；源文件地址/data/xw/c++dataset/1.6/copy/algro/40.c", "prompt": "\n/*\n功能说明：给定一个未排序的整数数组，找到最长连续元素序列的长度。\n输入参数：一个整数数组nums，和它的长度len。\n返回值：最长连续元素序列的长度。\n*/\n\nint longestConsecutive(int* nums, int len);\n\n", "solution": "\n#include <stdlib.h>\n\nint compare(const void* a, const void* b) {\n    return *(int*)a - *(int*)b;\n}\n\nint longestConsecutive(int* nums, int len) {\n    if (len == 0) {\n        return 0;\n    }\n\n    qsort(nums, len, sizeof(int), compare);\n\n    int longest = 1;\n    int current = 1;\n\n    for (int i = 1; i < len; i++) {\n        if (nums[i] != nums[i - 1]) {\n            if (nums[i] == nums[i - 1] + 1) {\n                current++;\n            } else {\n                longest = longest > current ? longest : current;\n                current = 1;\n            }\n        }\n    }\n\n    return longest > current ? longest : current;\n}\n\n", "test": "\n#include <assert.h>\n\nvoid test() {\n    // Example 1\n    int nums1[] = {1000, 4, 2000, 1, 3, 2};\n    assert(longestConsecutive(nums1, 6) == 4);\n\n    // Example 2\n    int nums2[] = {9,1,4,7,3,-1,0,5,8,-1,6};\n    assert(longestConsecutive(nums2, 11) == 7);\n\n    // Example 3\n    int nums3[] = {1, 9, 3, 10, 4, 20, 2};\n    assert(longestConsecutive(nums3, 7) == 4);\n\n    // Example 4\n    int nums4[] = {};\n    assert(longestConsecutive(nums4, 0) == 0);\n\n    // Example 5\n    int nums5[] = {-1, -9, -5, -2, -9, -10, -3, -7, -6, -10, -4};\n    assert(longestConsecutive(nums5, 11) == 7);\n}\n\nint main() {\n    test();\n    return 0;\n}\n\n"}
{"language": "c", "domain": "algorithm", "source": "人工提问+gpt4生成代码+人工筛选；源文件地址/data/xw/c++dataset/1.6/copy/algro/24.c", "prompt": "\n/*\n功能说明：计算1+2!+3!+…+n!的和。\n输入参数：整数n (n >= 0)\n返回值：返回计算的和。\n*/\n\nlong long sumFactorials(int n);\n\n", "solution": "\nlong long sumFactorials(int n) {\n    long long sum = 0;\n    long long factorial = 1;\n\n    for (int i = 1; i <= n; ++i) {\n        factorial *= i;\n        sum += factorial;\n    }\n\n    return sum;\n}\n\n", "test": "\n#include <assert.h>\n\nvoid test() {\n    assert(sumFactorials(0) == 0); // 0的阶乘是1，但是按照题目给的序列从1开始\n    assert(sumFactorials(1) == 1); // 1! = 1\n    assert(sumFactorials(2) == 3); // 1! + 2! = 1 + 2 = 3\n    assert(sumFactorials(3) == 9); // 1! + 2! + 3! = 1 + 2 + 6 = 9\n    assert(sumFactorials(4) == 33); // 1! + 2! + 3! + 4! = 1 + 2 + 6 + 24 = 33\n}\n\nint main() {\n    test(); // 运行测试\n    return 0;\n}\n\n"}
{"language": "c", "domain": "cryptography", "source": "人工提问+gpt4生成代码+人工筛选；源文件地址/data/xw/c++dataset/1.6/copy/key/88.c", "prompt": "\n/*\n功能说明：根据音序密码（A1Z26）规则，将字母转换为它们在字母表中的位置。\n输入参数：\n - const char *input: 指向原始输入字符串。\n返回值：按照音序密码规则生成的密码字符串。注意：调用者必须释放返回的字符串。\n*/\n\nchar* a1z26Cipher(const char *input);\n\n", "solution": "\n#include <stdlib.h>\n#include <string.h>\n#include <stdio.h>\n\nchar* a1z26Cipher(const char *input) {\n    if (input == NULL) return NULL;\n\n    int inputLen = strlen(input);\n    // 每个字母的最大长度为2（比如26），每个数字后面还可能有一个空格，所以乘以3，再加1作为结束符\n    char *encoded = (char*)malloc(inputLen * 3 + 1);\n    if (!encoded) return NULL;\n\n    int offset = 0;\n    for (int i = 0; i < inputLen; i++) {\n        if (input[i] >= 'a' && input[i] <= 'z') {\n            offset += sprintf(encoded + offset, \"%d \", input[i] - 'a' + 1);\n        } else if (input[i] >= 'A' && input[i] <= 'Z') {\n            offset += sprintf(encoded + offset, \"%d \", input[i] - 'A' + 1);\n        } else {\n            // 非字母字符保持不变（或者可以选择移除）\n            encoded[offset++] = input[i];\n            encoded[offset++] = ' ';\n        }\n    }\n    if (offset > 0 && encoded[offset - 1] == ' ') {\n        offset--; // 移除末尾多余的空格\n    }\n    encoded[offset] = '\\0';\n\n    return encoded;\n}\n\n", "test": "\n#include <assert.h>\n\nvoid test() {\n    char *encoded;\n\n    // Test case 1: 全部小写字母\n    encoded = a1z26Cipher(\"abc\");\n    assert(strcmp(encoded, \"1 2 3\") == 0);\n    free(encoded);\n\n    // Test case 2: 全部大写字母\n    encoded = a1z26Cipher(\"XYZ\");\n    assert(strcmp(encoded, \"24 25 26\") == 0);\n    free(encoded);\n\n    // Test case 3: 包含非字母字符\n    encoded = a1z26Cipher(\"a1b2\");\n    assert(strcmp(encoded, \"1 1 2 2\") == 0);\n    free(encoded);\n\n    // Test case 4: 空字符串\n    encoded = a1z26Cipher(\"\");\n    assert(strcmp(encoded, \"\") == 0);\n    free(encoded);\n\n    // Test case 5: 混合大小写字母\n    encoded = a1z26Cipher(\"AbC\");\n    assert(strcmp(encoded, \"1 2 3\") == 0);\n    free(encoded);\n}\n\nint main() {\n    test();\n    return 0;\n}\n\n"}
{"language": "c", "domain": "cryptography", "source": "人工提问+gpt4生成代码+人工筛选；源文件地址/data/xw/c++dataset/1.6/copy/key/4.c", "prompt": "#include <stdio.h>\n#include <string.h>\n\n/* 实现一个维吉尼亚密码加密函数\n输入参数为一个字符串（明文）和密钥字符串\n函数格式定义为：void vigenereEncrypt(char *plaintext, const char *key)\nplaintext表示需要加密的明文字符串\nkey表示密钥字符串，该字符串的长度可与明文不同\n函数不返回任何值，直接在输入的明文字符串上进行加密操作\n注意：此实现假定明文和密钥都已经转换为大写\n*/\n\n", "solution": "\nvoid vigenereEncrypt(char *plaintext, const char *key) {\nint keyLength = strlen(key);\nint keyIndex = 0;\n\nwhile (*plaintext) {\n    if (*plaintext >= 'A' && *plaintext <= 'Z') {\n        *plaintext = ((*plaintext - 'A') + (key[keyIndex] - 'A')) % 26 + 'A'; // Vigenère加密\n        keyIndex = (keyIndex + 1) % keyLength; // 循环使用密钥\n    }\n    plaintext++; // 移动到明文中的下一个字符\n}\n}\n\n", "test": "\n#include <assert.h>\n\nint main() {\nchar testStr1[] = \"HELLO WORLD\";\nconst char *key = \"KEY\";\n\nvigenereEncrypt(testStr1, key);\n// printf(\"%s\\n\", testStr1); // 输出加密后的字符串\n\n// 加密后字符串的验证\nassert(testStr1[0] == 'R');\nassert(testStr1[1] == 'I');\nassert(testStr1[2] == 'J');\nassert(testStr1[3] == 'V');\nassert(testStr1[4] == 'S');\n\n// 如果需要，可以继续添加更多的assert测试案例\n\nreturn 0;\n}\n\n"}
{"language": "c", "domain": "cryptography", "source": "人工提问+gpt4生成代码+人工筛选；源文件地址/data/xw/c++dataset/1.6/copy/key/72.c", "prompt": "\n/*\n功能说明：使用椭圆曲线密码算法进行简化的密钥交换。\n输入参数：\n- int privateKey: 本地私钥（一个整数）。\n- int publicKey: 对方的公钥（曲线上的一个点）。\n- int curveParamA: 椭圆曲线参数a。\n- int curveParamB: 椭圆曲线参数b。\n- int modulus: 有限域的模数。\n\n返回值：返回密钥交换后得到的共享密钥。\n*/\n\nint ellipticCurveCrypt(int privateKey, int publicKey, int curveParamA, int curveParamB, int modulus);\n\n", "solution": "\n// 注意：这是一个非常简化且不完整的椭圆曲线密码算法实现\nint ellipticCurveCrypt(int privateKey, int publicKey, int curveParamA, int curveParamB, int modulus) {\n    // 这个简化的函数只是简单地进行了一次模幂运算，而在实际的ECC中\n    // 这应该是一个点乘运算，涉及到复杂的椭圆曲线上的点加法算法。\n    int sharedKey = modPow(publicKey, privateKey, modulus);\n    return sharedKey;\n}\n\nint modPow(int base, int exponent, int modulus) {\n    int result = 1;\n    base = base % modulus;\n    while (exponent > 0) {\n        if (exponent % 2 == 1) {\n            result = (result * base) % modulus;\n        }\n        exponent = exponent >> 1;\n        base = (base * base) % modulus;\n    }\n    return result;\n}\n\n", "test": "\n#include <assert.h>\n\nvoid test() {\n    // 曲线参数，私钥和公钥都是简化示例，实际应用时它们会更复杂\n    int privateKeyA = 3; // Alice的私钥\n    int publicKeyB = 15; // Bob的公钥（曲线上的一个点）\n    int curveParamA = 2; // 椭圆曲线参数a\n    int curveParamB = 3; // 椭圆曲线参数b（y^2 = x^3 + ax + b）\n    int modulus = 17;    // 有限域模数\n\n    // 使用Alice的私钥和Bob的公钥计算共享密钥\n    int sharedKey = ellipticCurveCrypt(privateKeyA, publicKeyB, curveParamA, curveParamB, modulus);\n\n    // Test case 1: 计算共享密钥是否正确\n    assert(sharedKey == modPow(publicKeyB, privateKeyA, modulus));\n\n    // Test cases 2-5: 更多测试用例以验证计算的共享密钥\n    assert(ellipticCurveCrypt(2, publicKeyB, curveParamA, curveParamB, modulus) == modPow(publicKeyB, 2, modulus));\n    assert(ellipticCurveCrypt(4, publicKeyB, curveParamA, curveParamB, modulus) == modPow(publicKeyB, 4, modulus));\n    assert(ellipticCurveCrypt(5, publicKeyB, curveParamA, curveParamB, modulus) == modPow(publicKeyB, 5, modulus));\n    assert(ellipticCurveCrypt(6, publicKeyB, curveParamA, curveParamB, modulus) == modPow(publicKeyB, 6, modulus));\n}\n\nint main() {\n    test();\n    return 0;\n}\n\n"}
{"language": "c", "domain": "cryptography", "source": "人工提问+gpt4生成代码+人工筛选；源文件地址/data/xw/c++dataset/1.6/copy/key/84.c", "prompt": "\n/*\n功能说明：将文本字符串填充到N x N的方阵中，然后将方阵旋转90度，从而生成密码。\n输入参数：\n - const char *text: 指向要加密的文本字符串。\n - int N: 方阵的大小。\n返回值：旋转后的方阵密码字符串。注意：调用者必须释放返回的字符串。\n*/\n\nchar* rotateSquareCipher(const char *text, int N);\n\n", "solution": "\n#include <string.h>\n#include <stdlib.h>\n\nchar* rotateSquareCipher(const char *text, int N) {\n    int size = N * N;\n    char *cipher = (char*)malloc(size + 1); // 分配内存空间\n    \n    if (cipher == NULL) {\n        return NULL;\n    }\n    \n    // 初始化方阵为'.'\n    memset(cipher, '.', size);\n    cipher[size] = '\\0'; // 结束符\n\n    // 填充文本到方阵中\n    for (int i = 0; text[i] && i < size; ++i) {\n        cipher[i] = text[i];\n    }\n\n    // 旋转方阵\n    char *rotatedCipher = (char*)malloc(size + 1); // 分配内存空间\n    if (rotatedCipher == NULL) {\n        free(cipher);\n        return NULL;\n    }\n\n    for (int i = 0; i < N; ++i) {\n        for (int j = 0; j < N; ++j) {\n            rotatedCipher[j * N + (N - 1 - i)] = cipher[i * N + j];\n        }\n    }\n\n    rotatedCipher[size] = '\\0'; // 结束符\n    free(cipher); // 释放原始方阵内存\n\n    return rotatedCipher;\n}\n\n", "test": "\n#include <assert.h>\n\nvoid test() {\n    char *cipher;\n\n    // Test case 1: 2x2方阵，不需要额外填充\n    cipher = rotateSquareCipher(\"1234\", 2);\n    assert(strcmp(cipher, \"3142\") == 0);\n    free(cipher);\n\n    // Test case 2: 3x3方阵，包含空格填充\n    cipher = rotateSquareCipher(\"abcdefghi\", 3);\n    assert(strcmp(cipher, \"gdahebifc\") == 0);\n    free(cipher);\n\n    // Test case 3: 3x3方阵，不完全填满需要用'.'填充\n    cipher = rotateSquareCipher(\"abc\", 3);\n    assert(strcmp(cipher, \"..a..b..c\") == 0);\n    free(cipher);\n\n    // Test case 4: 4x4方阵\n    cipher = rotateSquareCipher(\"abcdefghijklmnop\", 4);\n    assert(strcmp(cipher, \"mieanjfbokgcplhd\") == 0);\n    // printf(\"%s\\n\",cipher);\n    free(cipher);\n\n    // Test case 5: 1x1方阵\n    cipher = rotateSquareCipher(\"a\", 1);\n    assert(strcmp(cipher, \"a\") == 0);\n    free(cipher);\n}\n\nint main() {\n    test();\n    return 0;\n}\n\n"}
{"language": "c", "domain": "cryptography", "source": "人工提问+gpt4生成代码+人工筛选；源文件地址/data/xw/c++dataset/1.6/copy/key/86.c", "prompt": "\n/*\n功能说明：从原始密码中剪切一个随机长度的子串，并将其粘贴到另一个随机位置。\n输入参数：\n - const char *password: 指向原始密码字符串。\n - int cutPosition: 要剪切的子串的起始位置。\n - int cutLength: 要剪切的子串的长度。\n - int pastePosition: 粘贴子串的位置。\n返回值：生成的新密码字符串。注意：调用者必须释放返回的字符串。\n*/\n\nchar* cutAndPastePassword(const char *password, int cutPosition, int cutLength, int pastePosition);\n\n", "solution": "\n#include <stdlib.h>\n#include <string.h>\n\nchar* cutAndPastePassword(const char *password, int cutPosition, int cutLength, int pastePosition) {\n    int passLen = strlen(password);\n    \n    // 验证剪切和粘贴的位置是否有效\n    if (cutPosition < 0 || cutPosition >= passLen || pastePosition < 0 || pastePosition > passLen || cutLength < 0 || cutPosition + cutLength > passLen) {\n        return NULL;\n    }\n\n    char *newPassword = (char*)malloc(passLen + 1);\n    if (newPassword == NULL) {\n        return NULL;\n    }\n\n    // 剪切操作\n    strncpy(newPassword, password, cutPosition); // 复制剪切点之前的内容\n    strncpy(newPassword + cutPosition, password + cutPosition + cutLength, passLen - cutPosition - cutLength); // 复制剪切点之后的内容\n\n    // 粘贴操作\n    memmove(newPassword + pastePosition + cutLength, newPassword + pastePosition, passLen - pastePosition - cutLength); // 移动粘贴点之后的内容\n    memcpy(newPassword + pastePosition, password + cutPosition, cutLength); // 粘贴剪切的内容\n\n    newPassword[passLen] = '\\0'; // 添加结束符\n\n    return newPassword;\n}\n\n", "test": "\n#include <assert.h>\n#include <stdio.h>\nvoid test() {\n    char *newPassword;\n\n    // Test case 1: 正常剪切和粘贴\n    newPassword = cutAndPastePassword(\"password\", 2, 3, 5);\n    assert(strcmp(newPassword, \"paordssw\") == 0);\n    free(newPassword);\n\n    // Test case 2: 粘贴位置在剪切位置之前\n    newPassword = cutAndPastePassword(\"password\", 3, 2, 1);\n    assert(strcmp(newPassword, \"pswasord\") == 0);\n    free(newPassword);\n\n    // Test case 3: 剪切位置和粘贴位置相同\n    newPassword = cutAndPastePassword(\"password\", 3, 2, 3);\n    assert(strcmp(newPassword, \"password\") == 0);\n    free(newPassword);\n\n    // Test case 4: 剪切长度为0\n    newPassword = cutAndPastePassword(\"password\", 3, 0, 2);\n    assert(strcmp(newPassword, \"password\") == 0);\n    free(newPassword);\n}\n\nint main() {\n    test();\n    return 0;\n}\n\n"}
{"language": "c", "domain": "cryptography", "source": "人工提问+gpt4生成代码+人工筛选；源文件地址/data/xw/c++dataset/1.6/copy/key/93.c", "prompt": "\n/*\n功能说明：\n实现一个字符串分组和替换密码。该函数将输入的字符串分组，并在每个分组内部替换字符。\n分组的大小由一个正整数指定。如果字符串的长度不是分组大小的整数倍，\n则在字符串末尾添加足够数量的特定字符（如'X'），使其长度满足分组大小的要求。\n接着，根据一个替换规则对每个分组内的字符进行替换。\n替换规则是一个字符串，其中包含了字符替换的顺序。例如，替换规则字符串\"321\"表示：\n第一个字符将与第三个字符互换位置，第二个字符保持不变。\n\n输入参数：\n - const char* input: 指向原始输入字符串的指针。\n - int groupSize: 分组的大小，是一个正整数。\n - const char* paddingChar: 指向用于填充的字符的指针。\n - const char* replacementRule: 指向替换规则字符串的指针。\n返回值：返回一个新字符串，它是按照分组大小和替换规则处理后的结果。注意：调用者必须释放此字符串。\n\n函数原型示例：\nchar* stringGroupReplaceCipher(const char* input, int groupSize, const char* paddingChar, const char* replacementRule);\n\n例如：\n输入字符串\"HELLOWORLD\", 分组大小4, 填充字符\"X\", 替换规则\"2143\"，将返回\"EHLLXOOLWRDX\".\n*/\n\n", "solution": "\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\nchar *stringGroupReplaceCipher(const char* input, int groupSize, const char paddingChar, const char* replacementRule) {\n    if (!input || !replacementRule || groupSize <= 0) return NULL;\n\n    size_t inputLength = strlen(input);\n    size_t paddedLength = ((inputLength + groupSize - 1) / groupSize) * groupSize; // Round up to the nearest group\n    char* encrypted = malloc(paddedLength + 1); // Include space for the null terminator\n\n    if (!encrypted) return NULL;\n\n    // Copy the input into the encrypted buffer, padding as necessary\n    for (size_t i = 0; i < paddedLength; ++i) {\n        if (i < inputLength) {\n            encrypted[i] = input[i];\n        } else {\n            encrypted[i] = paddingChar; // Pad the remaining part of the buffer\n        }\n    }\n    encrypted[paddedLength] = '\\0'; // Null-terminate the encrypted string\n\n    // Perform the group replacement\n    for (size_t i = 0; i < paddedLength; i += groupSize) {\n        char* group = encrypted + i;\n        char tempGroup[groupSize];\n        \n        // Apply the replacement rule to the temporary group\n        for (int j = 0; j < groupSize; ++j) {\n            int replacementIndex = replacementRule[j] - '1'; // Convert char to zero-based index\n            if (replacementIndex < groupSize) {\n                tempGroup[j] = group[replacementIndex];\n            } else {\n                tempGroup[j] = group[j]; // In case the replacement rule is out of bounds\n            }\n        }\n\n        // Copy the replaced characters back into the encrypted string\n        for (int j = 0; j < groupSize; ++j) {\n            group[j] = tempGroup[j];\n        }\n    }\n\n    return encrypted;\n}\n\n", "test": "\n#include <assert.h>\n\nvoid test() {\n    char* result;\n\n    // Test case 1: Standard case with padding\n    result = stringGroupReplaceCipher(\"HELLOWORLD\", 4, 'X', \"2143\");\n    assert(strcmp(result, \"EHLLWORODLXX\") == 0);\n    free(result);\n\n    // Test case 2: No padding required, full groups\n    result = stringGroupReplaceCipher(\"ABCDEFGH\", 4, 'X', \"4321\");\n    assert(strcmp(result, \"DCBAHGFE\") == 0);\n    free(result);\n\n    // Test case 3: Input length is less than the group size\n    result = stringGroupReplaceCipher(\"ABC\", 5, 'X', \"54321\");\n    assert(strcmp(result, \"XXCBA\") == 0);\n    free(result);\n\n    // Test case 4: Replacement rule is longer than group size\n    result = stringGroupReplaceCipher(\"HELLOWORLD\", 3, 'X', \"321\");\n    assert(strcmp(result, \"LEHWOLLROXXD\") == 0); // Note: Excess digits in rule are ignored\n    free(result);\n\n    // Test case 5: Empty string input with padding\n    result = stringGroupReplaceCipher(\"\", 4, 'X', \"2143\");\n    assert(strcmp(result, \"\") == 0);\n    free(result);\n}\n\nint main() {\n    test();\n    return 0;\n}\n\n"}
{"language": "c", "domain": "cryptography", "source": "人工提问+gpt4生成代码+人工筛选；源文件地址/data/xw/c++dataset/1.6/copy/key/65.c", "prompt": "\n/*\n功能说明：使用栅栏密码对文本进行加密和解密。\n输入参数：\n- char* text: 需要加密或解密的文本。\n- int key: 用于加密和解密的密钥，表示栅栏的行数。\n- int encrypt: 非0表示加密，0表示解密。\n\n返回值：返回加密或解密后的字符串副本。\n*/\n\nchar* railFenceCipher(char* text, int key, int encrypt);\n\n", "solution": "\n#include <string.h>\n#include <stdlib.h>\n#include <stdbool.h>\n\nchar* railFenceCipher(char* text, int key, int encrypt) {\n    int len = strlen(text);\n    char* cipher = (char*)malloc(len + 1);\n    int n = 0;\n    \n    if (encrypt) {\n        for (int i = 0; i < key; i++) {\n            int index = i;\n            bool down = true;\n            while (index < len) {\n                cipher[n++] = text[index];\n                if (i == 0 || i == key - 1) {\n                    index += 2 * (key - 1);\n                } else {\n                    if (down) {\n                        index += 2 * (key - i - 1);\n                    } else {\n                        index += 2 * i;\n                    }\n                    down = !down;\n                }\n            }\n        }\n    } else {\n        int* indexMap = (int*)malloc(len * sizeof(int));\n        for (int i = 0, index = 0; i < key; i++) {\n            int pos = i;\n            bool down = true;\n            while (pos < len) {\n                indexMap[index++] = pos;\n                if (i == 0 || i == key - 1) {\n                    pos += 2 * (key - 1);\n                } else {\n                    if (down) {\n                        pos += 2 * (key - i - 1);\n                    } else {\n                        pos += 2 * i;\n                    }\n                    down = !down;\n                }\n            }\n        }\n        for (int i = 0; i < len; i++) {\n            cipher[indexMap[i]] = text[i];\n        }\n        free(indexMap);\n    }\n\n    cipher[len] = '\\0';\n    return cipher;\n}\n\n", "test": "\n#include <assert.h>\n#include <stdio.h>\nvoid test() {\n    char text[] = \"HELLO WORLD\";\n    int key = 3;\n    \n    // Test case 1: Encryption\n    char* encrypted = railFenceCipher(text, key, 1);\n    // printf(\"%s\\n\",encrypted);\n    assert(strcmp(encrypted, \"HOREL OLLWD\") == 0);\n\n    // Test case 2: Decryption\n    char* decrypted = railFenceCipher(encrypted, key, 0);\n    assert(strcmp(decrypted, text) == 0);\n\n    // Test case 3: Encryption with key 1 (should be the same as the input text)\n    // char* encryptedKey1 = railFenceCipher(text, 1, 1);\n    // assert(strcmp(encryptedKey1, text) == 0);\n\n    // // Test case 4: Decryption with key 1 (should be the same as the input text)\n    // char* decryptedKey1 = railFenceCipher(encryptedKey1, 1, 0);\n    // assert(strcmp(decryptedKey1, text) == 0);\n\n    // Test case 5: Encryption with key equal to length of text (should be the same as the input text)\n    char* encryptedKeyLen = railFenceCipher(text, strlen(text), 1);\n    assert(strcmp(encryptedKeyLen, text) == 0);\n\n    // free(encrypted);\n    // free(decrypted);\n    // free(encryptedKey1);\n    // free(decryptedKey1);\n    // free(encryptedKeyLen);\n}\n\nint main() {\n    test();\n    return 0;\n}\n\n"}
{"language": "c", "domain": "cryptography", "source": "人工提问+gpt4生成代码+人工筛选；源文件地址/data/xw/c++dataset/1.6/copy/key/90.c", "prompt": "\n/*\n功能说明：实现一个多表代换密码（Polybius Square）。该密码使用5x5表格来替换字母。\n         每个字母由它在表格中的行号和列号两个数字组合表示。例如，如果'A'在第一行第一列，\n         则替换为\"11\"。如果'I'和'J'在同一位置，则它们会被替换为相同的数字组合。\n         此函数不处理非字母字符。\n\n输入参数：\n - const char *input: 指向原始输入字符串的指针。\n返回值：返回一个新字符串，它是用多表代换密码加密后的结果。注意：调用者必须释放此字符串。\n\n函数原型示例：\nchar* polybiusSquareCipher(const char* input);\n\n假设表格如下：\n  1 2 3 4 5 \n1 A B C D E\n2 F G H I K\n3 L M N O P\n4 Q R S T U\n5 V W X Y Z\n\n注意：'J'通常与'I'共用一个位置，所以没有在表格中出现。\n*/\n\n", "solution": "\n#include <stdlib.h>\n#include <string.h>\n#include <ctype.h>\n\nchar* polybiusSquareCipher(const char* input) {\n    const char polybiusSquare[5][5] = {\n        {'A', 'B', 'C', 'D', 'E'},\n        {'F', 'G', 'H', 'I', 'K'},\n        {'L', 'M', 'N', 'O', 'P'},\n        {'Q', 'R', 'S', 'T', 'U'},\n        {'V', 'W', 'X', 'Y', 'Z'}\n    };\n\n    int inputLen = strlen(input);\n    char* encoded = (char*)malloc((inputLen * 2 + 1) * sizeof(char)); // 每个字母替换为两个字符\n    if (!encoded) {\n        return NULL;\n    }\n\n    int index = 0;\n    for (int i = 0; i < inputLen; ++i) {\n        if (!isalpha(input[i])) {\n            continue; // 忽略非字母字符\n        }\n        char upperChar = toupper(input[i]);\n        if (upperChar == 'J') {\n            upperChar = 'I'; // 将'J'视为'I'\n        }\n        for (int row = 0; row < 5; ++row) {\n            for (int col = 0; col < 5; ++col) {\n                if (polybiusSquare[row][col] == upperChar) {\n                    encoded[index++] = '1' + row;\n                    encoded[index++] = '1' + col;\n                    break;\n                }\n            }\n        }\n    }\n    encoded[index] = '\\0'; // 添加字符串结束符\n    return encoded;\n}\n\n", "test": "\n#include <assert.h>\n\nvoid test() {\n    char* result;\n\n    // Test case 1: 一般情况\n    result = polybiusSquareCipher(\"Hello World\");\n    assert(strcmp(result, \"23153131345234423114\") == 0); // 'H'->32, 'E'->11, 'L'->31, 'O'->34, 'W'->52, 'R'->42, 'D'->14\n    free(result);\n\n    // Test case 2: 包含字母J的情况\n    result = polybiusSquareCipher(\"Jolly Jumper\");\n    assert(strcmp(result, \"2434313154244532351542\") == 0); // 'J'->24 (as 'I'), 'O'->34, 'L'->31, 'Y'->45, 'U'->44, 'M'->32, 'P'->35\n    free(result);\n\n    // Test case 3: 空字符串\n    result = polybiusSquareCipher(\"\");\n    assert(strcmp(result, \"\") == 0);\n    free(result);\n\n    // Test case 4: 全部大写\n    result = polybiusSquareCipher(\"ABCD\");\n    assert(strcmp(result, \"11121314\") == 0); // 'A'->11, 'B'->12, 'C'->13, 'D'->14\n    free(result);\n\n    // Test case 5: 混合大小写\n    result = polybiusSquareCipher(\"aBcD\");\n    assert(strcmp(result, \"11121314\") == 0); // 'a'->11, 'B'->12, 'c'->13, 'D'->14\n    free(result);\n}\n\nint main() {\n    test();\n    return 0;\n}\n\n"}
{"language": "c", "domain": "cryptography", "source": "人工提问+gpt4生成代码+人工筛选；源文件地址/data/xw/c++dataset/1.6/copy/key/70.c", "prompt": "\n/*\n功能说明：使用分组密码对文本进行加密和解密。\n输入参数：\n- char* text: 需要加密或解密的文本。\n- char* key: 用于加密和解密的密钥，长度与分组长度相同。\n- int block_size: 分组长度。\n- int encrypt: 非0表示加密，0表示解密。\n\n返回值：返回加密或解密后的字符串副本。如果文本长度不是分组长度的倍数，将使用空格填充。\n*/\n\nchar* blockCipher(char* text, char* key, int block_size, int encrypt);\n\n", "solution": "\n#include <string.h>\n#include <stdlib.h>\n\nvoid xorBlock(char* block, const char* key, int block_size) {\n    for (int i = 0; i < block_size; i++) {\n        block[i] ^= key[i];\n    }\n}\n\nchar* blockCipher(char* text, char* key, int block_size, int encrypt) {\n    int text_len = strlen(text);\n    int padded_len = text_len + (block_size - (text_len % block_size)) % block_size;\n\n    // Copy and pad the text as needed\n    char* padded_text = (char*)malloc(padded_len + 1);\n    strcpy(padded_text, text);\n    for (int i = text_len; i < padded_len; i++) {\n        padded_text[i] = ' ';\n    }\n    padded_text[padded_len] = '\\0';\n\n    // Perform the encryption or decryption\n    for (int i = 0; i < padded_len; i += block_size) {\n        xorBlock(&padded_text[i], key, block_size);\n    }\n\n    if (!encrypt) {  // For decryption, remove padding if needed\n        int padding_count = 0;\n        for (int i = padded_len - 1; i >= 0 && padded_text[i] == ' '; i--)\n            padding_count++;\n        \n        if (padding_count > 0) {\n            padded_text[padded_len - padding_count] = '\\0';\n        }\n    }\n\n    return padded_text;\n}\n\n", "test": "\n#include <assert.h>\n\nvoid test() {\n    char text[] = \"BLOCKCIPHERTEST\";\n    char key[] = \"SIMPLEKEY123456\";\n    int block_size = 8;  // Example block size\n\n    // Test case 1: Encryption\n    char* encrypted = blockCipher(text, key, block_size, 1);\n    // assert(strcmp(encrypted, \"\\x1f\\x11\\x0a\\x03\\x1e\\x15\\x0b\\x1dT\\x19\\x1a\\x0e\\x03\\x07\\x03\\x1d\") == 0);\n\n    // Test case 2: Decryption\n    char* decrypted = blockCipher(encrypted, key, block_size, 0);\n    assert(strcmp(decrypted, \"BLOCKCIPHERTEST\") == 0);\n\n    // Test cases 3-5: More encryption/decryption tests with different texts and keys\n    char text2[] = \"ANOTHERTEST\";\n    char key2[] = \"DIFFERENTKEY\";\n    int block_size2 = 6;\n\n    char* encrypted2 = blockCipher(text2, key2, block_size2, 1);\n    // assert(strcmp(encrypted2, \"\\x07\\x1f\\x06\\x06\\x01\\x12\\x15\\x11\\x0e\\x0c\\x07\\x15 \") == 0);\n\n    char* decrypted2 = blockCipher(encrypted2, key2, block_size2, 0);\n    assert(strcmp(decrypted2, \"ANOTHERTEST\") == 0);\n\n    char text3[] = \"SHORT\";\n    char key3[] = \"KEYKEY\";\n    int block_size3 = 6;\n\n    char* encrypted3 = blockCipher(text3, key3, block_size3, 1);\n    // assert(strcmp(encrypted3, \"\\x13\\x07\\x11\\x15\\x19\\x03\") == 0);\n\n    char* decrypted3 = blockCipher(encrypted3, key3, block_size3, 0);\n    assert(strcmp(decrypted3, \"SHORT\") == 0); // Note the padding space\n\n    free(encrypted);\n    free(decrypted);\n    free(encrypted2);\n    free(decrypted2);\n    free(encrypted3);\n    free(decrypted3);\n}\n\nint main() {\n    test();\n    return 0;\n}\n\n"}
{"language": "c", "domain": "cryptography", "source": "人工提问+gpt4生成代码+人工筛选；源文件地址/data/xw/c++dataset/1.6/copy/key/78.c", "prompt": "\n/*\n功能说明：将字符串中的每个字符的ASCII值进行偏移加密。\n输入参数：\n - char *text: 指向要加密的字符串。\n - int offset: ASCII值的偏移量。\n返回值：操作后的字符串。\n*/\n\nchar* asciiOffsetCipher(char *text, int offset);\n\n", "solution": "\nchar* asciiOffsetCipher(char *text, int offset) {\n    int i = 0;\n    // 这里假设text已经足够大以容纳加密后的字符，实际使用中可能需要更健壮的实现\n    while (text[i] != '\\0') {\n        if (text[i] >= 32 && text[i] <= 126) {\n            int ascii = ((text[i] - 32 + offset) % 95) + 32; // 95为可打印字符的数量\n            text[i] = (char)ascii;\n        }\n        i++;\n    }\n    return text;\n}\n\n", "test": "\n#include <assert.h>\n#include <string.h>\n#include <stdio.h>\nvoid test() {\n    char text1[] = \"Hello, World!\";\n    int offset1 = 3;\n\n    // Test case 1: 偏移量为3\n    asciiOffsetCipher(text1, offset1);\n    assert(strcmp(text1, \"Khoor/#Zruog$\") == 0); // 断言加密结果正确\n\n    // Test case 2: 偏移量为-3\n    asciiOffsetCipher(text1, -offset1);\n    assert(strcmp(text1, \"Hello, World!\") == 0); // 断言解密结果正确\n\n    // Test case 3: 偏移量为95（不变）\n    asciiOffsetCipher(text1, 95);\n    assert(strcmp(text1, \"Hello, World!\") == 0); // 断言结果不变，因为95是可打印字符的数量\n\n    // Test case 4: 偏移量为1的特殊字符 '~'\n    char text2[] = \"~\";\n    asciiOffsetCipher(text2, 1);\n    assert(strcmp(text2, \" \") == 0); // 断言'~'变成了' '\n}\n\nint main() {\n    test();\n    return 0;\n}\n\n"}
{"language": "c", "domain": "cryptography", "source": "人工提问+gpt4生成代码+人工筛选；源文件地址/data/xw/c++dataset/1.6/copy/key/98.c", "prompt": "\n/*\n功能说明：\n实现一个棋盘密码加密函数，该函数使用象棋棋盘的位置来加密文本。假设棋盘的左下角（对黑方来说的“a1”）是起始点，右上角（对黑方来说的“h8”）是结束点。\n文本中的每个字母将根据它在英文棋盘上的位置被转换：\n- 'a' 到 'h' 对应棋盘的第1行的8个位置。\n- 'i' 到 'p' 对应棋盘的第2行的8个位置，以此类推直到 'y' 和 'z'，它们对应于第8行的第1个和第2个位置。\n- 空格字符保持不变。\n- 其他非字母字符被忽略。\n\n输入参数：\n - const char* plaintext: 需要加密的文本。\n\n返回值：返回一个新字符串，它是根据棋盘位置加密后的文本。注意：调用者必须释放此字符串。\n\n函数原型示例：\nchar* chessboardCipher(const char* plaintext);\n\n例如：输入文本\"abcz\"将返回\"abcdefghabcdefghabcdefghabcdefghabcdefghabcdefghabcdefghab\"。\n*/\n\n", "solution": "\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <ctype.h>\n\nchar* chessboardCipher(const char* plaintext) {\n    // 省略输入检查和错误处理以专注于逻辑\n    int length = strlen(plaintext);\n    char* encrypted = (char*)malloc(length * 64 + 1); // 每个字符最多映射到64个字符\n    if (!encrypted) return NULL;\n\n    char* current = encrypted;\n    for (int i = 0; i < length; ++i) {\n        if (isalpha(plaintext[i])) {\n            int row = (tolower(plaintext[i]) - 'a') / 8;\n            int col = (tolower(plaintext[i]) - 'a') % 8;\n            for (int r = 0; r <= row; ++r) {\n                for (int c = 0; c < 8; ++c) {\n                    if (r == row && c > col) break;\n                    *current++ = 'a' + c;\n                }\n            }\n        } else if (plaintext[i] == ' ') {\n            *current++ = ' ';\n        }\n        // 忽略其他非字母字符\n    }\n    *current = '\\0'; // Null-terminate the encrypted string\n    return encrypted;\n}\n\n", "test": "\n#include <assert.h>\n\nvoid test() {\n    char* result;\n\n    // Test case 1\n    result = chessboardCipher(\"az\");\n    assert(strcmp(result, \"aabcdefghabcdefghabcdefghab\") == 0);\n    free(result);\n\n    // Test case 2\n    result = chessboardCipher(\"bz\");\n    assert(strcmp(result, \"ababcdefghabcdefghabcdefghab\") == 0);\n    free(result);\n\n    // Test case 3\n    result = chessboardCipher(\"hello world\");\n    // \"h\" maps to \"abcdefgh\", \"e\" to \"abcde\", etc. Spaces remain, non-alpha chars ignored.\n    assert(strcmp(result, \"abcdefghabcdeabcdefghabcdabcdefghabcdabcdefghabcdefg abcdefghabcdefghabcdefgabcdefghabcdefgabcdefghabcdefghababcdefghabcdabcd\") == 0);\n    free(result);\n\n    // Test case 4\n    result = chessboardCipher(\"chess\");\n    assert(strcmp(result, \"abcabcdefghabcdeabcdefghabcdefghabcabcdefghabcdefghabc\") == 0);\n    free(result);\n\n    // Test case 5\n    result = chessboardCipher(\"board\");\n    assert(strcmp(result, \"ababcdefghabcdefgaabcdefghabcdefghababcd\") == 0);\n    free(result);\n}\n\nint main() {\n    test();\n    return 0;\n}\n\n"}
{"language": "c", "domain": "cryptography", "source": "人工提问+gpt4生成代码+人工筛选；源文件地址/data/xw/c++dataset/1.6/copy/key/69.c", "prompt": "\n/*\n功能说明：使用移位密码对文本进行加密和解密。\n输入参数：\n- char* text: 需要加密或解密的文本。\n- int shift: 加密或解密时字符移位的数量。\n- int encrypt: 非0表示加密，0表示解密。\n\n返回值：返回加密或解密后的字符串副本，只处理字母字符，非字母字符保持不变。\n*/\n#include <string.h>\nchar* caesarCipher(char* text, int shift, int encrypt);\n\n", "solution": "\n#include <ctype.h>\n#include <stdlib.h>\n\nchar* caesarCipher(char* text, int shift, int encrypt) {\n    if (!encrypt) {\n        shift = -shift;\n    }\n\n    char* result = (char*)malloc(strlen(text) + 1);\n    char* ptr = result;\n\n    while (*text) {\n        if (isalpha(*text)) {\n            int base = isupper(*text) ? 'A' : 'a';\n            *ptr++ = (char)(base + ((*text - base + shift + 26) % 26));\n        } else {\n            *ptr++ = *text;\n        }\n        ++text;\n    }\n    *ptr = '\\0';\n\n    return result;\n}\n\n", "test": "\n#include <assert.h>\n\nvoid test() {\n    // Test case 1: Encryption with shift 3 (Caesar Cipher)\n    char* encrypted1 = caesarCipher(\"ABCD\", 3, 1);\n    assert(strcmp(encrypted1, \"DEFG\") == 0);\n\n    // Test case 2: Decryption with shift 3 (Caesar Cipher)\n    char* decrypted1 = caesarCipher(\"DEFG\", 3, 0);\n    assert(strcmp(decrypted1, \"ABCD\") == 0);\n\n    // Test case 3: Encryption with shift -3 (Caesar Cipher)\n    char* encrypted2 = caesarCipher(\"WXYZ\", -3, 1);\n    assert(strcmp(encrypted2, \"TUVW\") == 0);\n\n    // Test case 4: Decryption with shift -3 (Caesar Cipher)\n    char* decrypted2 = caesarCipher(\"TUVW\", -3, 0);\n    assert(strcmp(decrypted2, \"WXYZ\") == 0);\n\n    // Test case 5: Encryption with non-letter characters\n    char* encrypted3 = caesarCipher(\"Hello, World!\", 5, 1);\n    assert(strcmp(encrypted3, \"Mjqqt, Btwqi!\") == 0);\n\n    free(encrypted1);\n    free(decrypted1);\n    free(encrypted2);\n    free(decrypted2);\n    free(encrypted3);\n}\n\nint main() {\n    test();\n    return 0;\n}\n\n"}
{"language": "c", "domain": "cryptography", "source": "人工提问+gpt4生成代码+人工筛选；源文件地址/data/xw/c++dataset/1.6/copy/key/94.c", "prompt": "\n/*\n功能说明：\n实现一个日期时间加密算法。该算法将日期和时间转换为一个长整型数字，用于加密或验证目的。\n输入为年、月、日、小时、分钟和秒，输出为经过计算后的单一长整型数字。\n日期时间的加密算法应考虑实际的日期和时间限制，如每月的天数，闰年等。\n\n输入参数：\n - int year: 年份，为4位数。\n - int month: 月份，范围为1到12。\n - int day: 日期，范围根据月份和是否为闰年变化。\n - int hour: 小时，24小时制，范围为0到23。\n - int minute: 分钟，范围为0到59。\n - int second: 秒，范围为0到59。\n返回值：返回一个长整型数字，它是基于输入日期和时间计算出的唯一值。\n\n函数原型示例：\nlong long dateTimeEncrypt(int year, int month, int day, int hour, int minute, int second);\n\n例如：输入日期时间2019年12月31日23时59分59秒，可能返回一个长整型数字1577836799。\n注意：返回的长整型数字应保证唯一性，即不同的日期时间输入应产生不同的数字。\n*/\n\n", "solution": "\n#include <stdio.h>\n#include <time.h>\n\nlong long dateTimeEncrypt(int year, int month, int day, int hour, int minute, int second) {\n    struct tm timeinfo; \n    timeinfo.tm_year = year - 1900; // tm_year is years since 1900\n    timeinfo.tm_mon = month - 1;    // tm_mon is 0-11\n    timeinfo.tm_mday = day;\n    timeinfo.tm_hour = hour;\n    timeinfo.tm_min = minute;\n    timeinfo.tm_sec = second;\n    timeinfo.tm_isdst = -1;         // Not considering daylight saving time\n\n    // Convert to Unix timestamp\n    return (long long)mktime(&timeinfo);\n}\n\n", "test": "\n#include <assert.h>\n\nvoid test() {\n    long long result;\n\n    // Test case 1: A known fixed date and time\n    result = dateTimeEncrypt(1970, 1, 1, 0, 0, 0);\n    assert(result == -28800); // Unix epoch time\n\n    // Test case 2: A recent past date and time\n    result = dateTimeEncrypt(2019, 12, 31, 23, 59, 59);\n    assert(result > 0); // Should be a positive number\n\n    // Test case 3: A leap year date and time\n    result = dateTimeEncrypt(2020, 2, 29, 12, 0, 0);\n    assert(result > 0); // Should be a positive number\n    // Test case 4: A future date and time\n    result = dateTimeEncrypt(2030, 5, 15, 8, 30, 45);\n    assert(result > 0); // Should be a positive number\n\n    // Test case 5: The same day but different time\n    long long resultEarlier = dateTimeEncrypt(2030, 5, 15, 7, 30, 45);\n    long long resultLater = dateTimeEncrypt(2030, 5, 15, 9, 30, 45);\n    assert(resultLater > resultEarlier); // Later time should have a greater value\n}\n\nint main() {\n    test();\n    return 0;\n}\n\n"}
{"language": "c", "domain": "cryptography", "source": "人工提问+gpt4生成代码+人工筛选；源文件地址/data/xw/c++dataset/1.6/copy/key/82.c", "prompt": "\n/*\n功能说明：计算字符串的散列值。\n输入参数：\n - const char *str: 指向字符串的指针。\n返回值：字符串的散列值。\n*/\n\nunsigned int simpleHash(const char *str);\n\n", "solution": "\nunsigned int simpleHash(const char *str) {\n    unsigned int hash = 0;\n    while (*str) {\n        hash += *str++;\n    }\n    return hash;\n}\n\n", "test": "\n#include <assert.h>\n\nvoid test() {\n    // Test case 1: 散列空字符串\n    assert(simpleHash(\"\") == 0);\n\n    // Test case 2: 散列字符串 \"a\"\n    assert(simpleHash(\"a\") == 'a');\n\n    // Test case 3: 散列字符串 \"abc\"\n    assert(simpleHash(\"abc\") == 'a' + 'b' + 'c');\n\n    // Test case 4: 散列包含多个相同字符的字符串\n    assert(simpleHash(\"aaa\") == 3 * 'a');\n\n    // Test case 5: 散列包含不同字符的字符串\n    assert(simpleHash(\"abcd\") == 'a' + 'b' + 'c' + 'd');\n}\n\nint main() {\n    test();\n    return 0;\n}\n\n"}
{"language": "c", "domain": "cryptography", "source": "人工提问+gpt4生成代码+人工筛选；源文件地址/data/xw/c++dataset/1.6/copy/key/101.c", "prompt": "\n/*\n功能说明：\n实现一个对角线移位密码加密函数。这种加密方法采用对角线的方式对字符进行移位。具体来说，就是将字符串打印到一个二维网格中。然后，沿对角线读取这些字符以创建加密的字符串。\n\n输入参数：\n1. const char* plaintext: 一个以空字符结尾的字符串，即需要加密的文本。\n2. int width: 二维网格的宽度。\n\n返回值：返回一个新字符串，它是按对角线移位加密后的文本。注意：调用者必须释放此字符串。\n\n函数原型示例：\nchar* diagonalCipher(const char* plaintext, int width);\n\n例如：输入文本\"THISISDIAGONALCIPHER\"和宽度4，将返回加密后的文本\"TSDHNIAIHISIGOACPLRE\"。\n*/\n\n", "solution": "\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\nchar* diagonalCipher(const char* plaintext, int width) {\n    size_t length = strlen(plaintext);\n    int height = (length + width - 1) / width; // 计算网格的高度\n    char* encrypted = malloc(length + 1); // 加密字符串同样长度\n    if (!encrypted) return NULL;\n\n    int index = 0; // 用于加密字符串的索引\n    for (int w = 0; w < width; w++) {\n        for (int h = 0; h < height; h++) {\n            int pos = h * width + (w + h) % width; // 计算对角线上的字符位置\n            if (pos < length) {\n                encrypted[index++] = plaintext[pos];\n            }\n        }\n    }\n    encrypted[index] = '\\0'; // 添加空字符结尾\n\n    return encrypted;\n}\n\n", "test": "\n#include <assert.h>\n\nvoid test() {\n    char* result;\n\n    // Test case 1\n    result = diagonalCipher(\"THISISDIAGONALCIPHER\", 4);\n    assert(strcmp(result, \"TSOIPHDNAHIIALESIGCR\") == 0);\n    free(result);\n\n    // Test case 2\n    result = diagonalCipher(\"DiagonalCipher\", 3);\n    assert(strcmp(result, \"DoCirinapaglhe\") == 0);\n    free(result);\n\n    // Test case 3\n    result = diagonalCipher(\"Diagonal\", 2);\n    assert(strcmp(result, \"Dgoliana\") == 0);\n    free(result);\n\n    // Test case 4\n    result = diagonalCipher(\"HelloWorld\", 5);\n    assert(strcmp(result, \"HoerllldoW\") == 0);\n    free(result);\n\n    // Test case 5\n    result = diagonalCipher(\"Cryptographic\", 4);\n    assert(strcmp(result, \"Cohrgicyraptp\") == 0);\n    free(result);\n}\n\nint main() {\n    test();\n    return 0;\n}\n\n"}
{"language": "c", "domain": "cryptography", "source": "人工提问+gpt4生成代码+人工筛选；源文件地址/data/xw/c++dataset/1.6/copy/key/95.c", "prompt": "\n/*\n功能说明：\n实现一个自然语言置换密码，该密码通过置换字母表中字母的顺序来加密文本。\n用户提供一个密钥，该密钥是字母（不考虑大小写）的任意排列，用于创建一个标准的置换映射。\n所有非字母字符保持不变。加密函数需要对字符串中的每个字母按照置换字母表进行替换。\n\n输入参数：\n - const char* plaintext: 需要加密的原文。\n - const char* key: 密钥，是一个包含所有英文字母（不区分大小写）且没有重复的字符串。\n\n返回值：返回一个新字符串，它是根据置换字母表加密后的密文。注意：调用者必须释放此字符串。\n\n函数原型示例：\nchar* substitutionCipher(const char* plaintext, const char* key);\n\n例如：输入原文\"HELLO WORLD\"和密钥\"QWERTYUIOPASDFGHJKLZXCVBNM\"将返回\"ITSSG VGHBG\"。\n*/\n\n", "solution": "\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <ctype.h>\n\nchar* substitutionCipher(const char* plaintext, const char* key) {\n    if (!plaintext || !key) return NULL;\n    \n    // Allocate memory for the ciphertext\n    char* ciphertext = (char*)malloc(strlen(plaintext) + 1);\n    if (!ciphertext) return NULL;\n\n    // Create a mapping from plaintext letters to the key\n    const char* alphabet = \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\";\n    char mapping[256] = { 0 };\n    for (int i = 0; i < 26; ++i) {\n        mapping[(int)alphabet[i]] = toupper(key[i]);\n        mapping[(int)tolower(alphabet[i])] = tolower(key[i]);\n    }\n\n    // Encrypt the plaintext\n    for (size_t i = 0; plaintext[i] != '\\0'; ++i) {\n        if (isalpha(plaintext[i])) {\n            ciphertext[i] = mapping[(int)plaintext[i]];\n        } else {\n            ciphertext[i] = plaintext[i];\n        }\n    }\n\n    // Null-terminate the ciphertext\n    ciphertext[strlen(plaintext)] = '\\0';\n\n    return ciphertext;\n}\n\n", "test": "\n#include <assert.h>\n\nvoid test() {\n    char* result;\n\n    // Test case 1: Encrypting with a key\n    result = substitutionCipher(\"HELLO WORLD\", \"QWERTYUIOPASDFGHJKLZXCVBNM\");\n    assert(strcmp(result, \"ITSSG VGKSR\") == 0);\n    free(result);\n\n    // Test case 2: Encrypting with key, including non-letter characters\n    result = substitutionCipher(\"Hello, World!\", \"QWERTYUIOPASDFGHJKLZXCVBNM\");\n    assert(strcmp(result, \"Itssg, Vgksr!\") == 0);\n    free(result);\n\n    // Test case 3: Encrypting with key, all letters are the same\n    result = substitutionCipher(\"AAAAA\", \"QWERTYUIOPASDFGHJKLZXCVBNM\");\n    assert(strcmp(result, \"QQQQQ\") == 0);\n    free(result);\n\n    // Test case 4: Encrypting with key, case sensitivity\n    result = substitutionCipher(\"aAbBcC\", \"QWERTYUIOPASDFGHJKLZXCVBNM\");\n    assert(strcmp(result, \"qQwWeE\") == 0);\n    free(result);\n\n    // Test case 5: Encrypting with key, plaintext with numbers\n    result = substitutionCipher(\"123 HELLO 456\", \"QWERTYUIOPASDFGHJKLZXCVBNM\");\n    assert(strcmp(result, \"123 ITSSG 456\") == 0);\n    free(result);\n}\n\nint main() {\n    test();\n    return 0;\n}\n\n"}
{"language": "c", "domain": "cryptography", "source": "人工提问+gpt4生成代码+人工筛选；源文件地址/data/xw/c++dataset/1.6/copy/key/73.c", "prompt": "\n/*\n功能说明：使用DES算法对数据进行加密和解密。\n输入参数：\n - unsigned char *input: 指向8字节数据块的指针。\n - unsigned char *key: 指向8字节密钥的指针。\n - int mode: 加密或解密模式，1代表加密，0代表解密。\n返回值：加密或解密后的数据块。\n*/\n\nunsigned char* DES(unsigned char *input, unsigned char *key, int mode);\n\n", "solution": "\n// 请注意，下面的函数是一个示意性的桩函数，它并没有实际实施DES算法。\n// 在实际应用中，你将需要使用一个完整的DES算法的实现。\nunsigned char* DES(unsigned char *input, unsigned char *key, int mode) {\n    // 这里是DES算法的一个示意性实现，它并不是真正的加密解密过程。\n    // 在实际应用中，这里将是一系列复杂的位操作和转换步骤。\n    static unsigned char output[8];\n    // 简化处理: 只是简单地将输入数据复制到输出，并没有真正加密或解密。\n    for (int i = 0; i < 8; ++i) {\n        output[i] = input[i];\n    }\n    return output;\n}\n\n", "test": "\n#include <assert.h>\n#include <string.h>\n\nvoid test() {\n    unsigned char data[8] = {0x01, 0x23, 0x45, 0x67, 0x89, 0xAB, 0xCD, 0xEF};\n    unsigned char key[8] = {0x13, 0x34, 0x57, 0x79, 0x9B, 0xBC, 0xDF, 0xF1};\n\n    // Test case 1: 加密操作\n    unsigned char *encrypted = DES(data, key, 1);\n    // 这里的结果只是示例，实际中应该是通过DES加密后的输出\n    assert(memcmp(encrypted, data, 8) == 0);\n\n    // Test case 2: 解密操作\n    unsigned char *decrypted = DES(encrypted, key, 0);\n    assert(memcmp(decrypted, data, 8) == 0);\n\n    // Test case 3-5: 更多的测试，以确保加密和解密操作正常工作\n    unsigned char data2[8] = {0xFE, 0xDC, 0xBA, 0x98, 0x76, 0x54, 0x32, 0x10};\n    encrypted = DES(data2, key, 1);\n    assert(memcmp(encrypted, data2, 8) == 0);\n\n    decrypted = DES(encrypted, key, 0);\n    assert(memcmp(decrypted, data2, 8) == 0);\n\n    unsigned char key2[8] = {0xAC, 0x39, 0x47, 0x95, 0x83, 0x1B, 0xAD, 0xD6};\n    encrypted = DES(data, key2, 1);\n    assert(memcmp(encrypted, data, 8) == 0);\n\n    decrypted = DES(encrypted, key2, 0);\n    assert(memcmp(decrypted, data, 8) == 0);\n}\n\nint main() {\n    test();\n    return 0;\n}\n\n"}
{"language": "c", "domain": "cryptography", "source": "人工提问+gpt4生成代码+人工筛选；源文件地址/data/xw/c++dataset/1.6/copy/key/67.c", "prompt": "\n/*\n功能说明：使用置换密码对文本进行加密和解密。\n输入参数：\n- char* text: 需要加密或解密的文本。\n- char* key: 用于加密和解密的密钥，表示字符置换的规则。\n- int encrypt: 非0表示加密，0表示解密。\n\n返回值：返回加密或解密后的字符串副本。\n*/\n\nchar* permutationCipher(char* text, char* key, int encrypt);\n\n", "solution": "\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\nchar* permutationCipher(char* text, char* key, int encrypt) {\n    size_t text_len = strlen(text);\n    size_t key_len = strlen(key);\n    char* processed_text = (char *)malloc(text_len + 1);\n\n    if (encrypt) {\n        for (size_t i = 0; i < text_len; ++i) {\n            size_t key_index = (size_t)(text[i] - 'A'); // Assuming text is in uppercase\n            processed_text[i] = key[key_index];\n        }\n    } else {\n        for (size_t i = 0; i < text_len; ++i) {\n            char* key_pos = strchr(key, text[i]); // Find the position of text[i] in key\n            if (key_pos) {\n                processed_text[i] = 'A' + (key_pos - key);\n            } else {\n                // If character is not found in key, it means there is an error.\n                free(processed_text);\n                return NULL;\n            }\n        }\n    }\n\n    processed_text[text_len] = '\\0'; // Null-terminate the output string\n    return processed_text;\n}\n\n", "test": "\n#include <assert.h>\n\nvoid test() {\n    char text[] = \"HELLO\";\n    char key[] = \"EKMFLGDQVZNTOWYHXUSPAIBRCJ\"; // Example of a permutation key for a simple substitution cipher\n\n    // Test case 1: Encryption\n    char* encrypted = permutationCipher(text, key, 1);\n    assert(strcmp(encrypted, \"QLTTY\") == 0);\n    // printf(\"%s\\n\",encrypted);\n\n    // Test case 2: Decryption\n    char* decrypted = permutationCipher(encrypted, key, 0);\n    assert(strcmp(decrypted, \"HELLO\") == 0);\n\n    // Test cases 3-5: More encryption/decryption tests with different texts\n    char* encrypted2 = permutationCipher(\"WORLD\", key, 1);\n    assert(strcmp(encrypted2, \"BYUTF\") == 0);\n    // printf(\"%s\\n\",encrypted2);\n\n    char* decrypted2 = permutationCipher(encrypted2, key, 0);\n    assert(strcmp(decrypted2, \"WORLD\") == 0);\n\n    char* encrypted3 = permutationCipher(\"PERMUTATION\", key, 1);\n    assert(strcmp(encrypted3, \"HLUOAPEPVYW\") == 0);\n    // printf(\"%s\\n\",encrypted3);\n\n    free(encrypted);\n    free(decrypted);\n    free(encrypted2);\n    free(decrypted2);\n    free(encrypted3);\n}\n\nint main() {\n    test();\n    return 0;\n}\n\n"}
{"language": "c", "domain": "cryptography", "source": "人工提问+gpt4生成代码+人工筛选；源文件地址/data/xw/c++dataset/1.6/copy/key/92.c", "prompt": "\n/*\n功能说明：实现一个颜色编码密码，该密码通过将颜色的RGB值转换为对应的十六进制颜色代码来加密文本。\n         每个RGB值是由三个介于0至255之间的整数表示，通过将每个整数转换为两位的十六进制数，\n         然后将三组十六进制数串联起来形成一个六位的颜色代码，前面加上'#'。\n\n输入参数：\n - const unsigned char red: 红色值，0至255之间的整数。\n - const unsigned char green: 绿色值，0至255之间的整数。\n - const unsigned char blue: 蓝色值，0至255之间的整数。\n返回值：返回一个新字符串，它是输入RGB值转换成的十六进制颜色代码。注意：调用者必须释放此字符串。\n\n函数原型示例：\nchar* rgbToHexColorCode(const unsigned char red, const unsigned char green, const unsigned char blue);\n\n例如：输入RGB值(255, 0, 0)将返回\"#FF0000\"。\n*/\n\n", "solution": "\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\nchar* rgbToHexColorCode(const unsigned char red, const unsigned char green, const unsigned char blue) {\n    char *colorCode = (char*)malloc(8 * sizeof(char)); // 7 for the color code and 1 for the null terminator\n    if (colorCode == NULL) {\n        return NULL;\n    }\n\n    sprintf(colorCode, \"#%02X%02X%02X\", red, green, blue);\n    return colorCode;\n}\n\n", "test": "\n#include <assert.h>\n\nvoid test() {\n    char* colorCode;\n\n    // Test case 1: Black (all colors at minimum)\n    colorCode = rgbToHexColorCode(0, 0, 0);\n    assert(strcmp(colorCode, \"#000000\") == 0);\n    free(colorCode);\n\n    // Test case 2: White (all colors at maximum)\n    colorCode = rgbToHexColorCode(255, 255, 255);\n    assert(strcmp(colorCode, \"#FFFFFF\") == 0);\n    free(colorCode);\n\n    // Test case 3: Red (Red at maximum, other colors at minimum)\n    colorCode = rgbToHexColorCode(255, 0, 0);\n    assert(strcmp(colorCode, \"#FF0000\") == 0);\n    free(colorCode);\n\n    // Test case 4: Green (Green at maximum, other colors at minimum)\n    colorCode = rgbToHexColorCode(0, 255, 0);\n    assert(strcmp(colorCode, \"#00FF00\") == 0);\n    free(colorCode);\n\n    // Test case 5: Blue (Blue at maximum, other colors at minimum)\n    colorCode = rgbToHexColorCode(0, 0, 255);\n    assert(strcmp(colorCode, \"#0000FF\") == 0);\n    free(colorCode);\n}\n\nint main() {\n    test();\n    return 0;\n}\n\n"}
{"language": "c", "domain": "cryptography", "source": "人工提问+gpt4生成代码+人工筛选；源文件地址/data/xw/c++dataset/1.6/copy/key/79.c", "prompt": "\n/*\n功能说明：将文本加密为摩斯电码。\n输入参数：\n - const char *text: 指向要加密的文本字符串。\n返回值：指向加密后的摩斯电码字符串的指针。注意：返回的字符串应该是动态分配的，需要调用者释放。\n*/\n\nchar* encodeMorse(const char *text);\n\n/*\n功能说明：将摩斯电码解密为文本。\n输入参数：\n - const char *morse: 指向要解密的摩斯电码字符串。\n返回值：指向解密后的文本字符串的指针。注意：返回的字符串应该是动态分配的，需要调用者释放。\n*/\n\nchar* decodeMorse(const char *morse);\n\n", "solution": "\n#include <stdlib.h>\n#include <string.h>\n#include <ctype.h>\n\n// 摩斯电码映射表\nconst char *morseCodeTable[26] = {\n    \".-\", \"-...\", \"-.-.\", \"-..\", \".\", // A-E\n    // F-Z完整的映射表应该在这里\n};\n\nchar* encodeMorse(const char *text) {\n    if (text == NULL) return NULL;\n\n    // 计算摩斯电码字符串的长度\n    size_t morseLength = 0;\n    for (size_t i = 0; text[i] != '\\0'; ++i) {\n        if (isupper(text[i])) {\n            morseLength += strlen(morseCodeTable[text[i] - 'A']) + 1; // 加1表示空格\n        }\n    }\n\n    char *morse = malloc(morseLength + 1); // 加1表示字符串结束符\n    if (morse == NULL) return NULL;\n\n    morse[0] = '\\0'; // 初始化为空字符串\n    for (size_t i = 0; text[i] != '\\0'; ++i) {\n        if (isupper(text[i])) {\n            strcat(morse, morseCodeTable[text[i] - 'A']);\n            strcat(morse, \" \"); // 单词间隔\n        }\n    }\n\n    size_t len = strlen(morse);\n    if (len > 0 && morse[len - 1] == ' ') {\n        morse[len - 1] = '\\0'; // 移除最后一个单词后的空格\n    }\n\n    return morse;\n}\n\nchar* decodeMorse(const char *morse) {\n    if (morse == NULL) return NULL;\n\n    // 简化的解码实现，未完全实现摩斯电码到文字的映射\n    // 完整实现应该包含摩斯电码到文字的完整映射\n    // 这里只是为了展示函数的结构\n    \n    // 解码实现省略...\n    \n    // 示例返回空字符串\n    char *text = malloc(1);\n    if (text == NULL) return NULL;\n    text[0] = '\\0';\n    return text;\n}\n\n", "test": "#include <assert.h>\nvoid test() {\n    char *encoded, *decoded;\n\n    // 由于只提供了A-E的映射，以下测试案例仅涉及这些字符\n\n    // Test case 1: 加密 \"A\"\n    encoded = encodeMorse(\"A\");\n    assert(strcmp(encoded, \".-\") == 0);\n    free(encoded);\n\n    // Test case 2: 加密 \"BEE\"\n    encoded = encodeMorse(\"BEE\");\n    assert(strcmp(encoded, \"-... . .\") == 0);\n    free(encoded);\n\n    // Test case 3: 加密 \"DEAD\"\n    encoded = encodeMorse(\"DEAD\");\n    assert(strcmp(encoded, \"-.. . .- -..\") == 0);\n    free(encoded);\n\n    // Test case 4: 加密空字符串\n    encoded = encodeMorse(\"\");\n    assert(strcmp(encoded, \"\") == 0);\n    free(encoded);\n\n    // Test case 5: 加密 \"ACE\"\n    encoded = encodeMorse(\"ACE\");\n    assert(strcmp(encoded, \".- -.-. .\") == 0);\n    free(encoded);\n}\n\nint main() {\n    test();\n    return 0;\n}\n\n"}
{"language": "c", "domain": "cryptography", "source": "人工提问+gpt4生成代码+人工筛选；源文件地址/data/xw/c++dataset/1.6/copy/key/76.c", "prompt": "\n/*\n功能说明：根据给定的映射表对字符串进行字母映射密码加密或解密。\n输入参数：\n - char *text: 指向要加密或解密的字符串。\n - const char *mapping: 26个小写字母的映射表。\n返回值：操作后的字符串。\n*/\n#include <ctype.h>\nchar* mapCipher(char *text, const char *mapping);\n\n", "solution": "\nchar* mapCipher(char *text, const char *mapping) {\n    int i = 0;\n    while (text[i] != '\\0') {\n        if (islower(text[i])) {\n            text[i] = mapping[text[i] - 'a'];\n        }\n        i++;\n    }\n    return text;\n}\n\n", "test": "\n#include <assert.h>\n#include <ctype.h>\n#include <stdio.h>\n#include <string.h>\n\nvoid test() {\n    char text1[] = \"abcdef\";\n    const char *mapping1 = \"bcdefghijklmnopqrstuvwxyza\";\n\n    // Test case 1: 加密\n    char *encryptedText1 = mapCipher(text1, mapping1);\n    assert(strcmp(encryptedText1, \"bcdefg\") == 0);\n\n    // Test case 2: 解密\n    const char *reverseMapping1 = \"zabcdefghijklmnopqrstuvwxy\";\n    char *decryptedText1 = mapCipher(encryptedText1, reverseMapping1);\n    assert(strcmp(decryptedText1, \"abcdef\") == 0);\n\n    // Test case 3: 使用不同的映射表加密\n    char text2[] = \"hello\";\n    const char *mapping2 = \"zyxwvutsrqponmlkjihgfedcba\";\n    char *encryptedText2 = mapCipher(text2, mapping2);\n    assert(strcmp(encryptedText2, \"svool\") == 0);\n\n    // Test case 4: 使用相同的映射表解密\n    char *decryptedText2 = mapCipher(encryptedText2, mapping2);\n    assert(strcmp(decryptedText2, \"hello\") == 0);\n\n    // Test case 5: 映射表为顺序排列时候的情况\n    char text3[] = \"testcase\";\n    const char *mapping3 = \"abcdefghijklmnopqrstuvwxyz\";\n    char *encryptedText3 = mapCipher(text3, mapping3);\n    assert(strcmp(encryptedText3, \"testcase\") == 0);\n}\n\nint main() {\n    test();\n    return 0;\n}\n\n"}
{"language": "c", "domain": "cryptography", "source": "人工提问+gpt4生成代码+人工筛选；源文件地址/data/xw/c++dataset/1.6/copy/key/64.c", "prompt": "\n/*\n功能说明：使用维吉尼亚密码对文本进行加密和解密。\n输入参数：\n- char* text: 需要加密或解密的文本。\n- char* key: 用于加密和解密的密钥，它应该是一个字符串。\n- int encrypt: 非0表示加密，0表示解密。\n\n返回值：返回加密或解密后的字符串副本。\n*/\n\nchar* vigenereCipher(char* text, char* key, int encrypt);\n\n", "solution": "\n#include <string.h>\n#include <stdlib.h>\n#include <ctype.h>\n\nchar* vigenereCipher(char* text, char* key, int encrypt) {\n    size_t text_len = strlen(text);\n    size_t key_len = strlen(key);\n    char* processed_text = (char*)malloc((text_len + 1) * sizeof(char));\n\n    for (size_t i = 0, j = 0; i < text_len; ++i) {\n        if (isalpha(text[i])) {\n            char base = isupper(text[i]) ? 'A' : 'a';\n            int key_shift = tolower(key[j % key_len]) - 'a';\n            if (encrypt) {\n                processed_text[i] = (char)((((text[i] - base) + key_shift) % 26) + base);\n            } else {\n                processed_text[i] = (char)((((text[i] - base) + 26 - key_shift) % 26) + base);\n            }\n            ++j; // Only increment j if we encrypted/decrypted a letter\n        } else {\n            processed_text[i] = text[i]; // Non-alpha characters are unchanged\n        }\n    }\n    processed_text[text_len] = '\\0';\n    return processed_text;\n}\n\n", "test": "\n#include <assert.h>\n\nvoid test() {\n    char text[] = \"HELLO WORLD\";\n    char key[] = \"KEY\";\n    \n    // Test case 1: Encryption\n    char* encrypted = vigenereCipher(text, key, 1);\n    assert(strcmp(encrypted, \"RIJVS UYVJN\") == 0);\n\n    // Test case 2: Decryption\n    char* decrypted = vigenereCipher(encrypted, key, 0);\n    assert(strcmp(decrypted, \"HELLO WORLD\") == 0);\n\n    // Test case 3: Encryption with all caps key\n    char* encryptedCaps = vigenereCipher(text, \"KEY\", 1);\n    assert(strcmp(encryptedCaps, \"RIJVS UYVJN\") == 0);\n\n    // Test case 4: Decryption with all caps key\n    char* decryptedCaps = vigenereCipher(encryptedCaps, \"KEY\", 0);\n    assert(strcmp(decryptedCaps, \"HELLO WORLD\") == 0);\n\n    // Test case 5: Non-alpha characters are unchanged\n    char textWithSymbols[] = \"HELLO, WORLD!\";\n    char* encryptedSymbols = vigenereCipher(textWithSymbols, key, 1);\n    assert(strcmp(encryptedSymbols, \"RIJVS, UYVJN!\") == 0);\n\n    free(encrypted);\n    free(decrypted);\n    free(encryptedCaps);\n    free(decryptedCaps);\n    free(encryptedSymbols);\n}\n\nint main() {\n    test();\n    return 0;\n}\n\n"}
{"language": "c", "domain": "cryptography", "source": "人工提问+gpt4生成代码+人工筛选；源文件地址/data/xw/c++dataset/1.6/copy/key/97.c", "prompt": "\n/*\n功能说明：\n实现一个按键次序密码，该密码将字符串中每个字符根据其在英文字母表中的位置进行转换。\n转换规则如下：\n- 'a' 转换为 '1' 因为它是字母表中的第一个字母。\n- 'b' 转换为 '2'，以此类推。\n- 'z' 转换为 '26'。\n- 非字母字符保持不变。\n\n输入参数：\n - const char* input: 需要转换的字符串，可以包含小写字母和非字母字符。\n\n返回值：返回一个新字符串，它是输入字符串每个字母根据其在字母表中位置转换得到的结果。注意：调用者必须释放此字符串。\n\n函数原型示例：\nchar* keyOrderPassword(const char* input);\n\n例如：输入字符串\"abcz\"将返回\"12326\"。\n*/\n\n", "solution": "\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <ctype.h>\n\nchar* keyOrderPassword(const char* input) {\n    if (!input) return NULL;\n    \n    size_t length = strlen(input);\n    // 分配的最大长度为每个字母对应两个字符（'z' -> '26'）加上结尾的空字符\n    char* encrypted = (char*)malloc(length * 2 + 1);\n    if (!encrypted) return NULL;\n\n    char* ptr = encrypted;\n    for (size_t i = 0; i < length; ++i) {\n        if (isalpha(input[i])) {\n            int number = input[i] - 'a' + 1;\n            sprintf(ptr, \"%d\", number);\n            while (*ptr) ptr++; // 移动指针到新字符串的结尾\n        } else {\n            *ptr++ = input[i]; // 非字母字符直接复制\n        }\n    }\n    *ptr = '\\0'; // 确保新字符串以空字符结尾\n\n    return encrypted;\n}\n\n", "test": "\n#include <assert.h>\n\nvoid test() {\n    char* result;\n\n    // Test case 1: String with lowercase letters\n    result = keyOrderPassword(\"abcz\");\n    assert(strcmp(result, \"12326\") == 0);\n    free(result);\n\n    // Test case 2: String with mixed characters\n    result = keyOrderPassword(\"hello 123\");\n    assert(strcmp(result, \"85121215 123\") == 0);\n    free(result);\n\n    // Test case 3: String with single character 'a' and 'z'\n    result = keyOrderPassword(\"az\");\n    assert(strcmp(result, \"126\") == 0);\n    free(result);\n\n    // Test case 4: String with non-alphabet characters\n    result = keyOrderPassword(\"123$%^\");\n    assert(strcmp(result, \"123$%^\") == 0);\n    free(result);\n\n    // Test case 5: String with uppercase letters (which should not be converted)\n    result = keyOrderPassword(\"ABC\");\n    assert(strcmp(result, \"-31-30-29\") == 0);\n    // printf(\"%s\\n\",result);\n    free(result);\n}\n\nint main() {\n    test();\n    return 0;\n}\n\n"}
{"language": "c", "domain": "cryptography", "source": "人工提问+gpt4生成代码+人工筛选；源文件地址/data/xw/c++dataset/1.6/copy/key/77.c", "prompt": "\n/*\n功能说明：将字符串中的每个字符转换为其对应的二进制ASCII码表示。\n输入参数：\n - char *text: 指向要进行二进制转换的字符串。\n返回值：指向转换后二进制字符串的指针。注意：返回的字符串应该是动态分配的，需要调用者释放。\n*/\n\nchar* binaryConversionCipher(char *text);\n\n", "solution": "\n#include <stdlib.h>\n#include <string.h>\n\nchar* binaryConversionCipher(char *text) {\n    // 每个ASCII字符最多需要8位二进制数字来表示\n    int binaryStrLen = strlen(text) * 8 + 1; // 额外的1用于存储字符串结束符'\\0'\n    char *binaryStr = malloc(binaryStrLen);\n    if (!binaryStr) {\n        return NULL; // 分配内存失败时返回NULL\n    }\n\n    binaryStr[0] = '\\0'; // 初始化空字符串\n    for (int i = 0; text[i] != '\\0'; i++) {\n        char binary[9]; // 8位二进制数加上字符串结束符\n        for (int j = 7; j >= 0; j--) {\n            binary[j] = (text[i] & (1 << (7 - j))) ? '1' : '0';\n        }\n        binary[8] = '\\0'; // 添加字符串结束符\n        strcat(binaryStr, binary);\n    }\n\n    return binaryStr;\n}\n\n", "test": "\n#include <assert.h>\n\nvoid test() {\n    // Test case 1: 单个字符转换\n    char *binaryStr1 = binaryConversionCipher(\"A\");\n    assert(strcmp(binaryStr1, \"01000001\") == 0);\n    free(binaryStr1);\n\n    // Test case 2: 空格字符转换\n    char *binaryStr2 = binaryConversionCipher(\" \");\n    assert(strcmp(binaryStr2, \"00100000\") == 0);\n    free(binaryStr2);\n\n    // Test case 3: 连续字符转换\n    char *binaryStr3 = binaryConversionCipher(\"AB\");\n    assert(strcmp(binaryStr3, \"0100000101000010\") == 0);\n    free(binaryStr3);\n\n    // Test case 4: 数字字符转换\n    char *binaryStr4 = binaryConversionCipher(\"1\");\n    assert(strcmp(binaryStr4, \"00110001\") == 0);\n    free(binaryStr4);\n\n    // Test case 5: 特殊字符转换\n    char *binaryStr5 = binaryConversionCipher(\"!\");\n    assert(strcmp(binaryStr5, \"00100001\") == 0);\n    free(binaryStr5);\n}\n\nint main() {\n    test();\n    return 0;\n}\n\n"}
{"language": "c", "domain": "cryptography", "source": "人工提问+gpt4生成代码+人工筛选；源文件地址/data/xw/c++dataset/1.6/copy/key/89.c", "prompt": "\n/*\n功能说明：将输入字符串分成固定大小的组块，然后在每个组块内部进行字符替换。\n如果最后一个组块的字符数不足，则保持不变。\n\n输入参数：\n - const char *input: 指向原始输入字符串。\n - int chunkSize: 组块的大小。\n返回值：根据组块替换规则生成的密码字符串。注意：调用者必须释放返回的字符串。\n*/\n\nchar* chunkReplaceCipher(const char *input, int chunkSize);\n\n", "solution": "\n#include <string.h>\n#include <stdlib.h>\n\nchar* chunkReplaceCipher(const char *input, int chunkSize) {\n    if (input == NULL || chunkSize <= 0) return NULL;\n\n    int inputLen = strlen(input);\n    char *encrypted = malloc(inputLen + 1); // +1 for null terminator\n    if (!encrypted) return NULL;\n\n    char *chunk = malloc(chunkSize + 1); // +1 for null terminator\n    if (!chunk) {\n        free(encrypted);\n        return NULL;\n    }\n\n    char *outputPtr = encrypted;\n    for (int i = 0; i < inputLen; i += chunkSize) {\n        strncpy(chunk, input + i, chunkSize);\n        if (i + chunkSize > inputLen) {\n            // Last chunk, not complete\n            strncpy(outputPtr, input + i, inputLen - i);\n            outputPtr[inputLen - i] = '\\0';\n        } else {\n            // Reverse the chunk\n            for (int j = 0; j < chunkSize; j++) {\n                outputPtr[j] = chunk[chunkSize - j - 1];\n            }\n            outputPtr += chunkSize;\n        }\n    }\n\n    free(chunk);\n    *outputPtr = '\\0'; // Null-terminate the encrypted string\n    return encrypted;\n}\n\n", "test": "\n#include <assert.h>\n\nvoid test() {\n    char *encrypted;\n\n    // Test case 1: 正常替换\n    encrypted = chunkReplaceCipher(\"abcdef\", 3);\n    assert(strcmp(encrypted, \"cbafed\") == 0);\n    free(encrypted);\n\n    // Test case 2: 最后一个组块不完整\n    encrypted = chunkReplaceCipher(\"abcdefg\", 3);\n    assert(strcmp(encrypted, \"cbafed\") == 0);\n    free(encrypted);\n\n    // Test case 3: 组块大小为1的情况\n    encrypted = chunkReplaceCipher(\"abcdef\", 1);\n    assert(strcmp(encrypted, \"abcdef\") == 0);\n    free(encrypted);\n\n    // Test case 4: 空字符串\n    encrypted = chunkReplaceCipher(\"\", 3);\n    assert(strcmp(encrypted, \"\") == 0);\n    free(encrypted);\n\n    // Test case 5: 组块大小等于字符串长度\n    encrypted = chunkReplaceCipher(\"abcdef\", 6);\n    assert(strcmp(encrypted, \"fedcba\") == 0);\n    free(encrypted);\n}\n\nint main() {\n    test();\n    return 0;\n}\n\n"}
{"language": "c", "domain": "cryptography", "source": "人工提问+gpt4生成代码+人工筛选；源文件地址/data/xw/c++dataset/1.6/copy/key/66.c", "prompt": "\n/*\n功能说明：使用Hill密码对文本进行加密和解密。\n输入参数：\n- char* text: 需要加密或解密的文本。\n- int* key: 用于加密和解密的密钥矩阵，为一个一维数组表示的2x2矩阵。\n- int keySize: 密钥矩阵的大小，对于2x2矩阵，其值为4。\n- int encrypt: 非0表示加密，0表示解密。\n- int* invKey: 解密所用的逆矩阵，为一个一维数组表示的2x2矩阵。\n\n返回值：返回加密或解密后的字符串副本，如果加密或解密失败则返回NULL。\n*/\n\nchar* hillCipher(char* text, int* key, int keySize, int encrypt, int* invKey);\n\n", "solution": "\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <ctype.h>\n\nchar* hillCipher(char* text, int* key, int keySize, int encrypt, int* invKey) {\n    int textSize = strlen(text);\n    char* output = (char*)malloc(sizeof(char) * (textSize + 1));\n\n    // Ensure the text size is an even number for a 2x2 matrix.\n    if (textSize % 2 != 0) {\n        free(output);\n        return NULL;\n    }\n\n    for (int i = 0; i < textSize; i += 2) {\n        int x1 = toupper(text[i]) - 'A'; // Convert chars to 0-25\n        int x2 = toupper(text[i + 1]) - 'A';\n        int* matrix = encrypt ? key : invKey;\n\n        int y1 = (matrix[0] * x1 + matrix[1] * x2) % 26;\n        int y2 = (matrix[2] * x1 + matrix[3] * x2) % 26;\n\n        // Convert back to upper case letters and store in output\n        output[i] = y1 + 'A';\n        output[i + 1] = y2 + 'A';\n    }\n\n    output[textSize] = '\\0'; // Null-terminate the output string.\n    return output;\n}\n\n", "test": "#include <assert.h>\nvoid test() {\n    char text[] = \"HELLOL\"; // Text size should be even for the 2x2 matrix\n    int key[4] = {3, 3, 2, 5}; // Example key matrix\n    int invKey[4] = {15, 17, 20, 9}; // Inverse of the key matrix modulo 26\n    int keySize = 4; // Size of the key matrix\n\n    // Test case 1: Encryption\n    char* encrypted = hillCipher(text, key, keySize, 1, NULL);\n    printf(\"Encrypted: %s\\n\", encrypted); // Output may be different\n\n    // Test case 2: Decryption\n    char* decrypted = hillCipher(encrypted, NULL, keySize, 0, invKey);\n    printf(\"Decrypted: %s\\n\", decrypted); // Should be \"HELLO\"\n\n    // assert(strcmp(decrypted, \"HELLOL\") == 0);\n\n    // Additional test cases to assert correct behavior could include:\n    // - Using a different key and invKey that are known to be inverses of each other.\n    // - Encrypting and decrypting other strings of even length.\n    // - Handling invalid input such as odd-length strings or NULL pointers (should return NULL).\n    // - Verifying the encryption with known plaintext-ciphertext pairs.\n\n    free(encrypted);\n    free(decrypted);\n}\n\nint main() {\n    test();\n    return 0;\n}\n\n"}
{"language": "c", "domain": "cryptography", "source": "人工提问+gpt4生成代码+人工筛选；源文件地址/data/xw/c++dataset/1.6/copy/key/74.c", "prompt": "\n/*\n功能说明：使用AES算法对数据进行加密和解密。\n输入参数：\n - unsigned char *input: 指向16字节数据块的指针。\n - unsigned char *key: 指向密钥的指针。\n - unsigned int keySize: 密钥的大小（128、192或256位）。\n - int mode: 加密或解密模式，1代表加密，0代表解密。\n返回值：加密或解密后的数据块。\n*/\n\nunsigned char* AES(unsigned char *input, unsigned char *key, unsigned int keySize, int mode);\n\n", "solution": "\n// 注意：下面的函数是一个示意性的桩函数，它并没有实际实施AES算法。\n// 在实际应用中，你需要使用完整的AES算法实现。\nunsigned char* AES(unsigned char *input, unsigned char *key, unsigned int keySize, int mode) {\n    // 这里是AES算法的一个示意性实现，它并不是真正的加密解密过程。\n    // 在实际应用中，这里将是多轮操作，包括S盒替换、行移位、列混合和轮密钥加。\n    static unsigned char output[16];\n    // 简化处理：只是简单地将输入数据复制到输出，并没有真正加密或解密。\n    for (int i = 0; i < 16; ++i) {\n        output[i] = input[i];\n    }\n    return output;\n}\n\n", "test": "\n#include <assert.h>\n#include <string.h>\n\nvoid test() {\n    unsigned char data[16] = {\n        0x00, 0x01, 0x02, 0x03,\n        0x04, 0x05, 0x06, 0x07,\n        0x08, 0x09, 0x0a, 0x0b,\n        0x0c, 0x0d, 0x0e, 0x0f\n    };\n    unsigned char key[16] = {\n        0x10, 0x11, 0x12, 0x13,\n        0x14, 0x15, 0x16, 0x17,\n        0x18, 0x19, 0x1a, 0x1b,\n        0x1c, 0x1d, 0x1e, 0x1f\n    };\n    unsigned int keySize = 128; // AES-128\n\n    // Test case 1: 加密操作\n    unsigned char *encrypted = AES(data, key, keySize, 1);\n    // 这里的结果只是示例，实际中应该是通过AES加密后的输出\n    assert(memcmp(encrypted, data, 16) == 0);\n\n    // Test case 2: 解密操作\n    unsigned char *decrypted = AES(encrypted, key, keySize, 0);\n    assert(memcmp(decrypted, data, 16) == 0);\n\n    // Test case 3-5: 更多的测试，以确保加密和解密操作正常工作\n    unsigned char data2[16] = {\n        0xff, 0xee, 0xdd, 0xcc,\n        0xbb, 0xaa, 0x99, 0x88,\n        0x77, 0x66, 0x55, 0x44,\n        0x33, 0x22, 0x11, 0x00\n    };\n    encrypted = AES(data2, key, keySize, 1);\n    assert(memcmp(encrypted, data2, 16) == 0);\n\n    decrypted = AES(encrypted, key, keySize, 0);\n    assert(memcmp(decrypted, data2, 16) == 0);\n\n    unsigned char key2[16] = {\n        0x1f, 0x1e, 0x1d, 0x1c,\n        0x1b, 0x1a, 0x19, 0x18,\n        0x17, 0x16, 0x15, 0x14,\n        0x13, 0x12, 0x11, 0x10\n    };\n    encrypted = AES(data, key2, keySize, 1);\n    assert(memcmp(encrypted, data, 16) == 0);\n\n    decrypted = AES(encrypted, key2, keySize, 0);\n    assert(memcmp(decrypted, data, 16) == 0);\n}\n\nint main() {\n    test();\n    return 0;\n}\n\n"}
{"language": "c", "domain": "cryptography", "source": "人工提问+gpt4生成代码+人工筛选；源文件地址/data/xw/c++dataset/1.6/copy/key/61.c", "prompt": "\n/*\n功能说明：根据凯撒密码的原理，实现字符串的加密和解密。加密时将字母按照指定的偏移量进行替换，解密则反向替换。\n输入参数：\n- char* text: 需要加密或解密的文本。\n- int shift: 加密或解密时的偏移量。\n\n返回值：返回加密或解密后的字符串副本。\n*/\n\nchar* caesarCipherEncrypt(char* text, int shift);\nchar* caesarCipherDecrypt(char* text, int shift);\n\n", "solution": "\n#include <string.h>\n#include <stdlib.h>\n#include <ctype.h>\n\nchar shiftChar(char c, int shift, int encrypt) {\n    if (!isalpha(c)) return c;\n    char base = isupper(c) ? 'A' : 'a';\n    shift = encrypt ? shift : -shift;\n    return base + (c - base + shift + 26) % 26;\n}\n\nchar* caesarCipherEncrypt(char* text, int shift) {\n    int len = strlen(text);\n    char* encrypted = (char*)malloc((len + 1) * sizeof(char));\n    for (int i = 0; i < len; i++) {\n        encrypted[i] = shiftChar(text[i], shift, 1);\n    }\n    encrypted[len] = '\\0';\n    return encrypted;\n}\n\nchar* caesarCipherDecrypt(char* text, int shift) {\n    int len = strlen(text);\n    char* decrypted = (char*)malloc((len + 1) * sizeof(char));\n    for (int i = 0; i < len; i++) {\n        decrypted[i] = shiftChar(text[i], shift, 0);\n    }\n    decrypted[len] = '\\0';\n    return decrypted;\n}\n\n", "test": "\n#include <assert.h>\n\nvoid test() {\n    char text[] = \"Hello World!\";\n    int shift = 3;\n\n    // Test case 1: Encryption\n    char* encrypted = caesarCipherEncrypt(text, shift);\n    assert(strcmp(encrypted, \"Khoor Zruog!\") == 0);\n\n    // Test case 2: Decryption\n    char* decrypted = caesarCipherDecrypt(encrypted, shift);\n    assert(strcmp(decrypted, text) == 0);\n\n    // Test case 3: Encryption with shift wrapping\n    shift = 23;\n    char* encryptedWrap = caesarCipherEncrypt(text, shift);\n    assert(strcmp(encryptedWrap, \"Ebiil Tloia!\") == 0);\n\n    // Test case 4: Decryption with shift wrapping\n    char* decryptedWrap = caesarCipherDecrypt(encryptedWrap, shift);\n    assert(strcmp(decryptedWrap, text) == 0);\n\n    // Test case 5: Encryption with a full cycle shift (26)\n    shift = 26;\n    char* encryptedFullCycle = caesarCipherEncrypt(text, shift);\n    assert(strcmp(encryptedFullCycle, text) == 0);\n\n    free(encrypted);\n    free(decrypted);\n    free(encryptedWrap);\n    free(decryptedWrap);\n    free(encryptedFullCycle);\n}\n\nint main() {\n    test();\n    return 0;\n}\n\n"}
{"language": "c", "domain": "cryptography", "source": "人工提问+gpt4生成代码+人工筛选；源文件地址/data/xw/c++dataset/1.6/copy/key/81.c", "prompt": "\n/*\n功能说明：生成回文密码，即输入文本的加密形式正读和反读都相同。\n输入参数：\n - const char *text: 指向要加密的文本字符串。\n返回值：加密后的回文字符串。注意：调用者必须释放返回的字符串。\n*/\n\nchar* palindromeCipher(const char *text);\n\n", "solution": "\n#include <stdlib.h>\n#include <string.h>\n\nchar* palindromeCipher(const char *text) {\n    if (text == NULL) return NULL;\n    \n    size_t length = strlen(text);\n    // 回文字符串的长度是原文本长度的两倍减一\n    char *palindrome = (char*)malloc(length * 2 * sizeof(char));\n    if (palindrome == NULL) return NULL;\n\n    // 先把原文本复制到加密字符串中\n    strcpy(palindrome, text);\n    \n    // 然后将原文本的逆序（不包括最后一个字符）拼接到加密字符串的后面\n    for (size_t i = 0; i < length - 1; ++i) {\n        palindrome[length + i] = text[length - 2 - i];\n    }\n    \n    palindrome[length * 2 - 1] = '\\0'; // 添加字符串结束符\n\n    return palindrome;\n}\n\n", "test": "#include <stdio.h>\n#include <assert.h>\n\nvoid test() {\n    char *result;\n\n    // Test case 1: 加密字符串 \"racecar\"\n    result = palindromeCipher(\"racecar\");\n    // printf(\"%s\\n\",result);\n    assert(strcmp(result, \"racecaracecar\") == 0);\n    free(result);\n\n    // Test case 2: 加密字符串 \"step\"\n    result = palindromeCipher(\"step\");\n    assert(strcmp(result, \"stepets\") == 0);\n    // printf(\"%s\\n\",result);\n    free(result);\n\n    // Test case 3: 加密单个字符 \"a\"\n    result = palindromeCipher(\"a\");\n    assert(strcmp(result, \"a\") == 0);\n    // printf(\"%s\\n\",result);\n    free(result);\n\n    // Test case 4: 加密字符串 \"noon\"\n    result = palindromeCipher(\"noon\");\n    assert(strcmp(result, \"noonoon\") == 0);\n    free(result);\n\n}\n\nint main() {\n    test();\n    return 0;\n}\n\n"}
{"language": "c", "domain": "cryptography", "source": "人工提问+gpt4生成代码+人工筛选；源文件地址/data/xw/c++dataset/1.6/copy/key/0.c", "prompt": "#include <stdio.h>\n\n/* 实现一个简单的单字节异或加密函数\n输入参数为一个字符串和一个加密密钥（单字节字符）\n函数格式定义为：void xorEncrypt(char *str, char key)\nstr表示需要加密的字符串，key表示加密密钥\n加密算法是将每个字符与密钥进行异或操作\n函数不返回任何值，直接在输入的字符串上进行加密操作\n注意：加密后的字符串可能包含非打印字符\n*/\n\n", "solution": "\nvoid xorEncrypt(char *str, char key) {\n    while(*str) {\n        *str = *str ^ key;  // 对字符串中每个字符进行异或操作\n        str++;  // 移动到字符串中的下一个字符\n    }\n}\n\n", "test": "#include <assert.h>\nvoid printStrAsHex(char *str) {\n    while(*str) {\n        str++;\n    }\n}\n\nint main() {\n    char testStr1[] = \"Hello World!\";\n    char key = '!';\n\n    xorEncrypt(testStr1, key);\n\n    xorEncrypt(testStr1, key); // 再次加密应该得到原字符串\n\n    assert(testStr1[0] == 'H'); // 测试第一个字符是否恢复原值\n    assert(testStr1[1] == 'e'); // 测试第二个字符是否恢复原值\n    assert(testStr1[2] == 'l'); // 测试第三个字符是否恢复原值\n    assert(testStr1[3] == 'l'); // 测试第四个字符是否恢复原值\n    assert(testStr1[4] == 'o'); // 测试第五个字符是否恢复原值\n\n    return 0;\n}\n"}
{"language": "c", "domain": "cryptography", "source": "人工提问+gpt4生成代码+人工筛选；源文件地址/data/xw/c++dataset/1.6/copy/key/63.c", "prompt": "\n/*\n功能说明：实现异或加密和解密。使用单个字符作为密钥，对文本中的每个字符进行异或操作。\n输入参数：\n- char* text: 需要加密或解密的文本。\n- char key: 用于加密和解密的单个字符密钥。\n\n返回值：返回加密或解密后的字符串副本。\n*/\n\nchar* xorCipher(char* text, char key);\n\n", "solution": "\n#include <string.h>\n#include <stdlib.h>\n\nchar* xorCipher(char* text, char key) {\n    size_t len = strlen(text);\n    char* encrypted = (char*)malloc((len + 1) * sizeof(char));\n    \n    for (size_t i = 0; i < len; i++) {\n        encrypted[i] = text[i] ^ key;\n    }\n    encrypted[len] = '\\0';\n    \n    return encrypted;\n}\n\n", "test": "\n#include <assert.h>\n\nvoid test() {\n    char text[] = \"HELLO WORLD\";\n    char key = 'K';\n    \n    // Test case 1: Encryption\n    char* encrypted = xorCipher(text, key);\n    // The encrypted text is not human-readable and will be different\n\n    // Test case 2: Decryption equals original text\n    char* decrypted = xorCipher(encrypted, key);\n    assert(strcmp(decrypted, text) == 0);\n\n    // Test case 3: Encrypting with null key should return the same text\n    char* nullKeyEncrypted = xorCipher(text, '\\0');\n    assert(strcmp(nullKeyEncrypted, text) == 0);\n\n    // Test case 4: Decrypting the null key encryption should return the same text\n    char* nullKeyDecrypted = xorCipher(nullKeyEncrypted, '\\0');\n    assert(strcmp(nullKeyDecrypted, text) == 0);\n\n    // Test case 5: Encrypting and decrypting an empty string should return an empty string\n    char* encryptedEmpty = xorCipher(\"\", key);\n    assert(strcmp(encryptedEmpty, \"\") == 0);\n    char* decryptedEmpty = xorCipher(encryptedEmpty, key);\n    assert(strcmp(decryptedEmpty, \"\") == 0);\n\n    free(encrypted);\n    free(decrypted);\n    free(nullKeyEncrypted);\n    free(nullKeyDecrypted);\n    free(encryptedEmpty);\n    free(decryptedEmpty);\n}\n\nint main() {\n    test();\n    return 0;\n}\n\n"}
{"language": "c", "domain": "cryptography", "source": "人工提问+gpt4生成代码+人工筛选；源文件地址/data/xw/c++dataset/1.6/copy/key/83.c", "prompt": "\n/*\n功能说明：将文本字符串转换为九宫格键盘上的数字字符串。\n输入参数：\n - const char *text: 指向要转换的文本字符串。\n返回值：转换后的数字字符串。注意：调用者必须释放返回的字符串。\n*/\n#include <stddef.h>\n#include <stdlib.h>\n#include <string.h>\nchar* keypadPassword(const char *text);\n\n", "solution": "\nchar* keypadPassword(const char *text) {\n    if (text == NULL) {\n        return NULL;\n    }\n\n    size_t length = strlen(text);\n    char *password = (char*)malloc(length + 1); // 分配内存\n    if (password == NULL) {\n        return NULL;\n    }\n\n    for (size_t i = 0; i < length; ++i) {\n        if (text[i] >= 'a' && text[i] <= 'c') {\n            password[i] = '2';\n        } else if (text[i] >= 'd' && text[i] <= 'f') {\n            password[i] = '3';\n        } else if (text[i] >= 'g' && text[i] <= 'i') {\n            password[i] = '4';\n        } else if (text[i] >= 'j' && text[i] <= 'l') {\n            password[i] = '5';\n        } else if (text[i] >= 'm' && text[i] <= 'o') {\n            password[i] = '6';\n        } else if (text[i] >= 'p' && text[i] <= 's') {\n            password[i] = '7';\n        } else if (text[i] >= 't' && text[i] <= 'v') {\n            password[i] = '8';\n        } else if (text[i] >= 'w' && text[i] <= 'z') {\n            password[i] = '9';\n        } else {\n            // 对于非字母字符，可以选择保留原字符或转换为特定数字\n            password[i] = text[i]; // 在这里，我们选择保留原字符\n        }\n    }\n    \n    password[length] = '\\0';\n    return password;\n}\n\n", "test": "\n#include <assert.h>\n#include <string.h>\n\nvoid test() {\n    char *result;\n\n    // Test case 1: 转换单词 \"hello\"\n    result = keypadPassword(\"hello\");\n    assert(strcmp(result, \"43556\") == 0);\n    free(result);\n\n    // Test case 2: 转换单词 \"password\"\n    result = keypadPassword(\"password\");\n    assert(strcmp(result, \"72779673\") == 0);\n    free(result);\n\n    // Test case 3: 转换包含非字母字符的字符串\n    result = keypadPassword(\"abc!def\");\n    assert(strcmp(result, \"222!333\") == 0);\n    free(result);\n\n    // Test case 4: 转换空字符串\n    result = keypadPassword(\"\");\n    assert(strcmp(result, \"\") == 0);\n    free(result);\n\n    // Test case 5: 转换全部9个数字对应的字母\n    result = keypadPassword(\"abcdefghi\");\n    assert(strcmp(result, \"222333444\") == 0);\n    free(result);\n}\n\nint main() {\n    test();\n    return 0;\n}\n\n"}
{"language": "c", "domain": "cryptography", "source": "人工提问+gpt4生成代码+人工筛选；源文件地址/data/xw/c++dataset/1.6/copy/key/3.c", "prompt": "#include <stdio.h>\n#include <string.h>\n\n/* 实现一个简单的替换密码加密函数\n输入参数为一个字符串和代换表数组\n函数格式定义为：void substitutionEncrypt(char *str, const char *substitutionTable)\nstr表示需要加密的字符串\nsubstitutionTable表示26个英文字母的代换表，例如substitutionTable['A' - 'A']表示'A'的代换字母\n函数不返回任何值，直接在输入的字符串上进行加密操作\n注意：这里仅处理大写字母，且假定输入字符串已经全部转换为大写\n*/\n\n", "solution": "\nvoid substitutionEncrypt(char *str, const char *substitutionTable) {\nwhile(*str) {\nif (*str >= 'A' && *str <= 'Z') {\n*str = substitutionTable[*str - 'A'];\n}\nstr++; // 移动到字符串中的下一个字符\n}\n}\n\n", "test": "\n#include <assert.h>\n\nint main() {\nconst char substitutionTable[26] = {\n'Q', 'W', 'E', 'R', 'T', 'Y', 'U', 'I', 'O', 'P',\n'A', 'S', 'D', 'F', 'G', 'H', 'J', 'K', 'L', 'Z',\n'X', 'C', 'V', 'B', 'N', 'M'\n};\n\nchar testStr1[] = \"HELLO WORLD\";\nsubstitutionEncrypt(testStr1, substitutionTable);\n// printf(\"%s\\n\", testStr1); // 输出加密后的字符串\n\n// 加密后字符串的验证\nassert(testStr1[0] == 'I');\nassert(testStr1[1] == 'T');\nassert(testStr1[2] == 'S');\nassert(testStr1[3] == 'S');\nassert(testStr1[4] == 'G');\n\nreturn 0;\n}\n"}
{"language": "c", "domain": "cryptography", "source": "人工提问+gpt4生成代码+人工筛选；源文件地址/data/xw/c++dataset/1.6/copy/key/85.c", "prompt": "\n/*\n功能说明：在原始密码字符串中随机位置插入随机字符，生成新的密码字符串。\n输入参数：\n - const char *password: 指向原始密码字符串。\n - const char *randomChars: 指向随机字符序列。\n返回值：生成的新密码字符串。注意：调用者必须释放返回的字符串。\n*/\n\nchar* insertRandomChars(const char *password, const char *randomChars);\n\n", "solution": "\n#include <stdlib.h>\n#include <string.h>\n#include <time.h>\n\nchar* insertRandomChars(const char *password, const char *randomChars) {\n    srand(time(NULL)); // 初始化随机数生成器\n    int passLen = strlen(password);\n    int randLen = strlen(randomChars);\n    int newLen = passLen + randLen;\n\n    char *newPassword = malloc(newLen + 1); // 分配新密码字符串的内存\n    if (!newPassword) return NULL;\n\n    int randIndex = 0; // 随机字符的索引\n    for (int i = 0, j = 0; i < passLen; ++i) {\n        newPassword[j++] = password[i];\n        if (randIndex < randLen) {\n            newPassword[j++] = randomChars[randIndex++];\n        }\n    }\n    newPassword[newLen] = '\\0'; // 添加字符串结束标志\n\n    return newPassword;\n}\n\n", "test": "\n#include <assert.h>\n\nvoid test() {\n    char *newPassword;\n\n    // Test case 1: 插入随机字符到原始密码\n    newPassword = insertRandomChars(\"password\", \"12345678\");\n    assert(strlen(newPassword) == 16);\n    free(newPassword);\n\n    // Test case 2: 原始密码为空\n    newPassword = insertRandomChars(\"\", \"1234\");\n    assert(strlen(newPassword) == 0);\n    free(newPassword);\n\n    // Test case 3: 随机字符为空\n    newPassword = insertRandomChars(\"password\", \"\");\n    assert(strcmp(newPassword, \"password\") == 0);\n    free(newPassword);\n\n    // Test case 4: 随机字符数量少于原始密码长度\n    newPassword = insertRandomChars(\"pass\", \"123\");\n    assert(strlen(newPassword) == 7);\n    free(newPassword);\n\n    // Test case 5: 原始密码和随机字符都为空\n    newPassword = insertRandomChars(\"\", \"\");\n    assert(strlen(newPassword) == 0);\n    free(newPassword);\n}\n\nint main() {\n    test();\n    return 0;\n}\n\n"}
{"language": "c", "domain": "cryptography", "source": "人工提问+gpt4生成代码+人工筛选；源文件地址/data/xw/c++dataset/1.6/copy/key/62.c", "prompt": "\n/*\n功能说明：实现代换密码的加密和解密。加密时将每个字母替换为密钥中对应的字母，解密则反向替换。\n输入参数：\n- char* text: 需要加密或解密的文本。\n- char* key: 用于加密和解密的密钥，一个包含A-Z字母的乱序数组，用于替换原始信息。\n- int encrypt: 非0表示加密，0表示解密。\n\n返回值：返回加密或解密后的字符串副本。\n*/\n\nchar* substitutionCipher(char* text, char* key, int encrypt);\n\n", "solution": "\n#include <string.h>\n#include <stdlib.h>\n#include <ctype.h>\n\nchar* substitutionCipher(char* text, char* key, int encrypt) {\n    char* result = (char*)malloc((strlen(text) + 1) * sizeof(char));\n    char alphabet[27] = \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\";\n    int textLength = strlen(text);\n\n    for (int i = 0; i < textLength; ++i) {\n        if (isalpha(text[i])) {\n            char upperChar = toupper(text[i]);\n            char* subChar = encrypt ? strchr(alphabet, upperChar) : strchr(key, upperChar);\n            int index = subChar - (encrypt ? alphabet : key);\n            result[i] = encrypt ? key[index] : alphabet[index];\n        } else {\n            result[i] = text[i];\n        }\n        if (islower(text[i])) {\n            result[i] = tolower(result[i]);\n        }\n    }\n    result[textLength] = '\\0';\n    return result;\n}\n\n", "test": "\n#include <assert.h>\n\nvoid test() {\n    char text[] = \"HELLO WORLD\";\n    char key[] = \"QWERTYUIOPASDFGHJKLZXCVBNM\";\n    \n    // Test case 1: Encryption\n    char* encrypted = substitutionCipher(text, key, 1);\n    assert(strcmp(encrypted, \"ITSSG VGKSR\") == 0);\n\n    // Test case 2: Decryption\n    char* decrypted = substitutionCipher(encrypted, key, 0);\n    // printf(\"%s\\n\",decrypted);\n    assert(strcmp(decrypted, text) == 0);\n\n    // Test case 3: Encryption with non-letter characters\n    char textWithSymbols[] = \"HELLO, WORLD!\";\n    char* encryptedWithSymbols = substitutionCipher(textWithSymbols, key, 1);\n    // printf(\"%s\\n\",encryptedWithSymbols);\n    assert(strcmp(encryptedWithSymbols, \"ITSSG, VGKSR!\") == 0);\n\n    // Test case 4: Decryption with non-letter characters\n    char* decryptedWithSymbols = substitutionCipher(encryptedWithSymbols, key, 0);\n    assert(strcmp(decryptedWithSymbols, textWithSymbols) == 0);\n\n    // Test case 5: Case sensitivity check\n    char mixedCaseText[] = \"HeLlO WoRlD\";\n    char* encryptedMixedCase = substitutionCipher(mixedCaseText, key, 1);\n    // printf(\"%s\\n\",encryptedMixedCase);\n    assert(strcmp(encryptedMixedCase, \"ItSsG VgKsR\") == 0);\n\n    free(encrypted);\n    free(decrypted);\n    free(encryptedWithSymbols);\n    free(decryptedWithSymbols);\n    free(encryptedMixedCase);\n}\n\nint main() {\n    test();\n    return 0;\n}\n\n"}
{"language": "c", "domain": "cryptography", "source": "人工提问+gpt4生成代码+人工筛选；源文件地址/data/xw/c++dataset/1.6/copy/key/71.c", "prompt": "\n/*\n功能说明：使用RSA算法对文本进行加密和解密。\n输入参数：\n- int message: 待加密或解密的消息（通常是消息的数字表示形式）。\n- int key: 公钥或私钥。\n- int modulus: 模数。\n\n返回值：返回加密或解密后的消息。\n*/\n\nint rsaCrypt(int message, int key, int modulus);\n\n", "solution": "\n#include <math.h>\n\nint modPow(int base, int exponent, int modulus) {\n    int result = 1;\n    while (exponent > 0) {\n        if (exponent % 2 == 1) {\n            result = (result * base) % modulus;\n        }\n        exponent = exponent >> 1;\n        base = (base * base) % modulus;\n    }\n    return result;\n}\n\nint rsaCrypt(int message, int key, int modulus) {\n    // Normally RSA would use very large integers, but for simplicity, this example uses int\n    return modPow(message, key, modulus);\n}\n\n", "test": "\n#include <assert.h>\n\nvoid test() {\n    int p = 61; // First prime\n    int q = 53; // Second prime\n    int n = p * q; // Modulus\n    int e = 17; // Public key exponent\n    int d = 2753; // Private key exponent (Calculated for the given p, q, and e)\n\n    // Encrypt the message 'm' with the public key 'e'\n    int m = 42; // Example message to encrypt and decrypt\n    int encrypted = rsaCrypt(m, e, n);\n    \n    // Decrypt the message with the private key 'd'\n    int decrypted = rsaCrypt(encrypted, d, n);\n\n    // Test case 1: Encryption\n    assert(encrypted == modPow(m, e, n));\n\n    // Test case 2: Decryption\n    assert(decrypted == m);\n\n    // Test case 3-5: More tests with different messages\n    int m2 = 12;\n    int encrypted2 = rsaCrypt(m2, e, n);\n    int decrypted2 = rsaCrypt(encrypted2, d, n);\n    assert(decrypted2 == m2);\n\n    int m3 = 123;\n    int encrypted3 = rsaCrypt(m3, e, n);\n    int decrypted3 = rsaCrypt(encrypted3, d, n);\n    assert(decrypted3 == m3);\n\n    int m4 = 7;\n    int encrypted4 = rsaCrypt(m4, e, n);\n    int decrypted4 = rsaCrypt(encrypted4, d, n);\n    assert(decrypted4 == m4);\n}\n\nint main() {\n    test();\n    return 0;\n}\n\n"}
{"language": "c", "domain": "cryptography", "source": "人工提问+gpt4生成代码+人工筛选；源文件地址/data/xw/c++dataset/1.6/copy/key/91.c", "prompt": "\n/*\n功能说明：实现一个字母位元翻转密码（Letter Bit-Flip Cipher）。该密码通过翻转字母在ASCII表中的二进制表示的最低位（即第0位）来加密文本。\n         例如，字母'A'的ASCII码是65（二进制：01000001），翻转最低位后变为66（二进制：01000010），对应的字符是'B'。\n         对于小写字母，同样的规则适用。例如，'a'（ASCII码97，二进制：01100001）翻转最低位后变为'b'。\n         函数只处理字母字符，非字母字符应保持不变。\n\n输入参数：\n - const char *input: 指向原始输入字符串的指针。\n返回值：返回一个新字符串，它是输入字符串每个字母按位翻转后的结果。注意：调用者必须释放此字符串。\n\n函数原型示例：\nchar* letterBitFlipCipher(const char* input);\n\n例如：输入\"Hello, World!\"将返回\"Ifmmp, Xpsme!\"。\n\n注意：在ASCII表中，大写和小写字母的最低位都是0，翻转后变为1，字母向后移动一个位置。\n*/\n\n", "solution": "\n#include <stdlib.h>\n#include <string.h>\n#include <ctype.h>\n\nchar* letterBitFlipCipher(const char* input) {\n    if (input == NULL) return NULL;\n    \n    size_t inputLen = strlen(input);\n    char* encrypted = malloc(inputLen + 1); // Include space for the null terminator\n    if (!encrypted) {\n        return NULL;\n    }\n\n    for (size_t i = 0; i < inputLen; ++i) {\n        if (isalpha(input[i])) {\n            // Flip the least significant bit (LSB) of the letter\n            encrypted[i] = input[i] ^ 1;\n        } else {\n            encrypted[i] = input[i]; // Non-alphabetic characters are unchanged\n        }\n    }\n    \n    encrypted[inputLen] = '\\0'; // Null-terminate the encrypted string\n    return encrypted;\n}\n\n", "test": "\n#include <assert.h>\n\nvoid test() {\n    char* result;\n\n    // Test case 1: Lowercase and uppercase alphabet characters\n    result = letterBitFlipCipher(\"AbZz\");\n    assert(strcmp(result, \"@c[{\") == 0); // 'A'->'B', 'b'->'c', 'Z'->'A', 'z'->'a'\n    free(result);\n\n    // Test case 2: Non-alphabet characters remain unchanged\n    result = letterBitFlipCipher(\"1234!@#$\");\n    assert(strcmp(result, \"1234!@#$\") == 0);\n    free(result);\n\n    // Test case 3: Mixed characters\n    result = letterBitFlipCipher(\"Hello, World!\");\n    assert(strcmp(result, \"Idmmn, Vnsme!\") == 0); // Alphabets have shifted, other chars are the same\n    free(result);\n\n    // Test case 4: Empty string\n    result = letterBitFlipCipher(\"\");\n    assert(strcmp(result, \"\") == 0);\n    free(result);\n\n    // Test case 5: String with spaces\n    result = letterBitFlipCipher(\"A B C\");\n    assert(strcmp(result, \"@ C B\") == 0); // Spaces are non-alphabet and remain unchanged\n    free(result);\n}\n\nint main() {\n    test();\n    return 0;\n}\n\n"}
{"language": "c", "domain": "cryptography", "source": "人工提问+gpt4生成代码+人工筛选；源文件地址/data/xw/c++dataset/1.6/copy/key/96.c", "prompt": "\n/*\n功能说明：\n实现一个简单的字母逻辑运算密码。对两个相同长度的字符串进行逻辑运算，得到一个新的字符串。\n字符串仅包含小写字母。逻辑运算定义如下：\n- 'a' 和 'a' 的逻辑运算结果是 'a'\n- 'a' 和 'b' 的逻辑运算结果是 'z'\n\n逻辑运算是逐字符进行的。如果两个字符相同，结果字符与输入字符相同。如果不同，结果字符是 'z'。\n\n输入参数：\n - const char* str1: 第一个字符串，仅包含小写字母。\n - const char* str2: 第二个字符串，仅包含小写字母，且与第一个字符串长度相同。\n\n返回值：返回一个新字符串，它是两个输入字符串逐字符逻辑运算的结果。注意：调用者必须释放此字符串。\n\n函数原型示例：\nchar* letterLogicEncrypt(const char* str1, const char* str2);\n\n例如：输入字符串\"abc\"和\"abc\"逻辑运算将返回\"abc\"。\n输入字符串\"abc\"和\"abd\"逻辑运算将返回\"abz\"。\n*/\n\n", "solution": "\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\nchar* letterLogicEncrypt(const char* str1, const char* str2) {\n    if (!str1 || !str2 || strlen(str1) != strlen(str2)) return NULL;\n    \n    size_t length = strlen(str1);\n    char* encrypted = (char*)malloc(length + 1);\n    if (!encrypted) return NULL;\n\n    for (size_t i = 0; i < length; ++i) {\n        encrypted[i] = (str1[i] == str2[i]) ? str1[i] : 'z';\n    }\n    encrypted[length] = '\\0';\n\n    return encrypted;\n}\n\n", "test": "\n#include <assert.h>\n\nvoid test() {\n    char* result;\n\n    // Test case 1: Strings with same characters\n    result = letterLogicEncrypt(\"abc\", \"abc\");\n    assert(strcmp(result, \"abc\") == 0);\n    free(result);\n\n    // Test case 2: Strings with different characters\n    result = letterLogicEncrypt(\"abc\", \"abd\");\n    assert(strcmp(result, \"abz\") == 0);\n    free(result);\n\n    // Test case 3: Strings with all different characters\n    result = letterLogicEncrypt(\"abc\", \"def\");\n    assert(strcmp(result, \"zzz\") == 0);\n    free(result);\n\n    // Test case 4: Strings with a mix of same and different characters\n    result = letterLogicEncrypt(\"abcdef\", \"abcxyz\");\n    assert(strcmp(result, \"abczzz\") == 0);\n    free(result);\n\n    // Test case 5: Strings with single character\n    result = letterLogicEncrypt(\"a\", \"a\");\n    assert(strcmp(result, \"a\") == 0);\n    free(result);\n}\n\nint main() {\n    test();\n    return 0;\n}\n\n"}
{"language": "c", "domain": "cryptography", "source": "人工提问+gpt4生成代码+人工筛选；源文件地址/data/xw/c++dataset/1.6/copy/key/87.c", "prompt": "\n/*\n功能说明：根据键盘行位移规则生成密码。\n输入参数：\n - const char *input: 指向原始输入字符串。\n返回值：根据键盘行位移规则生成的密码字符串。注意：调用者必须释放返回的字符串。\n*/\n\nchar* keyboardRowShiftPassword(const char *input);\n\n", "solution": "\n#include <string.h>\n#include <stdlib.h>\n#include <ctype.h>\nchar* keyboardRowShiftPassword(const char *input) {\n    const char *keyboardRows[] = {\n        \"qwertyuiop\",\n        \"asdfghjkl\",\n        \"zxcvbnm\",\n        // 可以添加数字行和符号行，如果需要\n    };\n    int num_rows = sizeof(keyboardRows) / sizeof(keyboardRows[0]);\n    int inputLen = strlen(input);\n    char *password = malloc(inputLen + 1); // +1 for null terminator\n\n    if (!password) return NULL;\n\n    for (int i = 0; i < inputLen; ++i) {\n        char c = input[i];\n        for (int row = 0; row < num_rows; ++row) {\n            char *found = strchr(keyboardRows[row], tolower(c));\n            if (found) {\n                int pos = (found - keyboardRows[row] + 1) % strlen(keyboardRows[row]); // 循环位移\n                c = keyboardRows[row][pos];\n                // 如果原始字符是大写的，转换为大写\n                if (isupper(input[i])) {\n                    c = toupper(c);\n                }\n                break;\n            }\n        }\n        password[i] = c; // 可能包括未找到的字符，例如数字和符号\n    }\n    password[inputLen] = '\\0';\n    return password;\n}\n\n", "test": "\n#include <assert.h>\n\nvoid test() {\n    // 注意：以下测试用例假设函数只处理小写字母\n    // 如果函数需要处理大写字母、数字和符号，测试用例需要做相应的调整\n\n    char *result;\n\n    // Test case 1: 处理小写字母\n    result = keyboardRowShiftPassword(\"password\");\n    assert(strcmp(result, \"qsddeptf\") == 0);\n    free(result);\n\n    // Test case 2: 处理跨越行末的字母\n    result = keyboardRowShiftPassword(\"pinky\");\n    assert(strcmp(result, \"qomlu\") == 0);\n    free(result);\n\n    // Test case 3: 处理前一行的字母\n    result = keyboardRowShiftPassword(\"keyboard\");\n    assert(strcmp(result, \"lrunpstf\") == 0);\n    free(result);\n\n    // Test case 4: 包含未在行中找到的字符（如数字或符号）\n    result = keyboardRowShiftPassword(\"hello!2\");\n    // 假设这里的实现不处理非字母字符，所以字符'!'和'2'保持不变\n    assert(strcmp(result, \"jraap!2\") == 0);\n    free(result);\n\n    // Test case 5: 包含大写字母的情况\n    result = keyboardRowShiftPassword(\"HelloWorld\");\n    // 假设这里的实现处理大写字母\n    assert(strcmp(result, \"JraapEptaf\") == 0);\n    free(result);\n}\n\nint main() {\n    test();\n    return 0;\n}\n\n"}
{"language": "c", "domain": "cryptography", "source": "人工提问+gpt4生成代码+人工筛选；源文件地址/data/xw/c++dataset/1.6/copy/key/99.c", "prompt": "\n/*\n功能说明：\n实现一个精简版的Playfair密码加密函数。Playfair密码是一种使用5x5矩阵的双字母替换加密算法，这里我们做一个简化的版本。\n在这个版本中：\n- 使用一个固定的5x5矩阵，包含字母A到Y，忽略字母Z。\n- 加密过程中，将文本分为两个字母一组，不足一组的末尾添加'X'。\n- 如果一组中两个字母相同或者只有一个字母，则添加'X'分开。\n- 对于每一对字母，首先在矩阵中找到它们的位置。\n- 如果字母在同一行，则每个字母向右移动一格进行替换（如果已经在行的末尾，则移动到行的开始）。\n- 如果字母在同一列，则每个字母向下移动一格进行替换（如果已经在列的末尾，则移动到列的开始）。\n- 如果字母不在同一行或同一列，则每个字母移动到由另一个字母所在行和自己所在列形成的新位置。\n\n输入参数：\n - const char* plaintext: 需要加密的文本，文本为大写，不含空格和非英文字母字符。\n\n返回值：返回一个新的大写字符串，它是根据简化版Playfair加密方法加密后的文本。注意：调用者必须释放此字符串。\n\n函数原型示例：\nchar* simplifiedPlayfairCipher(const char* plaintext);\n\n例如：输入文本\"HELLO\"将返回\"IFMMP\"。\n*/\n\n", "solution": "\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <ctype.h>\n\nchar* simplifiedPlayfairCipher(const char* plaintext) {\n    const char matrix[5][5] = {\n        {'A', 'B', 'C', 'D', 'E'},\n        {'F', 'G', 'H', 'I', 'J'},\n        {'K', 'L', 'M', 'N', 'O'},\n        {'P', 'Q', 'R', 'S', 'T'},\n        {'U', 'V', 'W', 'X', 'Y'}\n    };\n    \n    int length = strlen(plaintext);\n    // 加密文本长度最多为原文长度的2倍\n    char* encrypted = (char*)malloc(length * 2 + 1);\n    if (!encrypted) return NULL;\n\n    int count = 0; // 加密文本的索引计数\n    for (int i = 0; i < length; i += 2) {\n        char a = plaintext[i];\n        char b = (i + 1 < length) ? plaintext[i + 1] : 'X'; // 不足一对的填充'X'\n\n        if (a == b) { // 如果一对中两个字母相同，分开并填充'X'\n            b = 'X';\n        }\n\n        int a_row, a_col, b_row, b_col;\n        // 找到每个字母在矩阵中的位置\n        for (int row = 0; row < 5; ++row) {\n            for (int col = 0; col < 5; ++col) {\n                if (matrix[row][col] == a) {\n                    a_row = row;\n                    a_col = col;\n                }\n                if (matrix[row][col] == b) {\n                    b_row = row;\n                    b_col = col;\n                }\n            }\n        }\n\n        // 加密规则\n        if (a_row == b_row) {\n            encrypted[count++] = matrix[a_row][(a_col + 1) % 5];\n            encrypted[count++] = matrix[b_row][(b_col + 1) % 5];\n        } else if (a_col == b_col) {\n            encrypted[count++] = matrix[(a_row + 1) % 5][a_col];\n            encrypted[count++] = matrix[(b_row + 1) % 5][b_col];\n        } else {\n            encrypted[count++] = matrix[a_row][b_col];\n            encrypted[count++] = matrix[b_row][a_col];\n        }\n        // 处理只有一个字母的情况\n        if (a == b) {\n            encrypted[count++] = matrix[b_row][(b_col + 1) % 5];\n        }\n    }\n    encrypted[count] = '\\0'; // Null-terminate the encrypted string\n\n    return encrypted;\n}\n\n", "test": "\n#include <assert.h>\n\nvoid test() {\n    char* result;\n\n    // Test case 1\n    result = simplifiedPlayfairCipher(\"HELLO\");\n    assert(strcmp(result, \"JCNVNY\") == 0);\n    free(result);\n\n    // Test case 2\n    result = simplifiedPlayfairCipher(\"GOODBYE\");\n    assert(strcmp(result, \"JLNEEVDY\") == 0);\n    free(result);\n\n    // Test case 3\n    result = simplifiedPlayfairCipher(\"PLAYFAIR\");\n    assert(strcmp(result, \"QKEUKFHS\") == 0);\n    free(result);\n\n    // Test case 4\n    result = simplifiedPlayfairCipher(\"CIPHER\");\n    assert(strcmp(result, \"DHRFCT\") == 0);\n    free(result);\n\n    // Test case 5\n    result = simplifiedPlayfairCipher(\"ABC\");\n    assert(strcmp(result, \"BCDW\") == 0);\n    free(result);  \n}\n\nint main() {\n    test();\n    return 0;\n}\n\n"}
{"language": "c", "domain": "cryptography", "source": "人工提问+gpt4生成代码+人工筛选；源文件地址/data/xw/c++dataset/1.6/copy/key/80.c", "prompt": "\n/*\n功能说明：对字符串中的每个字符应用乘法密码。\n输入参数：\n - const char *text: 指向要加密的字符串。\n - int key: 用于乘以每个字符的密钥。\n返回值：加密后的字符串。注意：调用者必须释放返回的字符串。\n*/\n\nchar* multiplyCipher(const char *text, int key);\n\n", "solution": "\n#include <stdlib.h>\n#include <string.h>\n\nchar* multiplyCipher(const char *text, int key) {\n    if (text == NULL) return NULL;\n    \n    size_t length = strlen(text);\n    char *encryptedText = (char*)malloc(length + 1); // 分配内存保存加密文本\n    if (encryptedText == NULL) return NULL;\n\n    for (size_t i = 0; i < length; ++i) {\n        // 用字符的ASCII值乘以key，并将结果模上256，以便保持在unsigned char的范围内\n        encryptedText[i] = (char)((unsigned char)text[i] * key % 256);\n    }\n    encryptedText[length] = '\\0'; // 添加字符串结束符\n\n    return encryptedText;\n}\n\n", "test": "\n#include <assert.h>\n\nvoid test() {\n    char *result;\n\n    // Test case 1: 加密字符 'a' 使用密钥 3\n    result = multiplyCipher(\"a\", 3);\n    assert(result[0] == ('a' * 3 % 256));\n    free(result);\n\n    // Test case 2: 加密字符串 \"hello\" 使用密钥 2\n    result = multiplyCipher(\"hello\", 2);\n    // assert(strcmp(result, \"\\x98\\xf0\\xf6\\xf6\\xfc\") == 0);\n    free(result);\n\n    // Test case 3: 加密字符串 \"test\" 使用密钥 1 (无变化)\n    result = multiplyCipher(\"test\", 1);\n    assert(strcmp(result, \"test\") == 0);\n    free(result);\n\n    // Test case 4: 加密空字符串使用任意密钥\n    result = multiplyCipher(\"\", 5);\n    assert(strcmp(result, \"\") == 0);\n    free(result);\n\n    // Test case 5: 加密字符串 \"abc\" 使用密钥 0 (所有字符变为 '\\0')\n    result = multiplyCipher(\"abc\", 0);\n    assert(result[0] == '\\0' && result[1] == '\\0' && result[2] == '\\0');\n    free(result);\n}\n\nint main() {\n    test();\n    return 0;\n}\n\n"}
{"language": "c", "domain": "cryptography", "source": "人工提问+gpt4生成代码+人工筛选；源文件地址/data/xw/c++dataset/1.6/copy/key/100.c", "prompt": "\n/*\n功能说明：\n实现一个带盐的散列函数。所谓“盐”是一个随机字符串，它与用户的密码组合在一起，然后整体进行散列处理，这样即使两个用户使用了相同的密码，由于盐值不同，最终生成的散列值也会不同。\n\n输入参数：\n - const char* password: 用户的密码，一个以空字符结尾的字符串。\n - const char* salt: 盐值，一个以空字符结尾的字符串。\n\n返回值：返回一个新字符串，它是密码和盐值组合后的散列结果。注意：调用者必须释放此字符串。\n\n函数原型示例：\nchar* hashWithSalt(const char* password, const char* salt);\n\n散列函数可以使用简单的哈希算法，例如将字符串中每个字符的ASCII值相加。\n\n例如：输入密码\"password\"和盐\"1234\"，可以返回它们组合后字符串\"password1234\"的简单散列值。\n*/\n\n", "solution": "\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\nunsigned long simpleHashFunction(const char* str) {\n    unsigned long hash = 5381;\n    int c;\n\n    while ((c = *str++))\n        hash = ((hash << 5) + hash) + c; // hash * 33 + c\n\n    return hash;\n}\n\nchar* hashWithSalt(const char* password, const char* salt) {\n    size_t combined_length = strlen(password) + strlen(salt);\n    char* combined = (char*)malloc(combined_length + 1);\n    if (!combined) return NULL;\n\n    strcpy(combined, password);\n    strcat(combined, salt);\n\n    unsigned long hashValue = simpleHashFunction(combined);\n    free(combined);\n\n    // 将散列值转换为字符串\n    char* hashString = (char*)malloc(20); // 足够存储unsigned long散列值的字符串\n    if (!hashString) return NULL;\n    sprintf(hashString, \"%lu\", hashValue);\n\n    return hashString;\n}\n\n", "test": "\n#include <assert.h>\n\nvoid test() {\n    char* result;\n\n    // Test case 1\n    result = hashWithSalt(\"password\", \"1234\");\n    unsigned long expected_hash_1 = simpleHashFunction(\"password1234\");\n    char expected_string_1[20];\n    sprintf(expected_string_1, \"%lu\", expected_hash_1);\n    assert(strcmp(result, expected_string_1) == 0);\n    free(result);\n\n    // Test case 2\n    result = hashWithSalt(\"admin\", \"salt\");\n    unsigned long expected_hash_2 = simpleHashFunction(\"adminsalt\");\n    char expected_string_2[20];\n    sprintf(expected_string_2, \"%lu\", expected_hash_2);\n    assert(strcmp(result, expected_string_2) == 0);\n    free(result);\n\n    // Test case 3\n    result = hashWithSalt(\"user\", \"unique_salt\");\n    unsigned long expected_hash_3 = simpleHashFunction(\"userunique_salt\");\n    char expected_string_3[20];\n    sprintf(expected_string_3, \"%lu\", expected_hash_3);\n    assert(strcmp(result, expected_string_3) == 0);\n    free(result);\n\n    // Test case 4\n    result = hashWithSalt(\"test123\", \"another_salt\");\n    unsigned long expected_hash_4 = simpleHashFunction(\"test123another_salt\");\n    char expected_string_4[20];\n    sprintf(expected_string_4, \"%lu\", expected_hash_4);\n    assert(strcmp(result, expected_string_4) == 0);\n    free(result);\n\n    // Test case 5\n    result = hashWithSalt(\"mypassword\", \"1234\");\n    unsigned long expected_hash_5 = simpleHashFunction(\"mypassword1234\");\n    char expected_string_5[20];\n    sprintf(expected_string_5, \"%lu\", expected_hash_5);\n    assert(strcmp(result, expected_string_5) == 0);\n    free(result);\n}\n\nint main() {\n    test();\n    return 0;\n}\n\n"}
{"language": "c", "domain": "cryptography", "source": "人工提问+gpt4生成代码+人工筛选；源文件地址/data/xw/c++dataset/1.6/copy/key/75.c", "prompt": "\n/*\n功能说明：根据给定的关键词对字符串进行基于关键词的凯撒密码加密或解密。\n输入参数：\n - char *text: 指向要加密或解密的字符串。\n - const char *keyword: 密钥关键词，决定每个字母的位移数。\n - int encrypt: 操作模式，1代表加密，0代表解密。\n返回值：操作后的字符串。\n*/\n#include <string.h>\n#include <ctype.h>\nchar* keywordCaesarCipher(char *text, const char *keyword, int encrypt);\n\n", "solution": "\nchar* keywordCaesarCipher(char *text, const char *keyword, int encrypt) {\n    int textLen = strlen(text);\n    int keywordLen = strlen(keyword);\n    int shift, i, keywordIndex;\n\n    for (i = 0; i < textLen; ++i) {\n        if (isalpha(text[i])) {\n            keywordIndex = i % keywordLen;\n            shift = tolower(keyword[keywordIndex]) - 'a' + 1;\n            shift = encrypt ? shift : -shift;\n\n            if (islower(text[i])) {\n                text[i] = 'a' + (text[i] - 'a' + shift + 26) % 26;\n            } else {\n                text[i] = 'A' + (text[i] - 'A' + shift + 26) % 26;\n            }\n        }\n    }\n\n    return text;\n}\n\n", "test": "\n#include <assert.h>\n#include <ctype.h>\n#include <stdio.h>\n\nvoid test() {\n    char text1[] = \"Hello World\";\n    const char *keyword1 = \"AXZ\";\n\n    // Test case 1: 加密\n    char *encryptedText1 = keywordCaesarCipher(text1, keyword1, 1);\n    assert(strcmp(encryptedText1, \"Iclmm Xmrmb\") == 0);\n    // printf(\"%s\\n\",encryptedText1);\n\n    // Test case 2: 解密\n    char *decryptedText1 = keywordCaesarCipher(encryptedText1, keyword1, 0);\n    assert(strcmp(decryptedText1, \"Hello World\") == 0);\n\n    // Test case 3: 加密使用不同关键词\n    char text2[] = \"Secret Message\";\n    const char *keyword2 = \"KEY\";\n    char *encryptedText2 = keywordCaesarCipher(text2, keyword2, 1);\n    assert(strcmp(encryptedText2, \"Djbcjs Rddxzrj\") == 0);\n    // printf(\"%s\\n\",encryptedText2);\n\n    // Test case 4: 解密使用不同关键词\n    char *decryptedText2 = keywordCaesarCipher(encryptedText2, keyword2, 0);\n    assert(strcmp(decryptedText2, \"Secret Message\") == 0);\n\n    // Test case 5: 关键词与文字相等长度\n    char text3[] = \"Same Length\";\n    const char *keyword3 = \"KEYKEYKEYKE\";\n    char *encryptedText3 = keywordCaesarCipher(text3, keyword3, 1);\n    assert(strcmp(encryptedText3, \"Dflp Kpsfem\") == 0);\n    // printf(\"%s\\n\",encryptedText3);\n}\n\nint main() {\n    test();\n    return 0;\n}\n\n"}
{"language": "c", "domain": "game", "source": "人工提问+gpt4生成代码+人工筛选；源文件地址/data/xw/c++dataset/1.6/copy/game/110.c", "prompt": "\n/*\n功能说明：\n在桥牌游戏中，玩家需要评估他们手中的牌的点数。点数是这样计算的：Aces值4点，Kings值3点，Queens值2点，Jacks值1点，其他牌不计分。\n实现一个函数来计算并返回一个桥牌手牌的总点数。\n\n输入参数：\n1. char* hand: 一个字符串数组，表示一手桥牌，每个字符表示一张牌的等级（'A'代表Ace，'K'代表King，'Q'代表Queen，'J'代表Jack，'T'代表10，其余字符代表其他牌）。\n\n返回值：整数，表示手牌的总点数。\n\n函数原型示例：\nint evaluateBridgeHand(char* hand);\n\n例如：如果手牌为\"AKQJT98765432\"，函数应该返回10。\n*/\n\n", "solution": "\nint evaluateBridgeHand(char* hand) {\n    int points = 0;\n    char card;\n\n    while ((card = *hand++) != '\\0') {\n        switch (card) {\n            case 'A':\n                points += 4;\n                break;\n            case 'K':\n                points += 3;\n                break;\n            case 'Q':\n                points += 2;\n                break;\n            case 'J':\n                points += 1;\n                break;\n            default:\n                // No points for other cards\n                break;\n        }\n    }\n\n    return points;\n}\n\n", "test": "#include <assert.h>\nvoid test() {\n    // Test case 1: Hand with all high cards \n    assert(evaluateBridgeHand(\"AKQJT\") == 10);\n\n    // Test case 2: Hand with no high cards\n    assert(evaluateBridgeHand(\"98765432\") == 0);\n\n    // Test case 3: Hand with mixed cards\n    assert(evaluateBridgeHand(\"AKQJT98765432\") == 10);\n\n    // Test case 4: Hand with multiple high cards of the same rank\n    assert(evaluateBridgeHand(\"AAKKQQJJ\") == 20);\n\n    // Test case 5: Hand with one of each high card\n    assert(evaluateBridgeHand(\"AKQJ\") == 10);\n}\nint main() {\n    test();\n    return 0;\n}\n"}
{"language": "c", "domain": "game", "source": "人工提问+gpt4生成代码+人工筛选；源文件地址/data/xw/c++dataset/1.6/copy/game/129.c", "prompt": "\n/*\n功能说明：\n在迷宫游戏中，玩家从起点出发，需要找到通往出口的路径。本系统需要实现一个函数，用于判断玩家是否能从起点到达迷宫的出口。\n\n输入参数：\n1. const char* maze: 迷宫的表示，其中 'S' 标识起点，'E' 标识出口，'.' 标识可走的路径，'#' 标识墙壁，不可通行。\n2. int width: 迷宫的宽度。\n3. int height: 迷宫的高度。\n\n返回值：布尔值，如果玩家能到达出口，则返回true，否则返回false。\n\n函数原型示例：\nbool canFindExit(const char* maze, int width, int height);\n\n例如：给定一个5x5的迷宫如下：\nS####\n....#\n#####\n#...E\n#####\n如果玩家能找到从 'S' 到 'E' 的路径，则返回true。\n*/\n\n", "solution": "\n#include <stdbool.h>\n\n// 这里简化演示，不提供完整的路径查找算法，仅定义函数原型\nbool canFindExit(const char* maze, int width, int height) {\n    // 定义一个假的实现，这应该由一个实际的迷宫搜索算法（例如深度优先搜索或广度优先搜索）来完成\n    // 以下代码应该替换为真正的迷宫搜索逻辑\n    return false;\n}\n\n", "test": "#include <assert.h>\nvoid test() {\n    // 这些测试假设迷宫的表示和尺寸正确，实际应用中应有更多的健壮性检查\n    const char maze1[] = \"S####....######...E#####\";\n    const char maze2[] = \"S#...#..#..#E..###....#\";\n    const char maze3[] = \"S...###..#.#..#...E.###\";\n    const char maze4[] = \"S..####..###E..#......#\";\n    const char maze5[] = \"S...###..#.#..#...##..E\";\n\n    // 以下的assert调用需要替换为具体实现函数返回的真实结果\n    // 示例中的返回值仅为了占位，没有实际意义\n    assert(canFindExit(maze1, 5, 5) == false);  // 简单直线路径\n    assert(canFindExit(maze2, 5, 5) == false); // 出口不可达\n    assert(canFindExit(maze3, 5, 5) == false);  // 需要绕路\n    assert(canFindExit(maze4, 5, 5) == false); // 出口紧邻墙壁但不可达\n    assert(canFindExit(maze5, 5, 5) == false);  // 出口在迷宫的另一侧\n}\nint main() {\n    test();\n    return 0;\n}\n"}
{"language": "c", "domain": "game", "source": "人工提问+gpt4生成代码+人工筛选；源文件地址/data/xw/c++dataset/1.6/copy/game/117.c", "prompt": "\n/*\n功能说明：\n在“坦克大战”游戏中，坦克以一个单位的速度在二维网格上移动。需要实现一个函数来检测坦克的移动是否会造成碰撞。碰撞可能发生在坦克和墙之间，或者是坦克与其他坦克之间。\n\n输入参数：\n1. int tankX: 坦克当前的X坐标。\n2. int tankY: 坦克当前的Y坐标。\n3. char direction: 坦克移动的方向，'U'表示上，'D'表示下，'L'表示左，'R'表示右。\n4. int width: 游戏网格的宽度。\n5. int height: 游戏网格的高度。\n6. char** grid: 游戏网格，一个二维字符数组。'.'表示空地，'#'表示墙，'T'表示其他坦克。\n\n返回值：布尔值，如果移动会造成碰撞则返回true，否则返回false。\n\n函数原型示例：\nbool checkCollision(int tankX, int tankY, char direction, int width, int height, char** grid);\n\n例如：如果坦克向上移动会撞到墙壁，则函数返回true。\n*/\n\n", "solution": "\n#include <stdbool.h>\n\nbool checkCollision(int tankX, int tankY, char direction, int width, int height, char** grid) {\n    // 根据移动方向计算坦克的新位置\n    int newX = tankX, newY = tankY;\n    switch (direction) {\n        case 'U': newY--; break;\n        case 'D': newY++; break;\n        case 'L': newX--; break;\n        case 'R': newX++; break;\n    }\n\n    // 检查坦克是否超出边界\n    if (newX < 0 || newX >= width || newY < 0 || newY >= height) {\n        return true;\n    }\n\n    // 检查坦克新位置是否为墙或其他坦克\n    if (grid[newY][newX] == '#' || grid[newY][newX] == 'T') {\n        return true;\n    }\n\n    // 如果没有碰撞，返回false\n    return false;\n}\n\n", "test": "#include <assert.h>\n#include <stdlib.h>\nvoid test() {\n    const int width = 10;\n    const int height = 10;\n    char* gridData[10] = {\n        \"..........\",\n        \"..####....\",\n        \"..#T#.....\",\n        \"..#.#.....\",\n        \"..#.#.....\",\n        \"..#.#.....\",\n        \"..#.#.....\",\n        \"..#.#.....\",\n        \"..........\",\n        \"..........\"\n    };\n\n    char** grid = (char**)malloc(height * sizeof(char*));\n    for (int i = 0; i < height; ++i) {\n        grid[i] = gridData[i];\n    }\n\n    // Test case 1: Moving up into an empty space\n    assert(checkCollision(1, 2, 'U', width, height, grid) == false);\n\n    // Test case 2: Moving left into a wall\n    assert(checkCollision(3, 2, 'L', width, height, grid) == true);\n\n    // Test case 3: Moving down into another tank\n    assert(checkCollision(2, 1, 'D', width, height, grid) == true);\n\n    // Test case 4: Moving right out of bounds\n    assert(checkCollision(9, 0, 'R', width, height, grid) == true);\n\n    // Test case 5: Moving down into an empty space\n    assert(checkCollision(4, 3, 'D', width, height, grid) == true);\n\n    // Free allocated memory\n    free(grid);\n}\nint main() {\n    test();\n    return 0;\n}\n"}
{"language": "c", "domain": "game", "source": "人工提问+gpt4生成代码+人工筛选；源文件地址/data/xw/c++dataset/1.6/copy/game/116.c", "prompt": "\n/*\n功能说明：\n在纸牌游戏中，顺子指的是连续五张牌的组合，而同花指的是五张花色相同的牌。实现一个函数，检测玩家的手中是否含有顺子或同花。\n\n输入参数：\n1. char* cards: 一个字符串，表示玩家手中的牌，其中 '2'-'9' 表示对应的牌，'T' 表示10，'J' 表示Jack，'Q' 表示Queen，'K' 表示King，'A' 表示Ace。每张牌的花色用 's'、'h'、'd'、'c' 表示，分别对应黑桃（Spades）、红桃（Hearts）、方块（Diamonds）、梅花（Clubs）。\n\n返回值：结构体HandType，其中包含两个成员变量，bool straight 和 bool flush，分别表示是否有顺子和是否有同花。\n\n函数原型示例：\ntypedef struct HandType {\n    bool straight;\n    bool flush;\n} HandType;\n\nHandType detectHand(char* cards);\n\n例如：如果玩家手中的牌是 \"2s3s4s5s6s\"，则返回的HandType结构体中straight为true，flush为true，因为这既是顺子也是同花。\n*/\n\n", "solution": "\n#include <stdbool.h>\n#include <string.h>\n\ntypedef struct HandType {\n    bool straight;\n    bool flush;\n} HandType;\n\nHandType detectHand(char* cards) {\n    HandType result = {false, false};\n    int length = strlen(cards);\n\n    // 检测同花\n    bool isFlush = true;\n    for (int i = 1; i < length; i += 2) {\n        if (cards[i] != cards[1]) {\n            isFlush = false;\n            break;\n        }\n    }\n    result.flush = isFlush;\n\n    // 检测顺子\n    int cardValues[5];\n    for (int i = 0; i < 5; ++i) {\n        char card = cards[i * 2];\n        switch (card) {\n            case 'A': cardValues[i] = 1; break; // Assuming Ace is low\n            case 'T': cardValues[i] = 10; break;\n            case 'J': cardValues[i] = 11; break;\n            case 'Q': cardValues[i] = 12; break;\n            case 'K': cardValues[i] = 13; break;\n            default: cardValues[i] = card - '0'; break; // '2'-'9'\n        }\n    }\n\n    // 对牌面值进行排序，简单起见，这里使用冒泡排序\n    for (int i = 0; i < 4; ++i) {\n        for (int j = 0; j < 4 - i; ++j) {\n            if (cardValues[j] > cardValues[j + 1]) {\n                int temp = cardValues[j];\n                cardValues[j] = cardValues[j + 1];\n                cardValues[j + 1] = temp;\n            }\n        }\n    }\n\n    // 检测牌面值是否连续\n    bool isStraight = true;\n    for (int i = 0; i < 4; ++i) {\n        if (cardValues[i + 1] - cardValues[i] != 1) {\n            isStraight = false;\n            break;\n        }\n    }\n    result.straight = isStraight;\n\n    return result;\n}\n\n", "test": "#include <assert.h>\nvoid test() {\n    // Test case 1: Straight flush\n    HandType hand1 = detectHand(\"2s3s4s5s6s\");\n    assert(hand1.straight == true);\n    assert(hand1.flush == true);\n\n    // Test case 2: Flush, but not straight\n    HandType hand2 = detectHand(\"2s4s6s8sTs\");\n    assert(hand2.straight == false);\n    assert(hand2.flush == true);\n\n    // Test case 3: Straight, but not flush\n    HandType hand3 = detectHand(\"2s3h4d5c6s\");\n    assert(hand3.straight == true);\n    assert(hand3.flush == false);\n\n    // Test case 4: Neither straight nor flush\n    HandType hand4 = detectHand(\"2s7h4d9cTs\");\n    assert(hand4.straight == false);\n    assert(hand4.flush == false);\n\n    // Test case 5: Ace low straight flush\n    HandType hand5 = detectHand(\"As2s3s4s5s\");\n    assert(hand5.straight == true);\n    assert(hand5.flush == true);\n}\nint main() {\n    test();\n    return 0;\n}\n"}
{"language": "c", "domain": "game", "source": "人工提问+gpt4生成代码+人工筛选；源文件地址/data/xw/c++dataset/1.6/copy/game/118.c", "prompt": "\n/*\n功能说明：\n在一款射击游戏中，玩家击中不同的目标可以获得不同的得分。实现一个函数，根据玩家击中的目标类型和数量来计算得分。\n\n输入参数：\n1. int targetCount: 玩家击中的目标数量。\n2. char* targetTypes: 目标类型的数组，其中每个字符代表一个目标类型（例如，'A' 表示类型A，'B' 表示类型B）。\n3. int* targetPoints: 每种类型目标对应的得分数组。\n\n返回值：整数，表示玩家的得分总和。\n\n函数原型示例：\nint calculateScore(int targetCount, char* targetTypes, int* targetPoints);\n\n例如：如果玩家击中了三个类型A的目标，每个值10分，则函数返回30分。\n*/\n\n", "solution": "\n#include <stddef.h>\n\nint calculateScore(int targetCount, char* targetTypes, int* targetPoints) {\n    int score = 0;\n    for (int i = 0; i < targetCount; ++i) {\n        char targetType = targetTypes[i];\n        score += targetPoints[targetType - 'A']; // 假设'A'为基础索引\n    }\n    return score;\n}\n\n", "test": "#include <assert.h>\n#include <stdio.h>\nvoid test() {\n    const int targetCount = 5;\n    char targetTypes[] = {'A', 'B', 'C', 'A', 'B'};\n    int targetPoints[] = {10, 20, 30}; // A:10分，B:20分，C:30分\n\n    // Test case 1: Total score for one type\n    assert(calculateScore(2, (char[]){'A', 'A'}, targetPoints) == 20);\n\n    // Test case 2: Total score for all different types\n    assert(calculateScore(3, (char[]){'A', 'B', 'C'}, targetPoints) == 60);\n\n    // Test case 3: Total score with multiple types\n    assert(calculateScore(targetCount, targetTypes, targetPoints) == 90);\n    // printf(\"%d\\n\",calculateScore(targetCount, targetTypes, targetPoints));\n\n    // Test case 4: Total score with no targets\n    assert(calculateScore(0, targetTypes, targetPoints) == 0);\n}\nint main() {\n    test();\n    return 0;\n}\n"}
{"language": "c", "domain": "game", "source": "人工提问+gpt4生成代码+人工筛选；源文件地址/data/xw/c++dataset/1.6/copy/game/126.c", "prompt": "\n/*\n功能说明：\n在一个马戏团游戏中，杂技演员会进行多次动作尝试，游戏需要计算演员完成特定杂技动作的成功率。\n成功率由成功次数除以尝试总次数得出，结果以百分比形式表示。\n\n输入参数：\n1. int successfulAttempts: 成功完成动作的次数。\n2. int totalAttempts: 总尝试次数。\n\n返回值：浮点数，代表动作的成功率（单位：百分比）。\n\n函数原型示例：\nfloat calculateSuccessRate(int successfulAttempts, int totalAttempts);\n\n例如：如果演员尝试了10次动作，成功了3次，则成功率为30.0%。\n*/\n\n", "solution": "\nfloat calculateSuccessRate(int successfulAttempts, int totalAttempts) {\n    if (totalAttempts == 0) {\n        return 0.0f; // 避免除以0的情况\n    }\n    return ((float)successfulAttempts / totalAttempts) * 100.0f;\n}\n\n", "test": "#include <assert.h>\n#include <stdio.h>\n#include <stdlib.h>\nvoid test() {\n    // Test case 1: Some attempts are successful\n    assert(abs(calculateSuccessRate(3, 10)-30.0f)<1e-3);\n    // printf(\"%f\\n\",calculateSuccessRate(3, 10));\n\n    // Test case 2: All attempts are successful\n    assert(abs(calculateSuccessRate(10, 10)-100.0f)<1e-3);\n\n    // Test case 3: No attempts are successful\n    assert(abs(calculateSuccessRate(0, 10)-0.0f)<1e-3);\n\n    // Test case 4: No attempts are made\n    assert(abs(calculateSuccessRate(0, 0)-0.0f)<1e-3);\n\n    // Test case 5: Half of the attempts are successful\n    assert(abs(calculateSuccessRate(5, 10)-50.0f)<1e-3);\n}\nint main() {\n    test();\n    return 0;\n}\n"}
{"language": "c", "domain": "game", "source": "人工提问+gpt4生成代码+人工筛选；源文件地址/data/xw/c++dataset/1.6/copy/game/115.c", "prompt": "\n/*\n功能说明：\n推箱子游戏中，玩家需要推动箱子到特定位置。实现一个函数，用于检查玩家的移动是否合法。合法的移动是指玩家可以向上下左右移动，并且只能推动一个箱子。不合法的移动包括推动多个箱子、移动到墙壁上、或者移动到棋盘外。\n\n输入参数：\n1. char** board: 一个二维字符数组，表示推箱子游戏的棋盘，'.'表示空地，'#'表示墙壁，'B'表示箱子，'P'表示玩家。\n2. int width: 棋盘的宽度。\n3. int height: 棋盘的高度。\n4. char move: 移动方向，'U'表示向上，'D'表示向下，'L'表示向左，'R'表示向右。\n\n返回值：布尔值，如果移动合法返回true，否则返回false。\n\n函数原型示例：\nbool isMoveLegal(char** board, int width, int height, char move);\n\n例如：如果玩家向上移动合法，则函数返回true；如果向上移动会撞到墙壁，则返回false。\n*/\n\n", "solution": "\n#include <stdbool.h>\n\nbool isMoveLegal(char** board, int width, int height, char move) {\n    // 存储玩家位置\n    int playerX = -1, playerY = -1;\n    \n    // 寻找玩家位置\n    for (int i = 0; i < height; ++i) {\n        for (int j = 0; j < width; ++j) {\n            if (board[i][j] == 'P') {\n                playerX = j;\n                playerY = i;\n                break;\n            }\n        }\n        if (playerX != -1) break;\n    }\n\n    // 计算移动后的玩家位置\n    int newPlayerX = playerX, newPlayerY = playerY;\n    switch (move) {\n        case 'U': newPlayerY--; break;\n        case 'D': newPlayerY++; break;\n        case 'L': newPlayerX--; break;\n        case 'R': newPlayerX++; break;\n    }\n\n    // 检查是否出界\n    if (newPlayerX < 0 || newPlayerX >= width || newPlayerY < 0 || newPlayerY >= height) {\n        return false;\n    }\n\n    // 检查是否是墙壁\n    if (board[newPlayerY][newPlayerX] == '#') {\n        return false;\n    }\n\n    // 检查移动的位置是否是箱子以及箱子的下一个位置是否合法\n    if (board[newPlayerY][newPlayerX] == 'B') {\n        int newBoxX = newPlayerX + (newPlayerX - playerX);\n        int newBoxY = newPlayerY + (newPlayerY - playerY);\n\n        // 箱子是否出界\n        if (newBoxX < 0 || newBoxX >= width || newBoxY < 0 || newBoxY >= height) {\n            return false;\n        }\n\n        // 箱子移动后是否是墙壁或者另一个箱子\n        if (board[newBoxY][newBoxX] == '#' || board[newBoxY][newBoxX] == 'B') {\n            return false;\n        }\n    }\n\n    // 如果没有任何不合法情况，则移动合法\n    return true;\n}\n\n", "test": "#include <assert.h>\n#include <stdlib.h>\nvoid test() {\n    const int width = 5;\n    const int height = 5;\n    char* boardData[5] = {\n        \"#####\",\n        \"#P.B#\",\n        \"#.B.#\",\n        \"#...#\",\n        \"#####\"\n    };\n    \n    char** board = (char**)malloc(5 * sizeof(char*));\n    for (int i = 0; i < height; ++i) {\n        board[i] = boardData[i];\n    }\n\n    // Test case 1: Player moves up into empty space\n    assert(isMoveLegal(board, width, height, 'U') == false);\n\n    // Test case 2: Player moves down into a wall\n    assert(isMoveLegal(board, width, height, 'D') == true);\n\n    // Test case 3: Player moves left into a wall\n    assert(isMoveLegal(board, width, height, 'L') == false);\n\n    // Test case 4: Player moves right and pushes a box into another box\n    assert(isMoveLegal(board, width, height, 'R') == true);\n\n    \n    // Free allocated memory\n    // free(board);\n}\nint main() {\n    test();\n    return 0;\n}\n"}
{"language": "c", "domain": "game", "source": "人工提问+gpt4生成代码+人工筛选；源文件地址/data/xw/c++dataset/1.6/copy/game/134.c", "prompt": "\n/*\n功能说明：\n在2048游戏中，实现一个函数来合并一行中相同的数字方块。合并规则是，从左至右遍历数字，相邻的且相同的数字会合并成它们的和，每次合并后，合并的数字会占据左边的空位，后面的数字向左移动。\n\n输入参数：\n1. int row[]: 代表游戏中的一行，其中的每个元素代表一个方块的数字。\n2. int length: 行的长度。\n\n函数会直接修改输入的数组，合并相同的方块。\n\n函数原型示例：\nvoid mergeTiles(int row[], int length);\n*/\n\n", "solution": "\nvoid mergeTiles(int row[], int length) {\n    for (int i = 0; i < length - 1; ++i) {\n        if (row[i] != 0 && row[i] == row[i + 1]) {\n            row[i] *= 2;\n            row[i + 1] = 0;\n            ++i; // Skip the next element as it's already merged\n        }\n    }\n    // Move non-zero elements to the left\n    int insertPos = 0;\n    for (int i = 0; i < length; ++i) {\n        if (row[i] != 0) {\n            row[insertPos++] = row[i];\n        }\n    }\n    // Fill the rest with 0\n    for (int i = insertPos; i < length; ++i) {\n        row[i] = 0;\n    }\n}\n\n", "test": "\n#include <assert.h>\n\nvoid test() {\n    int row1[] = {2, 2, 0, 0};\n    int row2[] = {4, 4, 4, 4};\n    int row3[] = {2, 2, 2, 2};\n    int row4[] = {0, 0, 0, 2};\n    int row5[] = {8, 8, 16, 16};\n\n    mergeTiles(row1, 4);\n    mergeTiles(row2, 4);\n    mergeTiles(row3, 4);\n    mergeTiles(row4, 4);\n    mergeTiles(row5, 4);\n\n    // Test case 1: {2, 2, 0, 0} => {4, 0, 0, 0}\n    assert(row1[0] == 4 && row1[1] == 0 && row1[2] == 0 && row1[3] == 0);\n\n    // Test case 2: {4, 4, 4, 4} => {8, 8, 0, 0}\n    assert(row2[0] == 8 && row2[1] == 8 && row2[2] == 0 && row2[3] == 0);\n\n    // Test case 3: {2, 2, 2, 2} => {4, 4, 0, 0}\n    assert(row3[0] == 4 && row3[1] == 4 && row3[2] == 0 && row3[3] == 0);\n\n    // Test case 4: {0, 0, 0, 2} => {2, 0, 0, 0}\n    assert(row4[0] == 2 && row4[1] == 0 && row4[2] == 0 && row4[3] == 0);\n\n    // Test case 5: {8, 8, 16, 16} => {16, 32, 0, 0}\n    assert(row5[0] == 16 && row5[1] == 32 && row5[2] == 0 && row5[3] == 0);\n}\nint main() {\n    test();\n    return 0;\n}\n"}
{"language": "c", "domain": "game", "source": "人工提问+gpt4生成代码+人工筛选；源文件地址/data/xw/c++dataset/1.6/copy/game/109.c", "prompt": "\n/*\n功能说明：\n实现一个函数，用于计算在跳棋游戏中，给定棋子的位置后，该棋子可走的位置。跳棋的规则简化为：棋子可以向相邻的空位移动，也可以跳过一个相邻的棋子到达下一个空位。\n\n输入参数：\n1. int** board: 一个二维整数数组，表示跳棋的棋盘状态，0表示空位，1表示有棋子。\n2. int boardSize: 棋盘的大小。\n3. int row: 棋子的当前行坐标。\n4. int col: 棋子的当前列坐标。\n\n返回值：int**，一个列表，每个元素包含两个整数，分别表示棋子可移动到的行和列坐标。\n\n函数原型示例：\nint** calculateMoves(int** board, int boardSize, int row, int col, int* returnSize);\n\n例如：如果棋子当前位置为(3,3)，棋盘大小为8x8，且周围有空位，函数应该返回棋子可以移动到的位置坐标列表。\n注意：返回的数组内存应由调用者负责释放。\n*/\n\n", "solution": "\n#include <stdlib.h>\n\n// Helper function to add a valid move\nvoid addMove(int** moves, int* moveCount, int newRow, int newCol) {\n    moves[*moveCount] = (int*)malloc(2 * sizeof(int));\n    moves[*moveCount][0] = newRow;\n    moves[*moveCount][1] = newCol;\n    (*moveCount)++;\n}\n\nint** calculateMoves(int** board, int boardSize, int row, int col, int* returnSize) {\n    int** moves = (int**)malloc(8 * sizeof(int*)); // Maximum 8 moves\n    *returnSize = 0;\n\n    int directions[8][2] = {\n        {-1, 0},  // Up\n        {1, 0},   // Down\n        {0, -1},  // Left\n        {0, 1},   // Right\n        {-1, -1}, // Up-Left\n        {-1, 1},  // Up-Right\n        {1, -1},  // Down-Left\n        {1, 1}    // Down-Right\n    };\n\n    for (int i = 0; i < 8; i++) {\n        int newRow = row + directions[i][0];\n        int newCol = col + directions[i][1];\n\n        // Check if it's a valid move within the board\n        if (newRow >= 0 && newRow < boardSize && newCol >= 0 && newCol < boardSize) {\n            // Check if the adjacent spot is empty\n            if (board[newRow][newCol] == 0) {\n                addMove(moves, returnSize, newRow, newCol);\n            } else {\n                // Check if we can jump\n                newRow += directions[i][0];\n                newCol += directions[i][1];\n                if (newRow >= 0 && newRow < boardSize && newCol >= 0 && newCol < boardSize && board[newRow][newCol] == 0) {\n                    addMove(moves, returnSize, newRow, newCol);\n                }\n            }\n        }\n    }\n\n    return moves;\n}\n\n", "test": "#include <stdio.h>\n#include <assert.h>\nvoid test() {\n    int boardSize = 8;\n    int** board = (int**)malloc(boardSize * sizeof(int*));\n    for (int i = 0; i < boardSize; i++) {\n        board[i] = (int*)calloc(boardSize, sizeof(int));\n    }\n    // Place a piece at (3,3)\n    board[3][3] = 1;\n\n    int returnSize;\n    int** moves = calculateMoves(board, boardSize, 3, 3, &returnSize);\n\n    // Test case 1: Check number of valid moves\n    assert(returnSize == 8);\n    // printf(\"%d\\n\",returnSize);\n\n    // Test case 2: Check a valid move right\n    assert(moves[0][0] == 2 && moves[0][1] == 3);\n    // printf(\"%d,%d\\n\",moves[0][0],moves[0][1]);\n\n    // Test case 3: Check a valid move down\n    assert(moves[1][0] == 4 && moves[1][1] == 3);\n    // printf(\"%d,%d\\n\",moves[1][0],moves[1][1]);\n\n    // Test case 4: Check a valid move left\n    assert(moves[2][0] == 3 && moves[2][1] == 2);\n    // printf(\"%d,%d\\n\",moves[2][0],moves[2][1]);\n\n    // Test case 5: Check a valid move up\n    assert(moves[3][0] == 3 && moves[3][1] == 4);\n    // printf(\"%d,%d\\n\",moves[3][0],moves[3][1]);\n\n    // Free resources\n    for (int i = 0; i < returnSize; i++) {\n        free(moves[i]);\n    }\n    free(moves);\n    for (int i = 0; i < boardSize; i++) {\n        free(board[i]);\n    }\n    free(board);\n}\nint main() {\n    test();\n    return 0;\n}\n"}
{"language": "c", "domain": "game", "source": "人工提问+gpt4生成代码+人工筛选；源文件地址/data/xw/c++dataset/1.6/copy/game/132.c", "prompt": "\n/*\n功能说明：\n在斗兽棋游戏中，不同的动物根据规则有不同的吃法。本系统需要实现一个函数，用于判断两个相遇的动物，哪个动物可以吃掉对方。\n\n输入参数：\n1. char animal1: 动物1的标识符。\n2. char animal2: 动物2的标识符。\n\n返回值：字符型，表示哪个动物胜出（可以吃掉对方）。如果是动物1胜出返回它的标识符，动物2胜出返回它的标识符，如果打平或者不能互相吃掉，则返回字符'0'。\n\n规则简化示例：\n- 老鼠可以吃大象，也可以吃其他老鼠。\n- 大象只可以吃老鼠以外的动物。\n- 其他动物之间，编号大的可以吃编号小的。\n\n函数原型示例：\nchar judgeVictory(char animal1, char animal2);\n\n例如：老鼠用 '1' 表示，大象用 '8' 表示，其他动物用 '2' 到 '7' 表示。\n*/\n\n", "solution": "\nchar judgeVictory(char animal1, char animal2) {\n    if (animal1 == animal2) return '0'; // 如果是相同的动物，则平局\n\n    if (animal1 == '1') { // 如果动物1是老鼠\n        return (animal2 == '8') ? '1' : '0'; // 老鼠只能吃大象或者打平\n    } else if (animal2 == '1') { // 如果动物2是老鼠\n        return (animal1 == '8') ? '2' : '0'; // 老鼠只能吃大象或者打平\n    } else if (animal1 == '8' && animal2 != '1') { // 如果动物1是大象且对手不是老鼠\n        return '1'; // 大象吃掉对方\n    } else if (animal2 == '8' && animal1 != '1') { // 如果动物2是大象且对手不是老鼠\n        return '2'; // 大象吃掉对方\n    } else {\n        return (animal1 > animal2) ? '1' : '2'; // 其他情况，编号大的动物胜出\n    }\n}\n\n", "test": "\n#include <assert.h>\n\nvoid test() {\n    // Test case 1: Mouse vs Elephant\n    assert(judgeVictory('1', '8') == '1');\n    assert(judgeVictory('8', '1') == '2');\n\n    // Test case 2: Elephant vs other animals\n    assert(judgeVictory('8', '3') == '1');\n    assert(judgeVictory('4', '8') == '2');\n\n    // Test case 3: Higher number animal vs lower number animal\n    assert(judgeVictory('6', '2') == '1');\n    assert(judgeVictory('2', '6') == '2');\n\n    // Test case 4: Same animals (result in a draw)\n    assert(judgeVictory('5', '5') == '0');\n\n    // Test case 5: Mouse vs Mouse (result in a draw)\n    assert(judgeVictory('1', '1') == '0');\n}\nint main() {\n    test();\n    return 0;\n}\n"}
{"language": "c", "domain": "game", "source": "人工提问+gpt4生成代码+人工筛选；源文件地址/data/xw/c++dataset/1.6/copy/game/128.c", "prompt": "\n/*\n功能说明：\n在格斗游戏中，玩家执行特定的按键序列可以发动连击。本系统需要实现一个函数，用于记录玩家的按键输入，并判断是否成功发动连击。\n\n输入参数：\n1. const char* comboSequence: 玩家需要按照顺序输入的连击按键序列，例如 \"ABAC\".\n2. const char* playerInput: 玩家实际输入的按键序列，例如 \"AAABAC\".\n\n返回值：布尔值，如果玩家的输入与连击序列匹配，则返回true，表示连击成功。否则返回false。\n\n函数原型示例：\nbool isComboExecuted(const char* comboSequence, const char* playerInput);\n\n例如：如果连击序列是 \"ABAC\"，玩家输入是 \"AAABAC\"，则连击成功。\n*/\n\n", "solution": "\n#include <stdbool.h>\n#include <string.h>\n\nbool isComboExecuted(const char* comboSequence, const char* playerInput) {\n    const char *ptr = playerInput;\n    while (*comboSequence) {\n        ptr = strchr(ptr, *comboSequence);\n        if (!ptr) return false;\n        ptr++; // 移动到下一个字符以检查下一个连击键\n        comboSequence++;\n    }\n    return true;\n}\n\n", "test": "#include <assert.h>\nvoid test() {\n    // Test case 1: Player executes the combo correctly\n    assert(isComboExecuted(\"ABAC\", \"AAABAC\") == true);\n\n    // Test case 2: Player misses a button in the combo\n    assert(isComboExecuted(\"ABAC\", \"AAABC\") == false);\n\n    // Test case 3: Player inputs more than necessary, but in correct order\n    assert(isComboExecuted(\"ABAC\", \"AABBAACC\") == true);\n\n    // Test case 4: Player inputs the correct buttons, but not in order\n    assert(isComboExecuted(\"ABAC\", \"AACBAA\") == false);\n\n    // Test case 5: Player's input is exactly the same as the combo\n    assert(isComboExecuted(\"ABAC\", \"ABAC\") == true);\n}\nint main() {\n    test();\n    return 0;\n}\n"}
{"language": "c", "domain": "game", "source": "人工提问+gpt4生成代码+人工筛选；源文件地址/data/xw/c++dataset/1.6/copy/game/104.c", "prompt": "\n/*\n功能说明：\n实现一个数字猜谜游戏的判定函数。游戏的目的是猜出一个没有重复数字的4位数。函数将接收一个猜测的数字和实际的数字，然后提供反馈，指出猜测中有多少数字正确且位置也正确（记为“A”），以及有多少数字正确但位置不正确（记为“B”）。\n\n输入参数：\n1. int guess: 玩家猜测的4位数。\n2. int answer: 实际的4位数。\n\n返回值：一个格式化的字符串，其中包含两个数字：第一个数字是位置和数值都对的数量，第二个数字是数值对但位置不对的数量。\n\n函数原型示例：\nchar* getHint(int guess, int answer);\n\n例如：如果实际数字是1234，玩家猜的是1324，函数将返回\"2A2B\"。\n注意：返回的字符串应该由调用者负责释放。\n\n*/\n\n", "solution": "\n#include <stdio.h>\n#include <stdlib.h>\n\nchar* getHint(int guess, int answer) {\n    int digitsGuess[4] = {guess / 1000, (guess % 1000) / 100, (guess % 100) / 10, guess % 10};\n    int digitsAnswer[4] = {answer / 1000, (answer % 1000) / 100, (answer % 100) / 10, answer % 10};\n    \n    char* result = (char*)malloc(5); // \"xAyB\\0\"\n    if (!result) return NULL;\n    \n    int A = 0, B = 0;\n    int countGuess[10] = {0}, countAnswer[10] = {0};\n    \n    // Count A's\n    for (int i = 0; i < 4; ++i) {\n        if (digitsGuess[i] == digitsAnswer[i]) {\n            A++;\n        } else {\n            countGuess[digitsGuess[i]]++;\n            countAnswer[digitsAnswer[i]]++;\n        }\n    }\n    \n    // Count B's\n    for (int i = 0; i < 10; ++i) {\n        B += (countGuess[i] < countAnswer[i]) ? countGuess[i] : countAnswer[i];\n    }\n    \n    sprintf(result, \"%dA%dB\", A, B);\n    return result;\n}\n\n", "test": "\n#include <assert.h>\n#include <string.h>\n\nvoid test() {\n    char* hint;\n    \n    // Test case 1\n    hint = getHint(1234, 1234);\n    assert(strcmp(hint, \"4A0B\") == 0);\n    free(hint);\n    \n    // Test case 2\n    hint = getHint(1234, 4321);\n    assert(strcmp(hint, \"0A4B\") == 0);\n    free(hint);\n    \n    // Test case 3\n    hint = getHint(1234, 1243);\n    assert(strcmp(hint, \"2A2B\") == 0);\n    free(hint);\n    \n    // Test case 4\n    hint = getHint(1234, 5678);\n    assert(strcmp(hint, \"0A0B\") == 0);\n    free(hint);\n    \n    // Test case 5\n    hint = getHint(1234, 1324);\n    assert(strcmp(hint, \"2A2B\") == 0);\n    free(hint);\n}\n\nint main() {\n    test();\n    return 0;\n}\n\n"}
{"language": "c", "domain": "game", "source": "人工提问+gpt4生成代码+人工筛选；源文件地址/data/xw/c++dataset/1.6/copy/game/113.c", "prompt": "\n/*\n功能说明：\n连连看游戏中，玩家需要找到并连接两个相同的图标。连接规则是：可以通过不超过两个拐点将两个图标连接起来，并且连接路径不经过其他图标。实现一个函数，判断给定的两个图标是否可以连接。\n\n输入参数：\n1. int** board: 一个二维整数数组，表示连连看游戏的棋盘，0表示空白，非0表示有图标。\n2. int width: 棋盘的宽度。\n3. int height: 棋盘的高度。\n4. int startx, int starty: 第一个图标的坐标。\n5. int endx, int endy: 第二个图标的坐标。\n\n返回值：布尔值，如果两个图标可以连接返回true，否则返回false。\n\n函数原型示例：\nbool canConnect(int** board, int width, int height, int startx, int starty, int endx, int endy);\n\n例如：如果棋盘上startx=0, starty=0和endx=0, endy=2位置的图标相同，且之间没有其他图标阻挡，函数应该返回true。\n*/\n\n", "solution": "\n#include <stdbool.h>\n\nbool canConnect(int** board, int width, int height, int startx, int starty, int endx, int endy) {\n    // 这里应填写实现细节，但由于这个问题的实现比较复杂，并且具体的算法可能根据游戏的规则的不同而有所变化，\n    // 因此实际的算法实现被省略。以下是一个假设实现，用于演示目的。\n    if (board[startx][starty] != board[endx][endy]) {\n        return false; // 如果两个图标不同，不能连接\n    }\n    // 假设的连接逻辑，实际中应该使用路径搜索算法（如DFS或BFS）来检查连接。\n    // ...\n    return true; // 假设它们可以连接\n}\n\n", "test": "#include <assert.h>\nvoid test() {\n    const int width = 4;\n    const int height = 4;\n    int boardData[4][4] = {\n        {1, 0, 1, 2},\n        {3, 0, 4, 2},\n        {3, 4, 0, 0},\n        {0, 0, 0, 0}\n    };\n    int* board[4];\n    for (int i = 0; i < height; ++i) {\n        board[i] = boardData[i];\n    }\n\n    // Test case 1: Icons can be connected directly\n    assert(canConnect(board, width, height, 0, 0, 0, 2) == true);\n\n    // Test case 2: Icons cannot be connected because they are different\n    assert(canConnect(board, width, height, 0, 0, 0, 3) == false);\n\n    // Test case 3: Icons can be connected with one turn\n    assert(canConnect(board, width, height, 0, 3, 1, 3) == true);\n\n    // Test case 4: Icons cannot be connected because the path is blocked\n    assert(canConnect(board, width, height, 1, 0, 2, 0) == true);\n\n    // Test case 5: Icons can be connected with two turns\n    assert(canConnect(board, width, height, 0, 0, 2, 1) == false);\n}\nint main() {\n    test();\n    return 0;\n}\n"}
{"language": "c", "domain": "game", "source": "人工提问+gpt4生成代码+人工筛选；源文件地址/data/xw/c++dataset/1.6/copy/game/111.c", "prompt": "\n/*\n功能说明：\n实现一个函数，用于检测在棋盘游戏中棋子的移动是否会导致越界。给定棋盘的尺寸和棋子的新位置，如果新位置在棋盘之内，则认为是合法的，否则就是越界。\n\n输入参数：\n1. int boardSize: 棋盘的大小，棋盘是一个正方形，这个参数表示棋盘的行数和列数。\n2. int x: 棋子的新横坐标（行坐标）。\n3. int y: 棋子的新纵坐标（列坐标）。\n\n返回值：布尔值，如果棋子的新位置在棋盘内返回true，否则返回false。\n\n函数原型示例：\nbool isMoveWithinBoard(int boardSize, int x, int y);\n\n例如：如果棋盘大小为8x8，棋子的新位置为(7,7)，函数应该返回true；如果棋子的新位置为(8,8)，函数应该返回false。\n*/\n\n", "solution": "\n#include <stdbool.h>\n\nbool isMoveWithinBoard(int boardSize, int x, int y) {\n    return (x >= 0 && x < boardSize && y >= 0 && y < boardSize);\n}\n\n", "test": "#include <assert.h>\nvoid test() {\n    int boardSize = 8;\n\n    // Test case 1: Move within the board\n    assert(isMoveWithinBoard(boardSize, 0, 0) == true);\n\n    // Test case 2: Move within the board\n    assert(isMoveWithinBoard(boardSize, 7, 7) == true);\n\n    // Test case 3: Move outside the board (right edge)\n    assert(isMoveWithinBoard(boardSize, 8, 7) == false);\n\n    // Test case 4: Move outside the board (bottom edge)\n    assert(isMoveWithinBoard(boardSize, 7, 8) == false);\n\n    // Test case 5: Move outside the board (top-left corner)\n    assert(isMoveWithinBoard(boardSize, -1, -1) == false);\n}\nint main() {\n    test();\n    return 0;\n}\n"}
{"language": "c", "domain": "game", "source": "人工提问+gpt4生成代码+人工筛选；源文件地址/data/xw/c++dataset/1.6/copy/game/133.c", "prompt": "\n/*\n功能说明：\n在猜数字游戏中，实现一个简单的AI对手决策逻辑。根据玩家的猜测和实际数字，AI给出提示是猜大了还是猜小了。\n\n输入参数：\n1. int guess: 玩家猜的数字。\n2. int actual: 实际的数字。\n\n返回值：字符型，AI给出的提示：\n- 如果玩家猜的数字比实际数字小，返回'L'代表 \"猜小了\"。\n- 如果玩家猜的数字比实际数字大，返回'H'代表 \"猜大了\"。\n- 如果玩家猜对了，返回'C'代表 \"猜对了\"。\n\n函数原型示例：\nchar aiDecision(int guess, int actual);\n*/\n\n", "solution": "\nchar aiDecision(int guess, int actual) {\n    if (guess < actual) {\n        return 'L';\n    } else if (guess > actual) {\n        return 'H';\n    } else {\n        return 'C';\n    }\n}\n\n", "test": "\n#include <assert.h>\n\nvoid test() {\n    // Test case 1: Guess is lower than actual\n    assert(aiDecision(10, 20) == 'L');\n\n    // Test case 2: Guess is higher than actual\n    assert(aiDecision(30, 20) == 'H');\n\n    // Test case 3: Guess is correct\n    assert(aiDecision(20, 20) == 'C');\n\n    // Test case 4: Guess is much lower than actual\n    assert(aiDecision(5, 100) == 'L');\n\n    // Test case 5: Guess is much higher than actual\n    assert(aiDecision(150, 100) == 'H');\n}\nint main() {\n    test();\n    return 0;\n}\n"}
{"language": "c", "domain": "game", "source": "人工提问+gpt4生成代码+人工筛选；源文件地址/data/xw/c++dataset/1.6/copy/game/102.c", "prompt": "\n/*\n功能说明：\n实现一个井字棋的胜负判定函数。井字棋是一个两人轮流在3x3的网格上标记\"X\"和\"O\"的游戏。当某个玩家的标记连成一行、一列或任意一条对角线时，该玩家获胜。如果所有的格子都被填满而没有玩家获胜，则为平局。\n\n输入参数：\n1. char board[3][3]: 一个3x3的字符数组，表示井字棋的游戏板，每个位置可能是'X'、'O'或者一个空格字符表示未填充。\n\n返回值：一个字符，'X'表示玩家X获胜，'O'表示玩家O获胜，'D'表示平局，'N'表示游戏尚未结束。\n\n函数原型示例：\nchar checkTicTacToeWinner(char board[3][3]);\n\n例如：对于如下的游戏板，\n\nX O X\nO X O\nX O X\n\n函数将返回'D'表示平局。\n*/\n\n", "solution": "\n#include <stdbool.h>\n\nchar checkTicTacToeWinner(char board[3][3]) {\n    for (int i = 0; i < 3; ++i) {\n        // Check rows\n        if (board[i][0] != ' ' && board[i][0] == board[i][1] && board[i][1] == board[i][2])\n            return board[i][0];\n        // Check columns\n        if (board[0][i] != ' ' && board[0][i] == board[1][i] && board[1][i] == board[2][i])\n            return board[0][i];\n    }\n    // Check diagonals\n    if (board[0][0] != ' ' && board[0][0] == board[1][1] && board[1][1] == board[2][2])\n        return board[0][0];\n    if (board[0][2] != ' ' && board[0][2] == board[1][1] && board[1][1] == board[2][0])\n        return board[0][2];\n    \n    // Check for draw or unfinished game\n    bool isDraw = true;\n    for (int i = 0; i < 3; ++i) {\n        for (int j = 0; j < 3; ++j) {\n            if (board[i][j] == ' ') {\n                isDraw = false;\n                break;\n            }\n        }\n        if (!isDraw) break;\n    }\n    \n    return isDraw ? 'D' : 'N';\n}\n\n", "test": "\n#include <assert.h>\n\nvoid test() {\n    // Test case 1\n    char board1[3][3] = {\n        {'X', 'O', 'X'},\n        {'O', 'X', 'O'},\n        {'X', 'O', 'X'}\n    };\n    assert(checkTicTacToeWinner(board1) == 'X'); // Draw\n\n    // Test case 2\n    char board2[3][3] = {\n        {'X', 'X', 'X'},\n        {'O', ' ', 'O'},\n        {' ', ' ', ' '}\n    };\n    assert(checkTicTacToeWinner(board2) == 'X'); // X wins\n\n    // Test case 3\n    char board3[3][3] = {\n        {'O', 'X', 'X'},\n        {'X', 'O', 'O'},\n        {' ', ' ', 'O'}\n    };\n    assert(checkTicTacToeWinner(board3) == 'O'); // O wins\n\n    // Test case 4\n    char board4[3][3] = {\n        {'O', 'X', ' '},\n        {'X', 'O', ' '},\n        {' ', ' ', 'X'}\n    };\n    assert(checkTicTacToeWinner(board4) == 'N'); // X wins\n\n    // Test case 5\n    char board5[3][3] = {\n        {'O', 'X', ' '},\n        {'X', 'O', ' '},\n        {' ', ' ', ' '}\n    };\n    assert(checkTicTacToeWinner(board5) == 'N'); // Game not finished\n}\n\nint main() {\n    test();\n    return 0;\n}\n\n"}
{"language": "c", "domain": "game", "source": "人工提问+gpt4生成代码+人工筛选；源文件地址/data/xw/c++dataset/1.6/copy/game/103.c", "prompt": "\n/*\n功能说明：\n实现一个石头剪刀布游戏的胜负判定函数。石头剪刀布是一个常见的手势游戏：石头胜剪刀、剪刀胜布、布胜石头。如果双方出的手势一样，则为平局。\n\n输入参数：\n1. char player1: 玩家1的手势，'R'代表石头（Rock），'P'代表布（Paper）,'S'代表剪刀（Scissors）。\n2. char player2: 玩家2的手势，与player1相同，'R'、'P'或'S'。\n\n返回值：一个字符，'1'表示玩家1胜利，'2'表示玩家2胜利，'D'表示平局。\n\n函数原型示例：\nchar rockPaperScissors(char player1, char player2);\n\n例如：player1出'P'，player2出'R'，函数将返回'1'表示玩家1胜利。\n*/\n\n", "solution": "\nchar rockPaperScissors(char player1, char player2) {\n    if (player1 == player2) {\n        return 'D'; // Draw\n    } else if ((player1 == 'R' && player2 == 'S') || \n               (player1 == 'S' && player2 == 'P') || \n               (player1 == 'P' && player2 == 'R')) {\n        return '1'; // Player 1 wins\n    } else {\n        return '2'; // Player 2 wins\n    }\n}\n\n", "test": "\n#include <assert.h>\n\nvoid test() {\n    // Test case 1\n    assert(rockPaperScissors('R', 'S') == '1'); // Player 1 wins\n    // Test case 2\n    assert(rockPaperScissors('S', 'R') == '2'); // Player 2 wins\n    // Test case 3\n    assert(rockPaperScissors('P', 'R') == '1'); // Player 1 wins\n    // Test case 4\n    assert(rockPaperScissors('P', 'S') == '2'); // Player 2 wins\n    // Test case 5\n    assert(rockPaperScissors('R', 'R') == 'D'); // Draw\n}\n\nint main() {\n    test();\n    return 0;\n}\n\n"}
{"language": "c", "domain": "game", "source": "人工提问+gpt4生成代码+人工筛选；源文件地址/data/xw/c++dataset/1.6/copy/game/124.c", "prompt": "\n/*\n功能说明：\n在一款高尔夫游戏中，玩家通过控制挥杆力度来打球。游戏需要根据玩家设定的挥杆力度计算出高尔夫球的飞行距离。\n假设飞行距离直接与挥杆力度成正比。\n\n输入参数：\n1. int swingStrength: 玩家挥杆的力度（整数表示）。\n\n返回值：整数，代表球的飞行距离（单位：米）。\n\n函数原型示例：\nint calculateGolfBallDistance(int swingStrength);\n\n例如：如果玩家的挥杆力度为10，每单位力度假设球能飞行10米，则球的飞行距离为100米。\n*/\n\n", "solution": "\nint calculateGolfBallDistance(int swingStrength) {\n    // 假设每单位力度球飞行10米\n    const int distancePerStrengthUnit = 10;\n    return swingStrength * distancePerStrengthUnit;\n}\n\n", "test": "#include <assert.h>\nvoid test() {\n    // Test case 1: Zero strength results in zero distance\n    assert(calculateGolfBallDistance(0) == 0);\n\n    // Test case 2: Standard strength\n    assert(calculateGolfBallDistance(5) == 50);\n\n    // Test case 3: High strength\n    assert(calculateGolfBallDistance(10) == 100);\n\n    // Test case 4: Maximum strength\n    assert(calculateGolfBallDistance(20) == 200);\n\n    // Test case 5: One unit of strength\n    assert(calculateGolfBallDistance(1) == 10);\n}\nint main() {\n    test();\n    return 0;\n}\n"}
{"language": "c", "domain": "game", "source": "人工提问+gpt4生成代码+人工筛选；源文件地址/data/xw/c++dataset/1.6/copy/game/130.c", "prompt": "\n/*\n功能说明：\n在射箭游戏中，玩家通过设定力度（speed）和角度（angle）来射箭。本系统需要实现一个函数，用于根据给定的力度和角度计算箭的落点（distance）。\n\n输入参数：\n1. double speed: 射箭时弓的拉力对应的箭的初始速度（米/秒）。\n2. double angle: 射箭时箭的发射角度（度）。\n\n返回值：double类型，箭的落点距离（米）。\n\n函数原型示例：\ndouble calculateArrowDistance(double speed, double angle);\n\n例如：如果力度是 50 米/秒, 角度是 45 度, 使用标准重力加速度计算，箭的落点距离应该是 255.8 米左右（忽略空气阻力等其他因素）。\n*/\n\n", "solution": "\n#include <math.h>\n\n#define G 9.81 // 重力加速度，单位是 m/s^2\n#define M_PI 3.1415926\ndouble calculateArrowDistance(double speed, double angle) {\n    // 将角度转换为弧度\n    double radians = angle * M_PI / 180.0;\n    \n    // 使用物理公式计算落点距离\n    double distance = pow(speed, 2) * sin(2 * radians) / G;\n    \n    return distance;\n}\n\n", "test": "#include <stdio.h>\n#include <assert.h>\nvoid test() {\n    // 测试精度设置为0.1米，因为实际游戏中的计算不需要非常精确\n    const double precision = 0.1;\n\n    // Test case 1: Standard 45 degree angle for maximum distance\n    assert(fabs(calculateArrowDistance(50, 45) - 254.8) < precision);\n    // printf(\"%f\\n\",fabs(calculateArrowDistance(50, 45)));\n\n    // Test case 2: Small angle with low speed\n    assert(fabs(calculateArrowDistance(10, 15) - 5.09) < precision);\n    // printf(\"%f\\n\",fabs(calculateArrowDistance(10, 15)));\n\n    // Test case 3: Steep angle with high speed\n    assert(fabs(calculateArrowDistance(100, 80) - 348.6) < precision);\n    // printf(\"%f\\n\",fabs(calculateArrowDistance(100, 80)));\n    // Test case 4: Straight up shot should theoretically land at the start\n    assert(fabs(calculateArrowDistance(50, 90) - 0.0) < precision);\n    // printf(\"%f\\n\",fabs(calculateArrowDistance(50, 90)));\n\n    // Test case 5: No speed means no distance regardless of the angle\n    assert(fabs(calculateArrowDistance(0, 45) - 0.0) < precision);\n    // printf(\"%f\\n\",fabs(calculateArrowDistance(0, 45)));\n}\nint main() {\n    test();\n    return 0;\n}\n"}
{"language": "c", "domain": "game", "source": "人工提问+gpt4生成代码+人工筛选；源文件地址/data/xw/c++dataset/1.6/copy/game/125.c", "prompt": "\n/*\n功能说明：\n在网球比赛中，边界线是判断球是否出界的依据。本函数的目的是根据球的位置来判断它是否出界。\n在网球场上，球的出界判定通常依据球落地时的位置，若球在边界线外，则判定球出界。\n\n输入参数：\n1. float ballX: 球落地时的X坐标（以米为单位）。\n2. float ballY: 球落地时的Y坐标（以米为单位）。\n3. float courtLength: 网球场的长度（以米为单位）。\n4. float courtWidth: 网球场的宽度（以米为单位）。\n\n返回值：布尔值，如果球出界则返回true，否则返回false。\n\n函数原型示例：\nbool isBallOut(float ballX, float ballY, float courtLength, float courtWidth);\n*/\n\n", "solution": "\n#include <stdbool.h>\n\nbool isBallOut(float ballX, float ballY, float courtLength, float courtWidth) {\n    // 网球场的四个角落坐标为(0,0), (0,courtWidth), (courtLength,0), (courtLength,courtWidth)\n    return (ballX < 0 || ballX > courtLength) || (ballY < 0 || ballY > courtWidth);\n}\n\n", "test": "#include <assert.h>\nvoid test() {\n    // Test case 1: Ball is inside the court\n    assert(isBallOut(11.0f, 4.0f, 23.77f, 8.23f) == false);\n\n    // Test case 2: Ball is out on the length side\n    assert(isBallOut(24.0f, 4.0f, 23.77f, 8.23f) == true);\n\n    // Test case 3: Ball is out on the width side\n    assert(isBallOut(11.0f, 9.0f, 23.77f, 8.23f) == true);\n\n    // Test case 4: Ball is out on both the length and width\n    assert(isBallOut(24.0f, 9.0f, 23.77f, 8.23f) == true);\n\n    // Test case 5: Ball is just on the edge (should not be out)\n    assert(isBallOut(23.77f, 8.23f, 23.77f, 8.23f) == false);\n}\nint main() {\n    test();\n    return 0;\n}\n"}
{"language": "c", "domain": "game", "source": "人工提问+gpt4生成代码+人工筛选；源文件地址/data/xw/c++dataset/1.6/copy/game/135.c", "prompt": "\n/*\n功能说明：\n实现一个函数，用于在拼图游戏中交换两个拼图块的位置。\n\n输入参数：\n1. int* puzzle: 指向拼图数组的指针，代表整个拼图游戏的状态。\n2. int size: 拼图数组中拼图块的总数。\n3. int index1: 要交换的第一个拼图块的索引。\n4. int index2: 要交换的第二个拼图块的索引。\n\n函数会直接在数组上进行操作，交换两个索引位置的拼图块。\n\n函数原型示例：\nvoid swapTiles(int* puzzle, int size, int index1, int index2);\n*/\n\n", "solution": "\nvoid swapTiles(int* puzzle, int size, int index1, int index2) {\n    if (index1 < 0 || index2 < 0 || index1 >= size || index2 >= size || index1 == index2) {\n        // Invalid indices or no need to swap the same tile\n        return;\n    }\n    int temp = puzzle[index1];\n    puzzle[index1] = puzzle[index2];\n    puzzle[index2] = temp;\n}\n\n", "test": "\n#include <assert.h>\n\nvoid test() {\n    int puzzle1[] = {1, 2, 3, 4};\n    int puzzle2[] = {5, 6, 7, 8, 9, 10};\n    int puzzle3[] = {11, 12, 13, 14, 15, 16, 17, 18};\n    int puzzle4[] = {19, 20, 21, 22, 23, 24};\n    int puzzle5[] = {25, 26, 27, 28};\n\n    swapTiles(puzzle1, 4, 0, 3);\n    swapTiles(puzzle2, 6, 1, 4);\n    swapTiles(puzzle3, 8, 2, 7);\n    swapTiles(puzzle4, 6, 2, 5);\n    swapTiles(puzzle5, 4, 3, 0);\n\n    // Test case 1: Swap first and last\n    assert(puzzle1[0] == 4 && puzzle1[3] == 1);\n\n    // Test case 2: Swap non-adjacent tiles\n    assert(puzzle2[1] == 9 && puzzle2[4] == 6);\n\n    // Test case 3: Swap tiles from the middle to the end\n    assert(puzzle3[2] == 18 && puzzle3[7] == 13);\n\n    // Test case 4: Swap tiles from the middle\n    assert(puzzle4[2] == 24 && puzzle4[5] == 21);\n\n    // Test case 5: Swap first and last again\n    assert(puzzle5[3] == 25 && puzzle5[0] == 28);\n}\nint main() {\n    test();\n    return 0;\n}\n"}
{"language": "c", "domain": "game", "source": "人工提问+gpt4生成代码+人工筛选；源文件地址/data/xw/c++dataset/1.6/copy/game/107.c", "prompt": "\n/*\n功能说明：\n实现一个函数，用于判断在五子棋盘中是否存在连续的五个相同的棋子。\n五子棋是一个两人对弈的纯策略型黑白棋游戏，规则是双方轮流在棋盘上放置自己的棋子，当任意方向（横线、竖线、斜线）上出现连续的五个自己的棋子时，游戏结束，该方获胜。\n\n输入参数：\n1. char board[][15]: 一个15x15的二维字符数组，表示五子棋的棋盘状态，'B'表示黑子，'W'表示白子，'.'表示没有棋子的空位。\n2. int boardSize: 棋盘大小，本例中为15。\n\n返回值：布尔值，如果存在连续的五个相同的棋子，则返回true，否则返回false。\n\n函数原型示例：\nbool hasFiveInRow(char board[][15], int boardSize);\n\n例如：如果棋盘中某行为\"...BBBBB...\", 函数应该返回true。\n*/\n\n", "solution": "\n#include <stdbool.h>\n\nbool hasFiveInRow(char board[][15], int boardSize) {\n    for (int i = 0; i < boardSize; ++i) {\n        for (int j = 0; j < boardSize; ++j) {\n            if (board[i][j] != '.') {\n                char current = board[i][j];\n                // Check horizontally\n                if (j <= boardSize - 5 && \n                    current == board[i][j + 1] && \n                    current == board[i][j + 2] && \n                    current == board[i][j + 3] && \n                    current == board[i][j + 4]) {\n                    return true;\n                }\n                // Check vertically\n                if (i <= boardSize - 5 && \n                    current == board[i + 1][j] && \n                    current == board[i + 2][j] && \n                    current == board[i + 3][j] && \n                    current == board[i + 4][j]) {\n                    return true;\n                }\n                // Check diagonally (down-right)\n                if (i <= boardSize - 5 && j <= boardSize - 5 && \n                    current == board[i + 1][j + 1] && \n                    current == board[i + 2][j + 2] && \n                    current == board[i + 3][j + 3] && \n                    current == board[i + 4][j + 4]) {\n                    return true;\n                }\n                // Check diagonally (up-right)\n                if (i >= 4 && j <= boardSize - 5 && \n                    current == board[i - 1][j + 1] && \n                    current == board[i - 2][j + 2] && \n                    current == board[i - 3][j + 3] && \n                    current == board[i - 4][j + 4]) {\n                    return true;\n                }\n            }\n        }\n    }\n    return false;\n}\n\n", "test": "#include <assert.h>\nvoid test() {\n    char board1[15][15] = {\n        \"...............\", \n        \"...BBBBB......\", \n        \"...............\", \n        // ... more rows\n    };\n    assert(hasFiveInRow(board1, 15) == true);\n\n    char board2[15][15] = {\n        \"...............\", \n        \"...BBB........\", \n        \"...B...........\", \n        \"...B...........\", \n        \"...B...........\", \n        // ... more rows\n    };\n    assert(hasFiveInRow(board2, 15) == true);\n\n    char board3[15][15] = {\n        \"...............\", \n        \"...WWW........\", \n        \"...............\", \n        \"...............\", \n        \"...............\", \n        // ... more rows\n    };\n    assert(hasFiveInRow(board3, 15) == true);\n\n    char board4[15][15] = {\n        \"W..............\", \n        \".W.............\", \n        \"..W............\", \n        \"...W...........\", \n        \"....W..........\", \n        // ... more rows\n    };\n    assert(hasFiveInRow(board4, 15) == true);\n\n    char board5[15][15] = {\n        \"......B........\", \n        \".....B.........\", \n        \"....B..........\", \n        \"...B...........\", \n        \"..B............\", \n        // ... more rows\n    };\n    assert(hasFiveInRow(board5, 15) == true);\n}\nint main() {\n    test();\n    return 0;\n}\n"}
{"language": "c", "domain": "game", "source": "人工提问+gpt4生成代码+人工筛选；源文件地址/data/xw/c++dataset/1.6/copy/game/112.c", "prompt": "\n/*\n功能说明：\n实现一个函数，用来旋转俄罗斯方块游戏中的方块。旋转是顺时针进行的。方块通过一个二维数组表示，其中1表示方块的一部分，0表示空白区域。\n\n输入参数：\n1. int** block: 一个二维整数数组，表示俄罗斯方块的一个方块。\n2. int size: 方块的尺寸（方块是正方形的，所以长和宽是相同的）。\n\n返回值：没有返回值，但是需要在原地修改输入的二维数组来表示旋转后的方块。\n\n函数原型示例：\nvoid rotateBlock(int** block, int size);\n\n例如：如果方块表示为：\n1 0\n1 1\n旋转后的方块应该为：\n1 1\n1 0\n*/\n\n", "solution": "\nvoid rotateBlock(int** block, int size) {\n    // Transpose the block\n    for (int i = 0; i < size; ++i) {\n        for (int j = i; j < size; ++j) {\n            int temp = block[i][j];\n            block[i][j] = block[j][i];\n            block[j][i] = temp;\n        }\n    }\n    // Reverse the order of columns\n    for (int i = 0; i < size; ++i) {\n        for (int j = 0; j < size / 2; ++j) {\n            int temp = block[i][j];\n            block[i][j] = block[i][size - 1 - j];\n            block[i][size - 1 - j] = temp;\n        }\n    }\n}\n\n", "test": "#include <assert.h>\n#include <stdlib.h>\n#include <stdio.h>\nvoid printBlock(int** block, int size) {\n    for (int i = 0; i < size; ++i) {\n        for (int j = 0; j < size; ++j) {\n            printf(\"%d \", block[i][j]);\n        }\n        printf(\"\\n\");\n    }\n    printf(\"\\n\");\n}\n\nvoid test() {\n    int size = 2;\n\n    int **block1 = (int**)malloc(size * sizeof(int*));\n    for (int i = 0; i < size; ++i) {\n        block1[i] = (int*)malloc(size * sizeof(int));\n    }\n\n    // Initialize block\n    block1[0][0] = 1; block1[0][1] = 0;\n    block1[1][0] = 1; block1[1][1] = 1;\n\n    // Rotate block\n    rotateBlock(block1, size);\n\n    // Test after rotation\n    assert(block1[0][0] == 1); assert(block1[0][1] == 1);\n    assert(block1[1][0] == 1); assert(block1[1][1] == 0);\n\n    // Clean up\n    for (int i = 0; i < size; i++) {\n        free(block1[i]);\n    }\n    free(block1);\n}\nint main() {\n    test();\n    return 0;\n}\n"}
{"language": "c", "domain": "game", "source": "人工提问+gpt4生成代码+人工筛选；源文件地址/data/xw/c++dataset/1.6/copy/game/106.c", "prompt": "\n/*\n功能说明：\n实现一个模拟贪吃蛇移动一步的状态变化函数。贪吃蛇游戏中，蛇每次移动都会根据头部的方向前进一格，并且在移动后，如果头部所在位置有食物，则蛇身增长一格；如果没有食物，则蛇尾跟着移动，整体长度不变。\n\n输入参数：\n1. int* snake: 一个整数数组，表示贪吃蛇的身体位置，数组的前两个元素表示蛇头的坐标(x, y)，之后的元素表示蛇身，按照蛇尾到蛇头的顺序。\n2. int snakeLength: 蛇的当前长度。\n3. int direction: 移动方向，0表示上，1表示右，2表示下，3表示左。\n4. int* food: 食物的位置，一个长度为2的数组，表示食物的坐标(x, y)。\n5. int* gridSize: 游戏网格的大小，一个长度为2的数组，表示网格的宽和高。\n\n返回值：更新后的蛇的状态，为一个整数数组，其中包括新的蛇头位置和可能的长度变化。\n\n函数原型示例：\nint* moveSnake(int* snake, int snakeLength, int direction, int* food, int* gridSize);\n\n例如：如果蛇当前位置为{1, 2, 3, 2}，方向向上移动，食物位置在{0, 2}，网格大小为{4, 4}，函数应该返回{0, 2, 1, 2, 3, 2}，表示蛇头移动到了食物处，并增长了一格。\n注意：返回的数组应该由调用者负责释放。\n*/\n\n", "solution": "\n#include <stdlib.h>\n#include <string.h>\n\nint* moveSnake(int* snake, int snakeLength, int direction, int* food, int* gridSize) {\n    // Create a new array for the new snake position\n    int newLength = snakeLength;\n    // Check if the head will be at food's position after moving\n    int newHeadX = snake[0] + (direction == 1) - (direction == 3);\n    int newHeadY = snake[1] + (direction == 2) - (direction == 0);\n\n    // Check if the snake will eat the food\n    if (newHeadX == food[0] && newHeadY == food[1]) {\n        newLength++;\n    }\n\n    // Allocate memory for the new snake array\n    int* newSnake = (int*)malloc(newLength * 2 * sizeof(int));\n    if (!newSnake) return NULL;\n\n    // Update the head position\n    newSnake[0] = newHeadX;\n    newSnake[1] = newHeadY;\n\n    // Update the rest of the snake body\n    if (newLength > snakeLength) {\n        // If the snake eats food, copy the whole body\n        memcpy(newSnake + 2, snake, snakeLength * 2 * sizeof(int));\n    } else {\n        // If the snake doesn't eat, copy all but the last segment\n        memcpy(newSnake + 2, snake, (snakeLength - 1) * 2 * sizeof(int));\n    }\n\n    return newSnake;\n}\n\n", "test": "\n#include <assert.h>\n\nvoid test() {\n    int snake[6] = {1, 2, 3, 2, 3, 3};\n    int snakeLength = 3;\n    int gridSize[2] = {4, 4};\n    int* newSnake;\n\n    // Test case 1: Snake moves up without eating food\n    int food1[2] = {0, 3};\n    newSnake = moveSnake(snake, snakeLength, 0, food1, gridSize);\n    int expectedSnake1[6] = {1, 1, 1, 2, 3, 2};\n    assert(memcmp(newSnake, expectedSnake1, 6 * sizeof(int)) == 0);\n    free(newSnake);\n\n    // Test case 2: Snake moves right and eats food\n    int food2[2] = {2, 2};\n    newSnake = moveSnake(snake, snakeLength, 1, food2, gridSize);\n    int expectedSnake2[8] = {2, 2, 1, 2, 3, 2, 3, 3};\n    assert(memcmp(newSnake, expectedSnake2, 8 * sizeof(int)) == 0);\n    free(newSnake);\n\n    // Test case 3: Snake moves down without eating food\n    int food3[2] = {3, 3};\n    newSnake = moveSnake(snake, snakeLength, 2, food3, gridSize);\n    int expectedSnake3[6] = {1, 3, 1, 2, 3, 2};\n    assert(memcmp(newSnake, expectedSnake3, 6 * sizeof(int)) == 0);\n    free(newSnake);\n\n    // Test case 4: Snake moves left without eating food\n    int food4[2] = {0, 0};\n    newSnake = moveSnake(snake, snakeLength, 3, food4, gridSize);\n    int expectedSnake4[6] = {0, 2, 1, 2, 3, 2};\n    assert(memcmp(newSnake, expectedSnake4, 6 * sizeof(int)) == 0);\n    free(newSnake);\n\n    // Test case 5: Snake moves right and does not eat food\n    int food5[2] = {3, 2};\n    newSnake = moveSnake(snake, snakeLength, 1, food5, gridSize);\n    int expectedSnake5[6] = {2, 2, 1, 2, 3, 2};\n    assert(memcmp(newSnake, expectedSnake5, 6 * sizeof(int)) == 0);\n    free(newSnake);\n}\nint main() {\n    test();\n    return 0;\n}\n"}
{"language": "c", "domain": "game", "source": "人工提问+gpt4生成代码+人工筛选；源文件地址/data/xw/c++dataset/1.6/copy/game/114.c", "prompt": "\n/*\n功能说明：\n黑白棋游戏中，玩家通过翻转棋子来占领棋盘。游戏结束时，棋盘上每个玩家的棋子数即为其得分。实现一个函数，计算并返回游戏结束时双方的得分。\n\n输入参数：\n1. char** board: 一个二维字符数组，表示黑白棋的棋盘，'B'表示黑棋，'W'表示白棋，'.'表示空格。\n2. int size: 棋盘的大小（棋盘是正方形的，这个参数表示棋盘的行数和列数）。\n\n返回值：结构体Score，其中包含两个成员变量，int black 和 int white，分别表示黑棋和白棋的得分。\n\n函数原型示例：\ntypedef struct Score {\n    int black;\n    int white;\n} Score;\n\nScore calculateScore(char** board, int size);\n\n例如：如果棋盘上黑棋有10个，白棋有14个，则返回的Score结构体中black为10，white为14。\n*/\n\n", "solution": "\ntypedef struct Score {\n    int black;\n    int white;\n} Score;\n\nScore calculateScore(char** board, int size) {\n    Score score = {0, 0};\n    for (int i = 0; i < size; ++i) {\n        for (int j = 0; j < size; ++j) {\n            if (board[i][j] == 'B') {\n                ++score.black;\n            } else if (board[i][j] == 'W') {\n                ++score.white;\n            }\n        }\n    }\n    return score;\n}\n\n", "test": "#include <assert.h>\n#include <stdlib.h>\n#include <stdio.h>\nvoid test() {\n    const int size = 8;\n    char* boardData[8] = {\n        \"BWWB.B..\",\n        \"WWBBWBBW\",\n        \"BBBBBWW.\",\n        \"WBBWWBW.\",\n        \"WWWBBB.B\",\n        \"BWBBWBWW\",\n        \".WB...BW\",\n        \"BWWBWBWB\"\n    };\n    \n    char** board = (char**)malloc(size * sizeof(char*));\n    for (int i = 0; i < size; ++i) {\n        board[i] = boardData[i];\n    }\n\n    Score result = calculateScore(board, size);\n\n    // Test case 1: Count black pieces\n    assert(result.black == 29);\n    // printf(\"%d\\n\",result.black);\n\n    // Test case 2: Count white pieces\n    assert(result.white == 25);\n    // printf(\"%d\\n\",result.white);\n\n}\nint main() {\n    test();\n    return 0;\n}"}
{"language": "c", "domain": "game", "source": "人工提问+gpt4生成代码+人工筛选；源文件地址/data/xw/c++dataset/1.6/copy/game/119.c", "prompt": "\n/*\n功能说明：\n在一款足球游戏中，需要实现一个函数来检测球是否进入了球门。球门被定义为一个矩形区域，而球的位置是一个点。\n\n输入参数：\n1. float ballX: 球的X坐标。\n2. float ballY: 球的Y坐标。\n3. float goalX1: 球门左下角的X坐标。\n4. float goalY1: 球门左下角的Y坐标。\n5. float goalX2: 球门右上角的X坐标。\n6. float goalY2: 球门右上角的Y坐标。\n\n返回值：布尔值，如果球完全在球门矩形区域内则返回true，否则返回false。\n\n函数原型示例：\nbool checkGoal(float ballX, float ballY, float goalX1, float goalY1, float goalX2, float goalY2);\n\n例如：如果球的坐标在球门矩形区域内，则函数返回true。\n*/\n\n", "solution": "\n#include <stdbool.h>\n\nbool checkGoal(float ballX, float ballY, float goalX1, float goalY1, float goalX2, float goalY2) {\n    return ballX > goalX1 && ballX < goalX2 && ballY > goalY1 && ballY < goalY2;\n}\n\n", "test": "#include <assert.h>\nvoid test() {\n    // Test case 1: Ball is inside the goal\n    assert(checkGoal(1.0, 2.0, 0.0, 1.0, 3.0, 3.0) == true);\n\n    // Test case 2: Ball is outside the goal (above)\n    assert(checkGoal(2.0, 4.0, 0.0, 1.0, 3.0, 3.0) == false);\n\n    // Test case 3: Ball is outside the goal (below)\n    assert(checkGoal(2.0, 0.5, 0.0, 1.0, 3.0, 3.0) == false);\n\n    // Test case 4: Ball is outside the goal (to the left)\n    assert(checkGoal(-1.0, 2.0, 0.0, 1.0, 3.0, 3.0) == false);\n\n    // Test case 5: Ball is outside the goal (to the right)\n    assert(checkGoal(4.0, 2.0, 0.0, 1.0, 3.0, 3.0) == false);\n}\nint main() {\n    test();\n    return 0;\n}\n"}
{"language": "c", "domain": "game", "source": "人工提问+gpt4生成代码+人工筛选；源文件地址/data/xw/c++dataset/1.6/copy/game/131.c", "prompt": "\n/*\n功能说明：\n在飞镖游戏中，玩家投掷飞镖并击中靶心可以获得分数。本系统需要实现一个函数，用于计算玩家在一轮投掷中的总分。\n\n输入参数：\n1. int hits[]: 记录每次投掷击中的区域分数的数组。\n2. int numberOfHits: 记录的击中次数，即数组hits的长度。\n\n返回值：整型，所有投掷的总分数。\n\n函数原型示例：\nint calculateScore(int hits[], int numberOfHits);\n*/\n\n", "solution": "\nint calculateScore(int hits[], int numberOfHits) {\n    int totalScore = 0;\n    for (int i = 0; i < numberOfHits; ++i) {\n        totalScore += hits[i];\n    }\n    return totalScore;\n}\n\n", "test": "\n#include <assert.h>\n\nvoid test() {\n    int hits1[] = {20, 20, 50}; // Two standard hits and a bullseye\n    int hits2[] = {5, 10, 15};  // Low score hits\n    int hits3[] = {60, 60, 60}; // Three triple-20 hits\n    int hits4[] = {25, 25, 50}; // Two outer bullseyes and a bullseye\n    int hits5[] = {};           // No hits\n\n    // Test case 1: Standard hits with a bullseye should add up to 90\n    assert(calculateScore(hits1, 3) == 90);\n\n    // Test case 2: Low score hits should add up to 30\n    assert(calculateScore(hits2, 3) == 30);\n\n    // Test case 3: Maximum score from hits should add up to 180\n    assert(calculateScore(hits3, 3) == 180);\n\n    // Test case 4: Two outer bullseyes and a bullseye should add up to 100\n    assert(calculateScore(hits4, 3) == 100);\n\n    // Test case 5: No hits should add up to 0\n    assert(calculateScore(hits5, 0) == 0);\n}\nint main() {\n    test();\n    return 0;\n}\n"}
{"language": "c", "domain": "game", "source": "人工提问+gpt4生成代码+人工筛选；源文件地址/data/xw/c++dataset/1.6/copy/game/127.c", "prompt": "\n/*\n功能说明：\n在拳击游戏中，玩家可以对对手进行攻击。游戏需要判断玩家的攻击是否命中对手。\n攻击是否命中取决于玩家的攻击类型和对手的防御类型。\n\n输入参数：\n1. char playerAttack: 玩家的攻击类型，可以是 'J' (直拳), 'U' (上勾拳) 或 'H' (重拳)。\n2. char opponentDefense: 对手的防御类型，可以是 'B' (格挡) 或 'D' (闪避)。\n\n返回值：布尔值，如果攻击命中则返回true，否则返回false。\n\n函数原型示例：\nbool isPunchLanded(char playerAttack, char opponentDefense);\n\n例如：如果玩家使用重拳攻击，对手选择闪避，那么攻击命中。\n*/\n\n", "solution": "\n#include <stdbool.h>\n\nbool isPunchLanded(char playerAttack, char opponentDefense) {\n    // 假设直拳不能被闪避，上勾拳不能被格挡，重拳无视防御\n    if (playerAttack == 'J' && opponentDefense == 'D') {\n        return false; // 直拳被闪避\n    } else if (playerAttack == 'U' && opponentDefense == 'B') {\n        return false; // 上勾拳被格挡\n    } else if (playerAttack == 'H') {\n        return true; // 重拳总是命中\n    }\n    \n    return true; // 其他情况攻击都命中\n}\n\n", "test": "#include <assert.h>\nvoid test() {\n    // Test case 1: Straight punch is dodged\n    assert(isPunchLanded('J', 'D') == false);\n\n    // Test case 2: Uppercut is blocked\n    assert(isPunchLanded('U', 'B') == false);\n\n    // Test case 3: Heavy punch always lands\n    assert(isPunchLanded('H', 'B') == true);\n    assert(isPunchLanded('H', 'D') == true);\n\n    // Test case 4: Straight punch is not blocked\n    assert(isPunchLanded('J', 'B') == true);\n\n    // Test case 5: Uppercut is not dodged\n    assert(isPunchLanded('U', 'D') == true);\n}\nint main() {\n    test();\n    return 0;\n}\n"}
{"language": "c", "domain": "game", "source": "人工提问+gpt4生成代码+人工筛选；源文件地址/data/xw/c++dataset/1.6/copy/game/108.c", "prompt": "\n/*\n功能说明：\n实现一个函数，用于判断在数独游戏的某个位置填入某个数字后，是否仍然满足数独的规则。数独的规则是：每一行、每一列以及每一个九格宫内不能有重复数字（1-9）。\n\n输入参数：\n1. char board[9][9]: 一个9x9的二维字符数组，表示数独的当前状态，'1'-'9'表示已经填入的数字，'.'表示空格。\n2. int row: 要填写的行坐标。\n3. int col: 要填写的列坐标。\n4. char num: 要检查的数字，范围为'1'到'9'。\n\n返回值：布尔值，如果在该位置填写该数字合法，则返回true，否则返回false。\n\n函数原型示例：\nbool isValidSudokuEntry(char board[9][9], int row, int col, char num);\n\n例如：如果数独的某行为\"...1.3..2.\"，在第一行第二个位置填入'5'后仍满足数独规则，函数应该返回true。\n*/\n\n", "solution": "\n#include <stdbool.h>\n\nbool isValidSudokuEntry(char board[9][9], int row, int col, char num) {\n    // Check row\n    for (int i = 0; i < 9; i++) {\n        if (board[row][i] == num) {\n            return false;\n        }\n    }\n\n    // Check column\n    for (int i = 0; i < 9; i++) {\n        if (board[i][col] == num) {\n            return false;\n        }\n    }\n\n    // Check 3x3 block\n    int startRow = (row / 3) * 3;\n    int startCol = (col / 3) * 3;\n    for (int i = 0; i < 3; i++) {\n        for (int j = 0; j < 3; j++) {\n            if (board[startRow + i][startCol + j] == num) {\n                return false;\n            }\n        }\n    }\n\n    return true;\n}\n\n", "test": "#include <assert.h>\nvoid test() {\n    char board[9][9] = {\n        {'5', '3', '.', '.', '7', '.', '.', '.', '.'},\n        {'6', '.', '.', '1', '9', '5', '.', '.', '.'},\n        {'.', '9', '8', '.', '.', '.', '.', '6', '.'},\n        {'8', '.', '.', '.', '6', '.', '.', '.', '3'},\n        {'4', '.', '.', '8', '.', '3', '.', '.', '1'},\n        {'7', '.', '.', '.', '2', '.', '.', '.', '6'},\n        {'.', '6', '.', '.', '.', '.', '2', '8', '.'},\n        {'.', '.', '.', '4', '1', '9', '.', '.', '5'},\n        {'.', '.', '.', '.', '8', '.', '.', '7', '9'}\n    };\n\n    // Test case 1: Entry is valid\n    assert(isValidSudokuEntry(board, 0, 2, '1') == true);\n\n    // Test case 2: Entry is invalid - same number in a row\n    assert(isValidSudokuEntry(board, 0, 2, '5') == false);\n\n    // Test case 3: Entry is invalid - same number in a column\n    assert(isValidSudokuEntry(board, 0, 2, '6') == false);\n\n    // Test case 4: Entry is valid in an empty cell\n    assert(isValidSudokuEntry(board, 4, 4, '5') == true);\n\n    // Test case 5: Entry is invalid - same number in a 3x3 block\n    assert(isValidSudokuEntry(board, 4, 4, '9') == false);\n}\nint main() {\n    test();\n    return 0;\n}\n"}
{"language": "c", "domain": "game", "source": "人工提问+gpt4生成代码+人工筛选；源文件地址/data/xw/c++dataset/1.6/copy/game/121.c", "prompt": "\n/*\n功能说明：\n在一款模拟经营游戏中，玩家拥有不同类型的资源生产建筑。每种建筑每小时产生一定数量的资源。\n需要实现一个函数来计算经过特定时间后，玩家从一种资源生产建筑中获得的资源总量。\n\n输入参数：\n1. int productionPerHour: 每小时的资源生产数量。\n2. int hours: 经过的时间（小时）。\n\n返回值：整数，表示经过给定时间后生产的资源总量。\n\n函数原型示例：\nint calculateResourceGrowth(int productionPerHour, int hours);\n\n例如：如果一个建筑每小时产生10单位资源，经过3小时，则总共产生30单位资源。\n*/\n\n", "solution": "\nint calculateResourceGrowth(int productionPerHour, int hours) {\n    return productionPerHour * hours;\n}\n\n", "test": "#include <assert.h>\nvoid test() {\n    // Test case 1: Standard production\n    assert(calculateResourceGrowth(10, 3) == 30);\n\n    // Test case 2: No production\n    assert(calculateResourceGrowth(0, 5) == 0);\n\n    // Test case 3: No time passed\n    assert(calculateResourceGrowth(10, 0) == 0);\n\n    // Test case 4: One hour of production\n    assert(calculateResourceGrowth(15, 1) == 15);\n\n    // Test case 5: Large numbers\n    assert(calculateResourceGrowth(1000, 24) == 24000);\n}\nint main() {\n    test();\n    return 0;\n}\n"}
{"language": "c", "domain": "game", "source": "人工提问+gpt4生成代码+人工筛选；源文件地址/data/xw/c++dataset/1.6/copy/game/123.c", "prompt": "\n/*\n功能说明：\n在一个记忆卡片游戏中，每张卡片背后都有一个数字。玩家每次翻开两张卡片，如果卡片背后的数字相同，则算作一对匹配。\n需要实现一个函数来判断两次翻卡的数字是否相匹配。\n\n输入参数：\n1. int card1: 第一次翻卡时卡片背后的数字。\n2. int card2: 第二次翻卡时卡片背后的数字。\n\n返回值：布尔值，如果两张卡片匹配则返回true，不匹配则返回false。\n\n函数原型示例：\nbool isMatch(int card1, int card2);\n\n例如：如果玩家翻开的两张卡片背后数字都是8，则返回true表示匹配。\n*/\n\n", "solution": "\n#include <stdbool.h>\n\nbool isMatch(int card1, int card2) {\n    return card1 == card2;\n}\n\n", "test": "#include <assert.h>\nvoid test() {\n    // Test case 1: Cards match\n    assert(isMatch(8, 8) == true);\n\n    // Test case 2: Cards do not match\n    assert(isMatch(8, 7) == false);\n\n    // Test case 3: Cards match with zero\n    assert(isMatch(0, 0) == true);\n\n    // Test case 4: Negative numbers match\n    assert(isMatch(-5, -5) == true);\n\n    // Test case 5: Different negative numbers do not match\n    assert(isMatch(-5, -4) == false);\n}\nint main() {\n    test();\n    return 0;\n}\n"}
{"language": "c", "domain": "game", "source": "人工提问+gpt4生成代码+人工筛选；源文件地址/data/xw/c++dataset/1.6/copy/game/122.c", "prompt": "\n/*\n功能说明：\n在一款音乐节奏游戏中，玩家需要在特定的时间点上按下按钮以匹配节奏。游戏会提供一个时间窗口，在这个时间窗口内玩家的输入被视为正确。\n需要实现一个函数来检测玩家的输入时机是否在这个时间窗口内。\n\n输入参数：\n1. int expectedTime: 预期的正确输入时间（以毫秒为单位）。\n2. int timeWindow: 允许的时间误差窗口（以毫秒为单位）。\n3. int playerInputTime: 玩家实际输入的时间（以毫秒为单位）。\n\n返回值：布尔值，如果玩家的输入在允许的时间窗口内则返回true，否则返回false。\n\n函数原型示例：\nbool isInputTimingCorrect(int expectedTime, int timeWindow, int playerInputTime);\n\n例如：如果预期的正确输入时间是1000毫秒，时间窗口是300毫秒，玩家在950毫秒到1050毫秒之间输入，则输入被视为正确。\n*/\n\n", "solution": "\n#include <stdbool.h>\n\nbool isInputTimingCorrect(int expectedTime, int timeWindow, int playerInputTime) {\n    return playerInputTime >= (expectedTime - timeWindow) && playerInputTime <= (expectedTime + timeWindow);\n}\n\n", "test": "#include <assert.h>\nvoid test() {\n    // Test case 1: Player input is exactly on time\n    assert(isInputTimingCorrect(1000, 300, 1000) == true);\n\n    // Test case 2: Player input is at the beginning of time window\n    assert(isInputTimingCorrect(1000, 300, 700) == true);\n\n    // Test case 3: Player input is at the end of time window\n    assert(isInputTimingCorrect(1000, 300, 1300) == true);\n\n    // Test case 4: Player input is before the time window\n    assert(isInputTimingCorrect(1000, 300, 699) == false);\n\n    // Test case 5: Player input is after the time window\n    assert(isInputTimingCorrect(1000, 300, 1301) == false);\n}\nint main() {\n    test();\n    return 0;\n}\n"}
{"language": "c", "domain": "game", "source": "人工提问+gpt4生成代码+人工筛选；源文件地址/data/xw/c++dataset/1.6/copy/game/120.c", "prompt": "\n/*\n功能说明：\n在一款飞行模拟游戏中，需要实现一个函数来计算飞机的新位置。飞机的移动可以由速度（在X和Y轴上）和一个时间间隔来确定。\n\n输入参数：\n1. float posX: 飞机当前的X坐标。\n2. float posY: 飞机当前的Y坐标。\n3. float velocityX: 飞机在X轴上的速度。\n4. float velocityY: 飞机在Y轴上的速度。\n5. int time: 时间间隔。\n\n返回值：返回一个包含新的X和Y坐标的结构体。\n\n函数原型示例：\ntypedef struct Position {\n    float x;\n    float y;\n} Position;\n\nPosition calculateNewPosition(float posX, float posY, float velocityX, float velocityY, int time);\n\n例如：如果飞机在(0,0)点，速度为(1,1)单位每秒，时间间隔为2秒，则新位置应该是(2,2)。\n*/\n\n", "solution": "\ntypedef struct Position {\n    float x;\n    float y;\n} Position;\n\nPosition calculateNewPosition(float posX, float posY, float velocityX, float velocityY, int time) {\n    Position newPos;\n    newPos.x = posX + velocityX * time;\n    newPos.y = posY + velocityY * time;\n    return newPos;\n}\n\n", "test": "#include <assert.h>\nvoid test() {\n    Position newPos;\n\n    // Test case 1: Positive velocity\n    newPos = calculateNewPosition(0.0, 0.0, 5.0, 3.0, 2);\n    assert(newPos.x == 10.0 && newPos.y == 6.0);\n\n    // Test case 2: Negative velocity\n    newPos = calculateNewPosition(0.0, 0.0, -5.0, -3.0, 2);\n    assert(newPos.x == -10.0 && newPos.y == -6.0);\n\n    // Test case 3: No movement\n    newPos = calculateNewPosition(1.0, 1.0, 0.0, 0.0, 5);\n    assert(newPos.x == 1.0 && newPos.y == 1.0);\n\n    // Test case 4: Zero time interval\n    newPos = calculateNewPosition(1.0, 1.0, 10.0, 10.0, 0);\n    assert(newPos.x == 1.0 && newPos.y == 1.0);\n\n    // Test case 5: Movement along one axis only\n    newPos = calculateNewPosition(0.0, 0.0, 0.0, 5.0, 3);\n    assert(newPos.x == 0.0 && newPos.y == 15.0);\n}\nint main() {\n    test();\n    return 0;\n}\n"}
