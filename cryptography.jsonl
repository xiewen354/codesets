{"language": "c++", "domain": "cryptography", "source": "gpt4+人工筛选；源文件地址/data/xw/c++dataset/key/already/1.cpp", "prompt": "#include <iostream>\n#include <string>\n#include <cassert>\nusing namespace std;\n/*实现一个基本的加密函数，使用简单的字符替换作为加密算法\n输入是一个string字符串，输出是一个加密后的string字符串\n函数的格式如下：string encrypt(string text);\n加密算法是将字母替换为其后第3个字母，例如'a'->'d', 'b'->'e', 'z'->'c'，其它字符不变\n注意英文字母大小写均可以处理\n*/\n", "solution": "string encrypt(string text) {\n    for (auto& c : text) {\n        if ('a' <= c && c <= 'z') {\n            c = 'a' + (c - 'a' + 3) % 26;\n        } else if ('A' <= c && c <= 'Z') {\n            c = 'A' + (c - 'A' + 3) % 26;\n        }\n    }\n    return text;\n}\n", "test": "int main() {\n    assert(encrypt(\"abcABC\")==\"defDEF\");\n    assert(encrypt(\"xyzXYZ\")==\"abcABC\");\n    assert(encrypt(\"Hello, world!\")==\"Khoor, zruog!\");\n    assert(encrypt(\"Javascript\")==\"Mdydvfulsw\");\n    assert(encrypt(\"C++\")==\"F++\");\n    \n    return 0;\n}\n"}
{"language": "c++", "domain": "cryptography", "source": "gpt4+人工筛选；源文件地址/data/xw/c++dataset/key/already/30.cpp", "prompt": "#include <iostream>\n#include <string>\n\nusing namespace std;\n\n/*\n实现一个简单的凯撒密码加密和解密的函数。\nInput: string plainText, char encryptKey ,\n功能: 凯撒密码是一种把正文中的所有字母都整体向后（或向前）移动N位到达加密结果的简单替换方法，这里的N就是encryptKey所包含的数值，而源字符串plainText就是待加密的信息。\n返回密文\nOutput: string\n*/\n", "solution": "string caesarCipher(string plainText, char encryptKey) {\n    string cipherText = \"\";\n    int len = plainText.length();\n    for(int i =0; i<len; i++){\n        if(isupper(plainText[i])) cipherText += char(int(plainText[i]+encryptKey-65)%26 +65);\n        else cipherText += char(int(plainText[i]+encryptKey-97)%26 +97);\n    }\n    return cipherText;\n}\n", "test": "#include<assert.h>\nint main() {\n    assert(caesarCipher(\"HELLO\", 2) == \"JGNNQ\");\n    assert(caesarCipher(\"CAESAR\", 3) == \"FDHVDU\");\n    assert(caesarCipher(\"WORLD\", 5) == \"BTWQI\");\n    assert(caesarCipher(\"ALPHABET\", 1) == \"BMQIBCFU\");\n    assert(caesarCipher(\"CIPHER\", 10) == \"MSZROB\");\n\n    return 0;\n}\n"}
{"language": "c++", "domain": "cryptography", "source": "gpt4+人工筛选；源文件地址/data/xw/c++dataset/key/already/44.cpp", "prompt": "#include<iostream>\n#include<string>\n\nusing namespace std;\n\n/*该程序将实现简单的凯撒密码加密。\n 凯撒密码是一种最简单的加密技术，它将一个字符串中的每个字符向前移动k个位置。\n 例如，字符串 \"HELLO\" 和位移 3 被加密为 \"KHOOR\"。\n 案例描述了一个encrypt函数，接受一个字符串和一个位移作为输入，并返回加密的字符串。\n*/\n", "solution": "string CaesarCipherEncrypt(string text, int shift){\n    string result = \"\";\n    for(int i = 0; i < text.length(); i++){\n        if(isupper(text[i]))\n            result += char(int(text[i]+shift-65)%26 +65);\n        else\n            result += char(int(text[i]+shift-97)%26 +97);\n    }\n    return result;\n}\n", "test": "#include<assert.h>\nint main(){\n    assert(CaesarCipherEncrypt(\"HELLO\",3) == \"KHOOR\");\n    assert(CaesarCipherEncrypt(\"WORLD\",10) == \"GYBVN\");\n    assert(CaesarCipherEncrypt(\"CAESARCIPHER\",15) == \"RPTHPGRXEWTG\");\n    assert(CaesarCipherEncrypt(\"THISISASIMPLECAESARCIPHER\",5) == \"YMNXNXFXNRUQJHFJXFWHNUMJW\");\n    assert(CaesarCipherEncrypt(\"LOOKATTHEBRIGHTSIDE\",20) == \"FIIEUNNBYVLCABNMCXY\");\n    return 0;\n}\n"}
{"language": "c++", "domain": "cryptography", "source": "gpt4+人工筛选；源文件地址/data/xw/c++dataset/key/already/4.cpp", "prompt": "#include <iostream>\n#include <string>\nusing namespace std;\n\n/* 一个字符串的简单加密解密功能的函数，密钥为一位字符，\n字符串中的每个字符通过与密钥进行异或运算得到加密后的字符。\n函数格式定义为：string xorCipher(string input, char key) */\n", "solution": "string xorCipher(string input, char key) {\n    string output = input;\n\n    for (int i = 0; i < output.length(); i++) {\n        output[i] ^= key;\n    }\n\n    return output;\n}\n", "test": "#include<assert.h>\nint main() {\n    char key = 'K';\n    assert(\"Hello\" == xorCipher(xorCipher(\"Hello\", key), key));\n    assert(\"World\" == xorCipher(xorCipher(\"World\", key), key));\n    assert(\"C++\" == xorCipher(xorCipher(\"C++\", key), key));\n    assert(\"Python\" == xorCipher(xorCipher(\"Python\", key), key));\n    assert(\"Java\" == xorCipher(xorCipher(\"Java\", key), key));\n    return 0;\n}\n"}
{"language": "c++", "domain": "cryptography", "source": "gpt4+人工筛选；源文件地址/data/xw/c++dataset/key/already/64.cpp", "prompt": "#include <iostream>\n#include <string>\n\nusing namespace std;\n\n/*实现维吉尼亚密码的加密函数\n维吉尼亚密码是一种使用一组密钥进行多次凯撒加密的方法\n函数的定义：string vigenereEncrypt(string text, string key)\n输入参数为待加密的明文text和密钥key的字符串\n返回一个代表加密后的密文的字符串\n注意：为简化计算，我们假设text和key中的字符只包含小写字母，也就是说text和key中的每个字符都在'a'到'z'之间\n*/\n", "solution": "string vigenereEncrypt(string text, string key) {\n    string resultText = \"\";\n    int textLength = text.length();\n    int keyLength = key.length();\n\n    for (int i = 0; i < textLength; i++) {\n        char c = (text[i] + key[i % keyLength] - 2 * 'a') % 26 + 'a'; \n        resultText += c;\n    }\n    return resultText;\n}\n", "test": "#include<assert.h>\nint main() {\n    assert(vigenereEncrypt(\"attackatdawn\", \"lemon\") == \"lxfopvefrnhr\");\n    assert(vigenereEncrypt(\"defendthecastle\", \"key\") == \"nidorbdlcmeqdpc\");\n    assert(vigenereEncrypt(\"weareunderattack\", \"password\") == \"lesjaiegtrslpotn\");\n    assert(vigenereEncrypt(\"executeorder\", \"supersecret\") == \"wrtglliqihxj\");\n    assert(vigenereEncrypt(\"prepareforbattle\", \"vikings\") == \"kzoxnxwawbjnzlgm\");\n    return 0;\n}\n"}
{"language": "c++", "domain": "cryptography", "source": "gpt4+人工筛选；源文件地址/data/xw/c++dataset/key/already/3.cpp", "prompt": "#include<iostream>\n#include<bitset>\nusing namespace std;\n\n/* 实现一个简单的XOR加密解密函数\n函数格式定义为：string XORCipher(string toEncrypt, char key)\ntoEncrypt 是一个需要加密或已加密的字符串\nkey 是一个字符，用来做为密钥与toEncrypt中的每个字符进行XOR操作\n如果toEncrypt是未加密字符串，那么函数返回加密后的字符串\n如果toEncrypt是已加密字符串，那么函数返回解密后的字符串\n*/\n", "solution": "string XORCipher(string toEncrypt, char key) {\n    string output = toEncrypt;\n    \n    for (int i = 0; i < toEncrypt.size(); i++)\n        output[i] = toEncrypt[i] ^ key;\n    \n    return output;\n}\n", "test": "#include<assert.h>\n\nint main() {\n    char key = 'K'; // key for XOR encryption\n    string original_str = \"Hello World!\";\n    string encrypted_str = XORCipher(original_str, key);\n    string decrypted_str = XORCipher(encrypted_str, key);\n    \n    assert(encrypted_str != original_str);\n    assert(decrypted_str == original_str);\n    assert(XORCipher(XORCipher(\"Test String\", 'T'),'T') == \"Test String\");\n    \n    return 0;\n}\n"}
{"language": "c++", "domain": "cryptography", "source": "gpt4+人工筛选；源文件地址/data/xw/c++dataset/key/already/77.cpp", "prompt": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n/* \n实现一个简单的凯撒密码加密功能\nvoid caesar_encrypt(const char *input, char *output, int shift)\ninput 是输入的明文字符串，output 是一个足够大的数组用来存放加密后的结果, shift 是移位的位数\n*/\n", "solution": "void caesar_encrypt(const char *input, char *output, int shift) {\n    int i = 0;\n    while(input[i] != '\\0'){\n        if(input[i] >= 'a' && input[i]<= 'z'){\n            output[i] = ((input[i] - 'a' + shift) % 26) + 'a';\n        }\n        else if(input[i] >= 'A' && input[i]<= 'Z'){\n            output[i] = ((input[i] - 'A' + shift) % 26) + 'A';\n        } \n        else{\n            output[i] = input[i];\n        }\n        i++;\n    }\n    output[i] = '\\0';\n}\n", "test": "#include <assert.h>\n#include <string.h>\nint main(){\n    char output[100];\n    const char *input1 = \"abc\";\n    caesar_encrypt(input1,output,3);\n    assert(strcmp(output, \"def\") == 0);\n\n    const char *input2 = \"xyz\";\n    caesar_encrypt(input2,output,3);\n    assert(strcmp(output, \"abc\") == 0);\n\n    const char *input3 = \"ABC\";\n    caesar_encrypt(input3,output,3);\n    assert(strcmp(output, \"DEF\") == 0);\n\n    const char *input4 = \"XYZ\";\n    caesar_encrypt(input4,output,3);\n    assert(strcmp(output, \"ABC\") == 0);\n\n    const char *input5 = \"aBcXyZ\";\n    caesar_encrypt(input5,output,3);\n    assert(strcmp(output, \"dEfAbC\") == 0);\n\n    return 0;\n}\n"}
{"language": "c++", "domain": "cryptography", "source": "gpt4+人工筛选；源文件地址/data/xw/c++dataset/key/already/35.cpp", "prompt": "#include <string>\n#include <cstring>\n#include <iostream>\nusing namespace std;\n/*调用string且定义一个CaesarCipher函数实现凯撒密码加密。\n  凯撒密码是一种替换加密的技术，明文中的所有字母都在字母表上向后(或向前)按照一个固定数目进行偏移后被替换成密文。\n  string CaesarCipher(string text, int shift)\n  text 是需要加密的明文，shift 是用户定义的偏移量，返回加密后的密文\n*/\n", "solution": "std::string CaesarCipher(std::string text, int shift) {\n    std::string result = \"\";\n    for(int i=0;i<text.length();i++){\n        if(isupper(text[i]))\n            result += char(int(text[i]+shift-65)%26 +65);\n        else\n            result += char(int(text[i]+shift-97)%26 +97);\n    }\n    return result;\n}\n", "test": "#include<assert.h>\nint main() {\n    std::string text1 = \"abc\";\n    int shift1 = 2;\n    assert(CaesarCipher(text1, shift1)==\"cde\");\n    \n    std::string text2 = \"XYZ\";\n    int shift2 = 3;\n    assert(CaesarCipher(text2, shift2)==\"ABC\");\n    \n    std::string text3 = \"Hello\";\n    int shift3 = 4;\n    assert(CaesarCipher(text3, shift3)==\"Lipps\");\n    \n    std::string text4 = \"world\";\n    int shift4 = 5;\n    assert(CaesarCipher(text4, shift4)==\"btwqi\");\n    \n    std::string text5 = \"OpenAI\";\n    int shift5 = 6;\n    assert(CaesarCipher(text5, shift5)==\"UvktGO\");\n    \n    return 0;\n}\n"}
{"language": "c++", "domain": "cryptography", "source": "gpt4+人工筛选；源文件地址/data/xw/c++dataset/key/already/66.cpp", "prompt": "#include<iostream>\n#include<string>\n\nusing namespace std;\n\n/* 使用凯撒密码进行字符串加密\n   用户输入字符串和平移数，输出加密后的字符串。\n   用户只需输入英文字符串和整数，其中英文字符串只包含小写字母，整数为平移次数。\n   凯撒密码的实质是将每一个字符向后平移，如果超出'a'和'z'，则从头开始，保证加密后的字符还在小写字母的范围内。\n*/\n", "solution": "string caesarEncryption(string text, int s) {\n    for (int i = 0; i < text.length(); i++) {\n        text[i] = ((text[i] - 'a' + s) % 26) + 'a';\n    }\n    return text;\n}\n", "test": "#include<assert.h>\nint main() {\n    assert(caesarEncryption(\"hello\", 3) == \"khoor\");\n    assert(caesarEncryption(\"world\", 1) == \"xpsme\");\n    assert(caesarEncryption(\"computer\", 23) == \"zljmrqbo\");\n    assert(caesarEncryption(\"science\", 10) == \"cmsoxmo\");\n    assert(caesarEncryption(\"engineering\", 5) == \"jslnsjjwnsl\");\n    return 0;\n}\n"}
{"language": "c++", "domain": "cryptography", "source": "gpt4+人工筛选；源文件地址/data/xw/c++dataset/key/already/6.cpp", "prompt": "#include <iostream>\n#include <string>\nusing namespace std;\n\n/*实现字符串的XOR加密和解密函数\n函数的格式定义为：string xorCipherDecryptor(string input, char secretKey)\n这里input表示待加密或解密的字符串，secretKey表示秘密关键字\n返回一个表示处理后结果的字符串*/\n", "solution": "string xorCipherDecryptor(string input, char secretKey){\n    string output = input;\n \n    for (int i = 0; i < input.size(); i++)\n        output[i] = input[i] ^ secretKey;\n \n    return output;\n}\n", "test": "#include<assert.h>\nint main() {\n    string message = \"HELLO\";\n    char secretKey = 'K';\n    string encryptedMessage = xorCipherDecryptor(message, secretKey);\n    string decryptedMessage = xorCipherDecryptor(encryptedMessage, secretKey);\n    assert(message == decryptedMessage);\n\n    message = \"WORLD\";\n    secretKey = 'L';\n    encryptedMessage = xorCipherDecryptor(message, secretKey);\n    decryptedMessage = xorCipherDecryptor(encryptedMessage, secretKey);\n    assert(message == decryptedMessage);\n\n    message = \"MACHINE\";\n    secretKey = 'E';\n    encryptedMessage = xorCipherDecryptor(message, secretKey);\n    decryptedMessage = xorCipherDecryptor(encryptedMessage, secretKey);\n    assert(message == decryptedMessage);\n\n    message = \"LEARNING\";\n    secretKey = 'R';\n    encryptedMessage = xorCipherDecryptor(message, secretKey);\n    decryptedMessage = xorCipherDecryptor(encryptedMessage, secretKey);\n    assert(message == decryptedMessage);\n\n    message = \"DEEP\";\n    secretKey = 'P';\n    encryptedMessage = xorCipherDecryptor(message, secretKey);\n    decryptedMessage = xorCipherDecryptor(encryptedMessage, secretKey);\n    assert(message == decryptedMessage);\n\n    return 0;\n}\n"}
{"language": "c++", "domain": "cryptography", "source": "gpt4+人工筛选；源文件地址/data/xw/c++dataset/key/already/39.cpp", "prompt": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\n/*\n凯撒密码实现\nvoid caeser_cipher(char* input, int shift, char* output)\ninput是输入的明文，shift是移位的位数，output是加密后的密文\n*/\n", "solution": "void caeser_cipher(char* input, int shift, char* output) \n{\n    int i = 0;\n    while(input[i] != '\\0')\n    {\n        char c = input[i];\n        if(c >= 'a' && c <= 'z')\n            output[i] = (c - 'a' + shift)%26 + 'a';\n        else if(c >= 'A' && c <= 'Z')\n            output[i] = (c - 'A' + shift)%26 + 'A';\n        else\n            output[i] = c;\n        i++;\n    }\n    output[i] = '\\0';\n}\n", "test": "#include<assert.h>\nint main() \n{\n    char output[100];\n    caeser_cipher(\"hello\", 1, output);\n    assert(strcmp(output, \"ifmmp\") == 0);\n    caeser_cipher(\"HELLO\", 1, output);\n    assert(strcmp(output, \"IFMMP\") == 0);\n    caeser_cipher(\"Hello World!\", 1, output);\n    assert(strcmp(output, \"Ifmmp Xpsme!\") == 0);\n    return 0;\n}\n"}
{"language": "c++", "domain": "cryptography", "source": "gpt4+人工筛选；源文件地址/data/xw/c++dataset/key/already/0.cpp", "prompt": "#include <iostream>\n#include <string>\n\nusing namespace std;\n\n/*\n实现一个简单的凯撒密码加密解密方法。\n输入参数为字符串以及一个用于偏移字符的整数。\n加密函数通过将每个字符偏移指定的大小后得到一个新的字符，从而实现加密。\n解密函数则是反向偏移字符以得到原始的字符。\n*/\n", "solution": "string caesarCipherEncrypt(string text, int shift) {\n    string result = \"\";\n    for (int i = 0; i < text.size(); i++) {\n        if (islower(text[i]))\n            result += char(int(text[i] + shift - 97) % 26 + 97);\n        else\n            result += char(int(text[i] + shift - 65) % 26 + 65);\n    }\n    return result;\n}\n\nstring caesarCipherDecrypt(string text, int shift) {\n    string result = \"\";\n    for (int i = 0; i < text.size(); i++) {\n        if (islower(text[i]))\n            result += char(int(text[i] - shift - 97 + 26) % 26 + 97);\n        else\n            result += char(int(text[i] - shift - 65 + 26) % 26 + 65);\n    }\n    return result;\n}\n", "test": "#include<assert.h>\nint main() {\n    assert(caesarCipherEncrypt(\"ABC\", 1) == \"BCD\");\n    assert(caesarCipherDecrypt(\"BCD\", 1) == \"ABC\");\n    assert(caesarCipherEncrypt(\"xyz\", 2) == \"zab\");\n    assert(caesarCipherDecrypt(\"zab\", 2) == \"xyz\");\n    assert(caesarCipherEncrypt(\"HelloWorld\", 5) == \"MjqqtBtwqi\");\n    assert(caesarCipherDecrypt(\"MjqqtBtwqi\", 5) == \"HelloWorld\");\n\n    return 0;\n}\n"}
{"language": "c++", "domain": "cryptography", "source": "gpt4+人工筛选；源文件地址/data/xw/c++dataset/key/already/81.cpp", "prompt": "#include <stdio.h>\n#include <string.h>\n#include <openssl/bn.h>\n#include <openssl/rsa.h>\n#include <openssl/pem.h>\n#include <openssl/err.h>\n\n/*用RSA公钥加密并用RSA私钥解密\nvoid rsa_encrypt_decrypt(const char *Message, char *encrypted_message, char *decrypted_message, int key_length)\nMessage是要加密的消息，encrypted_message是加密后的消息，decrypted_message是解密后的消息，key_length是密钥长度。\n加密过程结束后，encrypted_message包含加密后的消息，decrypted_message包含解密后的消息。\n*/\n", "solution": "void rsa_encrypt_decrypt(const char *Message, char *encrypted_message, char *decrypted_message, int key_length)\n{\n    RSA *keypair;\n    size_t pri_len;\n    size_t pub_len;\n    char *pri_key;\n    char *pub_key; \n    int encrypt_len, decrypt_len;   \n    keypair = RSA_generate_key(key_length, RSA_3, NULL, NULL);\n    BIO *pri = BIO_new(BIO_s_mem());\n    BIO *pub = BIO_new(BIO_s_mem());\n    PEM_write_bio_RSAPrivateKey(pri, keypair, NULL, NULL, 0, NULL, NULL);\n    PEM_write_bio_RSAPublicKey(pub, keypair);\n\n    pri_len = BIO_pending(pri);\n    pub_len = BIO_pending(pub);\n    pri_key = (char*)malloc(pri_len + 1);\n    pub_key = (char*)malloc(pub_len + 1);\n    BIO_read(pri, pri_key, pri_len);\n    BIO_read(pub, pub_key, pub_len);\n    pri_key[pri_len] = '\\0';\n    pub_key[pub_len] = '\\0';\n    \n    encrypt_len = RSA_public_encrypt(strlen(Message)+1, (unsigned char*)Message, (unsigned char*)encrypted_message, keypair, RSA_PKCS1_OAEP_PADDING);\n    RSA_private_decrypt(encrypt_len, (unsigned char*)encrypted_message, (unsigned char*)decrypted_message, keypair, RSA_PKCS1_OAEP_PADDING);\n    \n    free(pri_key);\n    free(pub_key);\n}\n", "test": "#include<assert.h>\nint main() \n{\n    char Message[] = \"Hello, world!\";\n    char encrypted_message[4098] = {};\n    char decrypted_message[4098] = {};\n    rsa_encrypt_decrypt(Message, encrypted_message, decrypted_message, 2048);\n    assert(strcmp(Message, decrypted_message) == 0);\n    return 0;\n}\n"}
{"language": "c++", "domain": "cryptography", "source": "gpt4+人工筛选；源文件地址/data/xw/c++dataset/key/already/9.cpp", "prompt": "#include <string>\n#include<iostream>\nusing namespace std;\n\n/*\n实现一个简单的密码学工具 - Caesar Cipher（凯撒加密）\nCaesar Cipher 是一种最简单的密码学加密算法，它是一种替换型的加密算法，即通过将需要加密的明文中的每个字符，替换为其后的第n个字符进行加密。\n函数格式定义为：string caesarCipher(string text, int shift)\ntext 是需要加密的明文，shift 是移位的数量\n返回一个加密后的密文\n*/\n", "solution": "string caesarCipher(string text, int shift) {\n    string result = \"\";\n    for (int i = 0; i < text.length(); i++) {\n        if (isupper(text[i])) {\n            result += char(int(text[i] + shift - 65) % 26 + 65);\n        } else {\n            result += char(int(text[i] + shift - 97) % 26 + 97);\n        }\n    }\n    return result;\n}\n", "test": "#include<assert.h>\n\nint main() {\n  assert(caesarCipher(\"HELLO\", 3) == \"KHOOR\");\n  assert(caesarCipher(\"WORLD\", 4) == \"ASVPH\");\n  assert(caesarCipher(\"HELLO\", 13) == \"URYYB\");\n  assert(caesarCipher(\"WORLD\", 13) == \"JBEYQ\");\n  assert(caesarCipher(\"HELLO\", 26) == \"HELLO\");\n\n  return 0;\n}\n"}
{"language": "c++", "domain": "cryptography", "source": "gpt4+人工筛选；源文件地址/data/xw/c++dataset/key/already/71.cpp", "prompt": "#include <iostream>\n#include <cmath>\n/*使用简单代换密码进行加密。\nstring substitutionCipherEncrypt(string text, string key)\ntext是明文，key是替换密码，加密规则是根据key的索引位置来替换text中的字符，返回加密后的密文。错误返回\"Error\"\n*/\n", "solution": "std::string substitutionCipherEncrypt(std::string text, std::string key) {\n    if(key.length() != 26) {\n        return \"Error\";\n    }\n    std::string output = text;\n    for(int i = 0; i < text.length(); i++) {\n        if(isalpha(text[i])) {\n            bool isUpperCase = isupper(text[i]);\n            char cipherChar = key[tolower(text[i]) - 'a'];\n            output[i] = isUpperCase ? toupper(cipherChar) : cipherChar;\n        } else {\n            output[i] = text[i];\n        }\n    }\n    return output;\n}\n", "test": "#include<assert.h>\nint main() {\n    std::string text1=\"cryptography\";\n    std::string key1=\"bcdefghijklmnopqrstuvwxyza\";\n    assert(substitutionCipherEncrypt(text1, key1)==\"dszquphsbqiz\");\n    std::string text2=\"cipher\";\n    std::string key2=\"bcdefghijklmnopqrstuvwxyza\";\n    assert(substitutionCipherEncrypt(text2, key2)==\"djqifs\");\n    std::string text3=\"textwithnumbers1234\";\n    std::string key3=\"bcdefghijklmnopqrstuvwxyza\";\n    // assert(substitutionCipherEncrypt(text3, key3)==\"ufyuixjuijnvmfst1234\");\n    std::string text4=\"wrongkeylength\";\n    std::string key4=\"bcdefghijklmnopq\";\n    assert(substitutionCipherEncrypt(text4, key4)==\"Error\");\n    std::string text5=\"\";\n    std::string key5=\"bcdefghijklmnopqrstuvwxyza\";\n    assert(substitutionCipherEncrypt(text5, key5)==\"\");\n    return 0;\n}\n"}
{"language": "c++", "domain": "cryptography", "source": "gpt4+人工筛选；源文件地址/data/xw/c++dataset/key/already/97.cpp", "prompt": "#include <iostream>\n#include <vector>\n/*\n使用AES加密算法对字符串进行加密\nstring AES_encrypt(string plainText, string key)\nplainText是待加密的明文，key是用于加密的密钥，返回加密后的密文\n注意，这里简化了AES的实现，且未进行任何安全性处理，仅供学习使用\n*/\n", "solution": "#include <openssl/aes.h>\n\nstd::string AES_encrypt(std::string plainText, std::string key) {\n    AES_KEY encryptKey;\n    AES_set_encrypt_key((unsigned char*)key.c_str(), 128, &encryptKey);\n\n    int len = plainText.length();\n    unsigned char encryptString[1000];\n    AES_encrypt((unsigned char*)plainText.c_str(), encryptString, &encryptKey);\n\n    std::string encryptText = \"\";\n    for(int i = 0; i < len; ++i) {\n        encryptText += encryptString[i];\n    }\n    return encryptText;\n}\n", "test": "#include<assert.h>\nint main() {\n    std::string plainText = \"hello world\";\n    std::string key = \"password\";\n    std::string cipherText = AES_encrypt(plainText, key);\n    // 根据AES的定义，没有明确定义的输出\n    std::cout<<cipherText<<std::endl;\n    return 0;\n}\n"}
{"language": "c++", "domain": "cryptography", "source": "gpt4+人工筛选；源文件地址/data/xw/c++dataset/key/already/95.cpp", "prompt": "#include<string>\n#include <iostream>\nusing namespace std;\n\n/*实现凯撒密码加密的函数\n输入是一个明文字符串，和一个整数偏移量\n函数的定义为：string caesarEncrypt(string plaintext, int shift)\nplaintext - 明文字符串，只包含英文小写字母\nshift - 加密时的整数偏移量\n返回一个加密后的密文字符串。\n*/\n", "solution": "string caesarEncrypt(string plaintext, int shift) {\n    string ciphertext = \"\";\n    //遍历每个字符,向右偏移\n    for(auto &ch : plaintext){\n        ch = (ch - 'a' + shift) % 26 + 'a';\n        ciphertext += ch;\n    }\n    return ciphertext;\n}\n", "test": "#include<assert.h>\nint main() {\n    assert(caesarEncrypt(\"hello\",3)==\"khoor\");\n    assert(caesarEncrypt(\"world\",7)==\"dvysk\");\n    assert(caesarEncrypt(\"caesar\",5)==\"hfjxfw\");\n    assert(caesarEncrypt(\"cryptology\",10)==\"mbizdyvyqi\");\n    assert(caesarEncrypt(\"encryption\",15)==\"tcrgneixdc\");\n\n    return 0;\n}\n"}
{"language": "c++", "domain": "cryptography", "source": "gpt4+人工筛选；源文件地址/data/xw/c++dataset/key/already/53.cpp", "prompt": "#include<iostream>\n#include<string>\nusing namespace std;\n/*\n进行简单的笛卡尔密码加密\nstring caesarCipherEncrypt(const string &text, int shift)\ntext:待加密的文本\nshift:位移的字符数\n返回:加密后的文本\n*/\n", "solution": "std::string caesarCipherEncrypt(const std::string &text, int shift) {\n    std::string result = \"\";\n\tfor (int i = 0; i < text.length(); i++)\n\t{\n\t\tif (isupper(text[i]))\n\t\t\tresult += char(int(text[i] + shift - 65) % 26 + 65);\n\t\telse\n\t\t\tresult += char(int(text[i] + shift - 97) % 26 + 97);\n\t}\n    return result;\n}\n", "test": "#include<assert.h>\nint main() {\n    std::string plaintext1 = \"attackatdawn\";\n    std::string plaintext2 = \"meetmeafterthesunset\";\n    std::string plaintext3 = \"laydownyourweapons\";\n    assert(caesarCipherEncrypt(plaintext1, 2)==\"cvvcemcvfcyp\");\n    assert(caesarCipherEncrypt(plaintext2, 3)==\"phhwphdiwhuwkhvxqvhw\");\n    assert(caesarCipherEncrypt(plaintext3, 1)==\"mbzepxozpvsxfbqpot\");\n    \n    return 0;\n}\n"}
{"language": "c++", "domain": "cryptography", "source": "gpt4+人工筛选；源文件地址/data/xw/c++dataset/key/already/15.cpp", "prompt": "#include <iostream>\n#include <string>\n#include <openssl/evp.h>\n#include <openssl/aes.h>\n#include <cstring>\n/* 调用AES密码库函数进行对称加密\nstd::string AES_encrypt(const std::string& plaintext, const std::string& key)\n其中，plaintext是需要加密的明文，key是用户设定的密钥，返回值是加密后的密文\n注：当明文或密钥为空时，返回空字符串\n*/\n", "solution": "std::string AES_encrypt(const std::string& plaintext, const std::string& key){\n    if(plaintext.empty() || key.empty()){\n        return std::string();\n    }\n    EVP_CIPHER_CTX* ctx = EVP_CIPHER_CTX_new();\n    EVP_EncryptInit_ex(ctx, EVP_aes_128_ecb(), NULL, (unsigned char*)key.c_str(), NULL);\n    unsigned char out[plaintext.size() + AES_BLOCK_SIZE] = {0};\n    int outlen1, outlen2;\n    EVP_EncryptUpdate(ctx, out, &outlen1, (unsigned char*)plaintext.c_str(), plaintext.size());\n    EVP_EncryptFinal_ex(ctx, out + outlen1, &outlen2);\n    EVP_CIPHER_CTX_free(ctx);\n    return std::string((char*)out, outlen1 + outlen2);\n}\n", "test": "#include<assert.h>\nint main(){\n    assert(AES_encrypt(\"\",\"key\")==\"\");//当明文为空时，返回空字符串\n    assert(AES_encrypt(\"plaintext\",\"\")==\"\");//当密钥为空时，返回空字符串\n    assert(AES_encrypt(\"\",\"\")==\"\");//当明文和密钥都为空时，返回空字符串\n    std::string encrypted = AES_encrypt(\"plaintext\",\"password\");\n    assert(!encrypted.empty());//当明文和密钥都非空时，加密后的字符串不为空\n    assert(encrypted!=\"plaintext\");//加密后的密文与明文不相同\n    return 0;\n}\n"}
{"language": "c++", "domain": "cryptography", "source": "gpt4+人工筛选；源文件地址/data/xw/c++dataset/key/already/79.cpp", "prompt": "#include <iostream>\n#include <string>\n\nusing namespace std;\n\n/* 实现一个简单的维吉尼亚加密函数\n函数的格式定义为：string VigenereEncrypt(string plaintext, string key)\n输入一个明文字符串和一个密钥字符串（只包含小写英文字母），输出一个加密后的密文字符串。\n维吉尼亚密码是一种凯撒密码的加强版，使用一个密钥和明文中的每个字符进行凯撒加密。\n具体的加密方法是：将明文中的每个字符的ASCII码值（a为0，b为1，...）加上密钥中对应位置字符的ASCII码值（a为0，b为1，...），然后模26，得到密文字符。\n*/\n", "solution": "string VigenereEncrypt(string plaintext, string key) {\n    int n = plaintext.size();\n    int m = key.size();\n    string ciphertext(n, ' ');\n    for (int i = 0; i < n; i++) {\n        char plain = plaintext[i];\n        char keychar = key[i % m];\n        ciphertext[i] = 'a' + (plain - 'a' + keychar - 'a') % 26;\n    }\n    return ciphertext;\n}\n", "test": "#include <assert.h>\n\nint main() {\n    assert(VigenereEncrypt(\"hello\", \"abc\") == \"hfnlp\");\n    assert(VigenereEncrypt(\"world\", \"abc\") == \"wptle\");\n    assert(VigenereEncrypt(\"test\", \"abc\") == \"tfut\");\n    assert(VigenereEncrypt(\"plaintext\", \"abc\") == \"pmcioveyv\");\n    assert(VigenereEncrypt(\"vigenere\", \"abc\") == \"vjieogrf\");\n\n    return 0;\n}\n"}
{"language": "c++", "domain": "cryptography", "source": "gpt4+人工筛选；源文件地址/data/xw/c++dataset/key/already/59.cpp", "prompt": "#include <iostream>\n#include <string>\n// 使用异或操作进行简单加密\n// std::string simple_encryption(std::string text, char key)\n// 输入参数：\n// text - 需要加密的原文\n// key - 加密密钥\n// 输出参数：\n// 加密之后的密文\n// 描述：\n// 该函数将原文中的每个字符和密钥进行异或操作，用来进行简单的加密\n", "solution": "std::string simple_encryption(std::string text, char key) {\n    std::string result = text;\n    for (int i = 0; i < text.length(); i++) {\n        result[i] = text[i] ^ key;\n    }\n    return result;\n}\n", "test": "#include<assert.h>\nint main() {\n    using namespace std;\n    string text = \"Computer Science\";\n    char key = 'K';\n    // string expected_result = \"\\x85\\x8c\\x88\\x97\\x95\\x8c\\x82\\xde\\x8c\\x8b\\x86\\x89\\x95\\x8d\\x8c\";\n    \n    string encrypted_text = simple_encryption(text, key);\n    // assert(encrypted_text == expected_result);\n    \n    // 因为是通过异或操作加密，所以再异或一次可以得到原文\n    string decrypted_text = simple_encryption(encrypted_text, key);\n    assert(decrypted_text == text);\n\n    string another_text = \"Cryptography\";\n    char another_key = 'S';\n    // string another_expected_result = \"\\x8e\\x98\\x90\\x8b\\x85\\x98\\x92\\x93\\x8a\\x85\\x90\\x9f\";\n    \n    string another_encrypted_text = simple_encryption(another_text, another_key);\n    // assert(another_encrypted_text == another_expected_result);\n\n    string another_decrypted_text = simple_encryption(another_encrypted_text, another_key);\n    assert(another_decrypted_text == another_text);\n\n    return 0;\n}\n"}
{"language": "c++", "domain": "cryptography", "source": "gpt4+人工筛选；源文件地址/data/xw/c++dataset/key/already/24.cpp", "prompt": "#include <iostream>\n#include <string.h>\n\nusing namespace std;\n\n/*\n实现异或加密的函数\n函数格式定义为： string XORCipher(string str, string key)\nstr是待加密或解密的字符串\nkey是用于加密的密钥\n加密和解密的方法相同，只要再次使用相同的密钥异或就可以得到原始数据\n返回异或加密/解密后的字符串\n*/\n", "solution": "string XORCipher(string str, string key) {\n    string xorStr = str;\n    for (int i = 0; i < str.size(); i++) {\n        xorStr[i] = str[i] ^ key[i % key.size()]; \n    }\n    return xorStr;\n}\n", "test": "#include<assert.h>\nint main(){\n    string str = \"Hello, World!\";\n    string key = \"key\";\n    string cipherText = XORCipher(str, key);\n    string plainText = XORCipher(cipherText, key);\n    assert(plainText == str);\n\n    str = \"Test string\";\n    key = \"test\";\n    cipherText = XORCipher(str, key);\n    plainText = XORCipher(cipherText, key);\n    assert(plainText == str);\n\n    str = \"Another test string\";\n    key = \"anotherkey\";\n    cipherText = XORCipher(str, key);\n    plainText = XORCipher(cipherText, key);\n    assert(plainText == str);\n\n\n    return 0;\n} \n"}
{"language": "c++", "domain": "cryptography", "source": "gpt4+人工筛选；源文件地址/data/xw/c++dataset/key/already/25.cpp", "prompt": "#include <iostream>\n#include <string>\n#include <bitset>\n\nusing namespace std;\n\n/* 实现一个简单的XOR字符串加密函数\n函数的格式定义为：string xorEncrypt(string text, char key)\ntext 是待加密的字符串， key是用于加密的密钥字符（仅一个字母）\n返回值是用XOR运算加密后的字符串结果（二进制形式）\nXOR运算是对二进制的数进行异或运算，两个相同的数异或的结果是0，两个不同的数异或的结果是1\n*/\n", "solution": "string xorEncrypt(string text, char key) {\n    string binaryResult = \"\";\n    // 遍历文本的每个字符\n    for (int i = 0; i < text.size(); i++) {\n        // 将字符和密钥进行XOR运算，并转换为二进制字符串\n        bitset<8> bits(text[i] ^ key);\n        binaryResult += bits.to_string();\n    }\n\n    return binaryResult;\n}\n", "test": "#include<assert.h>\nint main() {\n    assert(xorEncrypt(\"hello\", 'a') == \"0000100100000100000011010000110100001110\");\n    assert(xorEncrypt(\"world\", 'x') == \"0000111100010111000010100001010000011100\");\n    assert(xorEncrypt(\"C++\", 'y') == \"001110100101001001010010\");\n    assert(xorEncrypt(\"\", 'z') == \"\");\n    assert(xorEncrypt(\"123\", '5') == \"000001000000011100000110\");\n\n    return 0;\n}\n"}
{"language": "c++", "domain": "cryptography", "source": "gpt4+人工筛选；源文件地址/data/xw/c++dataset/key/already/36.cpp", "prompt": "#include <iostream>\n#include <string>\n#include <iostream>\nusing namespace std;\n/*实现了一个基于ASCII的非对称凯撒密码算法\nstring caesarCipher(string text, int shift)\ntext 是将要被加密的明文\nshift 是凯撒密码算法的位移量，也就是每一个字符会向后移动多少个字符\n该函数会返回用凯撒密码加密后的密文\n*/\n", "solution": "string caesarCipher(string text, int shift) {\n    string result = \"\";\n    for (int i=0; i<text.length(); i++) {\n        char c = text[i];\n        if (c>='a' && c<='z') {\n            c = 'a' + (c - 'a' + shift) % 26;\n        } else if (c>='A' && c<='Z') {\n            c = 'A' + (c - 'A' + shift) % 26;\n        }\n        result += c;\n    }\n    return result;\n}\n", "test": "#include<assert.h>\n#include<string.h>\nint main() {\n    assert(caesarCipher(\"Hello World\", 3) == \"Khoor Zruog\");\n    assert(caesarCipher(\"ABCDEFGHIJKLMNOPQRSTUVWXYZ\", 1) == \"BCDEFGHIJKLMNOPQRSTUVWXYZA\");\n    assert(caesarCipher(\"Caesar Cipher\", 5) == \"Hfjxfw Hnumjw\");\n    assert(caesarCipher(\"I Love Encryption\", 7) == \"P Svcl Lujyfwapvu\");\n    assert(caesarCipher(\"C Plus Plus\", 9) == \"L Yudb Yudb\");\n    return 0;\n}\n"}
{"language": "c++", "domain": "cryptography", "source": "gpt4+人工筛选；源文件地址/data/xw/c++dataset/key/already/31.cpp", "prompt": "#include <iostream>\n#include <string>\n\nusing namespace std;\n\n/* 实现凯撒密码的加密和解密\n字符串的格式定义为：string CaesarCipher(string text, int shift, bool encrypt)\ntext是待处理的字符串\nshift是偏移量\nencrypt是指明是否进行加密操作，为true时进行加密，为false时进行解密\n返回一个处理结果字符串\n*/\n", "solution": "string CaesarCipher(string text, int shift, bool encrypt) {\n    string result = \"\";\n    int length = text.length();\n\n    for(int i=0; i < length; i++){\n        if(isupper(text[i])){\n            result += char(int(text[i] + shift - 65) % 26 + 65);\n        }else{\n            result += char(int(text[i] + shift - 97) % 26 + 97);\n        }\n    }\n    \n    if(encrypt)\n        return result; // For encryption\n    else{\n        result = \"\";\n        for(int i=0; i < length; i++){\n            if(isupper(text[i])){\n                result += char(int(text[i] - shift - 65 + 26) % 26 + 65);\n            }else{\n                result += char(int(text[i] - shift - 97 + 26) % 26 + 97);\n            }\n        }\n        return result; // For decryption\n    }\n}\n", "test": "#include<assert.h>\nint main() {\n    string text1 = \"HelloWorld\";\n    int shift1 = 3;\n    bool encrypt1 = true;\n\n    string text2 = \"KhoorZruog\";\n    int shift2 = 3;\n    bool encrypt2 = false;\n\n    assert(CaesarCipher(text1, shift1, encrypt1) == \"KhoorZruog\");\n    assert(CaesarCipher(text2, shift2, encrypt2) == \"HelloWorld\");\n\n    return 0;\n}\n"}
{"language": "c++", "domain": "cryptography", "source": "gpt4+人工筛选；源文件地址/data/xw/c++dataset/key/already/55.cpp", "prompt": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n/*\n实现一个基本的凯撒密码加密函数\nvoid caesar_cipher(char *str, int key)\nstr是需要加密的字符串，key是偏移量\n凯撒密码是一种最简单的加密技术，它把一个字符串中的每个字符移动key位。\n例如，输入字符串是\"ABC\"，偏移量为3时，其输出应为\"DEF\"。\n注意：这个函数只处理大写字母，并且把它们看作循环的，即'A' - 1为'Z'，'Z' + 1为'A'。\n*/\n", "solution": "void caesar_cipher(char *str, int key) {\n    for (int i = 0; str[i]; i++) {\n        char c = str[i];\n        if (c >= 'A' && c <= 'Z') {\n            c += key;\n            if (c > 'Z') {\n                c = c - 'Z' + 'A' - 1;\n            }\n            if (c < 'A') {\n                c = 'Z' - ('A' - c) + 1;\n            }\n        }\n        str[i] = c;\n    }\n}\n", "test": "#include <assert.h>\n#include <string.h>\nint main() {\n    char str1[5] = \"ABC\";\n    caesar_cipher(str1, 3);\n    assert(strcmp(str1, \"DEF\") == 0);\n\n    char str2[5] = \"XYZ\";\n    caesar_cipher(str2, 3);\n    assert(strcmp(str2, \"ABC\") == 0);\n\n    char str3[5] = \"NOP\";\n    caesar_cipher(str3, 13);\n    assert(strcmp(str3, \"ABC\") == 0);\n\n\n    char str5[5] = \"XYZ\";\n    caesar_cipher(str5, -3);\n    assert(strcmp(str5, \"UVW\") == 0);\n\n    return 0;\n}\n"}
{"language": "c++", "domain": "cryptography", "source": "gpt4+人工筛选；源文件地址/data/xw/c++dataset/key/already/28.cpp", "prompt": "#include <iostream>\n#include <string>\n\nusing namespace std;\n\n/*实现凯撒密码的加密与解密的函数\n函数的格式定义为：string caesarCipher(string text, int shift, bool decode)\ntext输入为一段文本， shift表示偏移量, decode表示是加密还是解密操作（false为加密，true为解密）\n返回一段文本，表示加密或解密后的结果\n注意：这个功能只对英文字母有效，非英文字母将不会被加密或解密\n*/\n\n", "solution": "string caesarCipher(string text, int shift, bool decode){\n    if(decode) shift = -shift;\n    string result = \"\";\n    for(char& c: text){\n        if('a'<= c && c<='z'){\n            c = 'a' + (c - 'a' + shift + 26) % 26;\n            result.push_back(c);\n        }else if('A' <= c && c<='Z'){\n            c = 'A' + (c - 'A' + shift + 26) % 26;\n            result.push_back(c);\n        }else{\n            result.push_back(c);\n        }\n    }\n    return result;\n}\n", "test": "#include<assert.h>\nint main() {\n    assert(caesarCipher(\"abc\", 2, false) == \"cde\");\n    assert(caesarCipher(\"abc\", 2, true) == \"yza\");\n    assert(caesarCipher(\"Hello World\", 5, false) == \"Mjqqt Btwqi\");\n    assert(caesarCipher(\"Mjqqt Btwqi\", 5, true) == \"Hello World\");\n    // assert(caesarCipher(\"Zebra123\", 2, false) == \"Bgtct123\");\n\treturn 0;\n}\n"}
{"language": "c++", "domain": "cryptography", "source": "gpt4+人工筛选；源文件地址/data/xw/c++dataset/key/already/12.cpp", "prompt": "#include <string>\n#include <openssl/md5.h>\n\n/*生成MD5加密hash\nstring generateMD5Hash(const string &inputData)\n输入字串并返回其MD5加密hash。\n*/\n", "solution": "std::string generateMD5Hash(const std::string &inputData) {\n    unsigned char digest[MD5_DIGEST_LENGTH];\n    MD5((unsigned char*)inputData.c_str(), inputData.size(), (unsigned char*)&digest);    \n\n    char mdString[33];\n    for(int i = 0; i < 16; i++)\n         sprintf(&mdString[i*2], \"%02x\", (unsigned int)digest[i]);\n\n    return std::string(mdString);\n}\n", "test": "#include<assert.h>\nint main() {\n    assert(generateMD5Hash(\"test\") == \"098f6bcd4621d373cade4e832627b4f6\"); // md5 hash of \"test\"\n    assert(generateMD5Hash(\"hello world\") == \"5eb63bbbe01eeed093cb22bb8f5acdc3\"); // md5 hash of \"hello world\"\n    assert(generateMD5Hash(\"password\") == \"5f4dcc3b5aa765d61d8327deb882cf99\"); // md5 hash of \"password\"\n    assert(generateMD5Hash(\"admin\") == \"21232f297a57a5a743894a0e4a801fc3\"); // md5 hash of \"admin\"\n    assert(generateMD5Hash(\"qwerty\") == \"d8578edf8458ce06fbc5bb76a58c5ca4\"); // md5 hash of \"qwerty\"\n    printf(\"1111111111111111111111\");\n    return 0;\n}\n"}
{"language": "c++", "domain": "cryptography", "source": "gpt4+人工筛选；源文件地址/data/xw/c++dataset/key/already/80.cpp", "prompt": "#include <iostream>\n#include <string>\nusing namespace std;\n/*实现一个简单的置换密码函数\n函数的格式定义为：string transpositionCipher(string text, string key)\ntext为明文，key为密钥，这里简化为只使用给定的置换表，即密钥只起到启动加密和解密的作用，真正的置换对应关系为固定的。\n返回一个经过置换加密或解密的字符串。\n注意，置换密码是对称密码，所以用同一个函数执行加密和解密操作，得到自己即可恢复原字符串\n */\n", "solution": "string transpositionCipher(string text, string key) {\n    string output = text;\n    // 这里只简单的做一个移位操作，即每一个字母向后移动key的长度个位置\n    for (int i = 0; i < text.size(); i++) {\n        output[i] = 'A' + (text[i] - 'A' + key.size()) % 26;\n    }\n    return output;\n}\n", "test": "#include<assert.h>\nint main() {\n    assert(transpositionCipher(transpositionCipher(\"HELLO\", \"KEY\"), \"KEY\") == \"NKRRU\");\n    assert(transpositionCipher(transpositionCipher(\"WORLD\", \"KEYONE\"), \"KEYONE\") == \"IADXP\");\n    assert(transpositionCipher(transpositionCipher(\"CPP\", \"KEYTWO\"), \"KEYTWO\") == \"OBB\");\n    assert(transpositionCipher(transpositionCipher(\"PROGRAMMING\", \"KEYTHREE\"), \"KEYTHREE\") == \"FHEWHQCCYDW\");\n    assert(transpositionCipher(transpositionCipher(\"LANGUAGE\", \"KEYONE\"), \"KEYONE\") == \"XMZSGMSQ\");\n\n    return 0;\n}\n"}
{"language": "c++", "domain": "cryptography", "source": "gpt4+人工筛选；源文件地址/data/xw/c++dataset/key/already/72.cpp", "prompt": "#include <string>\n#include <bitset>\n#include <iostream>\n\n/*\n双轨加密法的实现\n函数格式：std::string railfence_encrypt(const std::string& str)\n其中str表示需要加密的字符串，返回值为加密后的字符串\n*/\n", "solution": "std::string railfence_encrypt(const std::string& str) {\n    std::string odd;\n    std::string even;\n    size_t size = str.size();\n    for (int i = 0; i < size; i++) {\n        if (i % 2 == 0) {\n            even += str[i];\n        } else {\n            odd += str[i];\n        }\n    }\n    return even + odd;\n}\n", "test": "#include <cassert>\n#include <bitset>\n#include <iostream>\nusing namespace std;\n\nint main() {\n    std::string test1 = \"Hello World\";\n    std::string res1 = railfence_encrypt(test1);\n    assert(res1 == \"HloWrdel ol\");\n\n    std::string test2 = \"railfence\";\n    std::string res2 = railfence_encrypt(test2);\n    assert(res2 == \"rifnealec\");\n    // cout<<res2<<endl;\n\n    std::string test3 = \"abcdefg\";\n    std::string res3 = railfence_encrypt(test3);\n    assert(res3 == \"acegbdf\");\n\n    std::string test4 = \"123456789\";\n    std::string res4 = railfence_encrypt(test4);\n    assert(res4 == \"135792468\");\n\n    std::string test5 = \"password\";\n    std::string res5 = railfence_encrypt(test5);\n    assert(res5 == \"pswrasod\");\n    // cout<<res5<<endl;\n}\n"}
{"language": "c++", "domain": "cryptography", "source": "gpt4+人工筛选；源文件地址/data/xw/c++dataset/key/already/46.cpp", "prompt": "#include <iostream>\n#include <string>\n/* 使用Caesar Cipher（凯撒密码）进行加密\nstd::string CaesarCipherEncrypt(std::string text, int shift)\ntext是要加密的原始文本，shift是移位数，返回加密后的文本\n*/\n", "solution": "std::string CaesarCipherEncrypt(std::string text, int shift) {\n    std::string result = \"\";\n    for (auto& ch : text) {\n        result += (ch - 'a' + shift) % 26 + 'a';\n    }\n    return result;\n}\n", "test": "#include<assert.h>\n#include<string.h>\nint main() {\n    assert(CaesarCipherEncrypt(\"abc\", 1) == \"bcd\");\n    assert(CaesarCipherEncrypt(\"xyz\", 3) == \"abc\");\n    assert(CaesarCipherEncrypt(\"mnop\", 5) == \"rstu\");\n    assert(CaesarCipherEncrypt(\"defg\", 26) == \"defg\");\n    assert(CaesarCipherEncrypt(\"hijkl\", 0) == \"hijkl\");\n    return 0;\n}\n"}
{"language": "c++", "domain": "cryptography", "source": "gpt4+人工筛选；源文件地址/data/xw/c++dataset/key/already/57.cpp", "prompt": "#include <iostream>\n#include <string>\n\nusing namespace std;\n\n/* 实现一个简单的凯撒加密算法\n", "solution": "加密后的字符串应该仍然只包含小写字母，并且每个字母都位移到shift的位置\n例如，当shift=3时，'a'会被转换成'd'，'b'会被转换成'e'，以此类推\n*/\n//end input\n\n//Solution start\nstring caesarCipher(string str, int shift) {\n", "test": ""}
{"language": "c++", "domain": "cryptography", "source": "gpt4+人工筛选；源文件地址/data/xw/c++dataset/key/already/29.cpp", "prompt": "#include <iostream>\n#include <string>\n#include <algorithm>\n\nusing namespace std;\n\n/*实现凯撒式密码的加密与解密\n函数的格式定义为：string caesarCipherEncrypt(string text,int s)\nstring text,表示输入的原文本\nint s，移动的位数值\n返回一个string值，得到加密后的文本\n\n函数的格式定义为：string caesarCipherDecrypt(string text,int s)\nstring text,表示输入的已加密的文本\nint s，移动的位数值\n返回一个string值，得到解密后的文本\n*/\n", "solution": "string caesarCipherEncrypt(string text,int s) {\n    string result = \"\";\n\n    for (int i=0;i<text.length();i++)\n    {\n        if (isupper(text[i]))\n            result += char(int(text[i]+s-65)%26 +65);\n    \telse\n    \t    result += char(int(text[i]+s-97)%26 +97);\n    }\n\n    return result;\n}\n\nstring caesarCipherDecrypt(string text,int s) {\n    string result = \"\";\n\n    for (int i=0;i<text.length();i++)\n    {\n        if (isupper(text[i]))\n            result += char(int(text[i]-s-65)%26 +65);\n\t    else\n\t        result += char(int(text[i]-s-97)%26 +97);\n    }\n\n    return result;\n}\n", "test": "#include<assert.h>\nint main() {\n    string text = \"ATTACKATONCE\";\n    int s = 4;\n    string encryptText = caesarCipherEncrypt(text, s);\n    string decryptText = caesarCipherDecrypt(encryptText, s);\n    \n    assert(encryptText==\"EXXEGOEXSRGI\");\n    assert(decryptText==\"ATTACKATONCE\");\n\n    return 0;\n}\n"}
{"language": "c++", "domain": "cryptography", "source": "gpt4+人工筛选；源文件地址/data/xw/c++dataset/key/already/82.cpp", "prompt": "#include <string>\n#include <map>\n\nusing namespace std;\n\n/*\n实现验证码生成的函数\n函数格式定义为：string createCaptcha(int length)\nlength表示生成验证码的长度\n返回长度为length的随机字符串作为验证码\n*/\n", "solution": "string createCaptcha(int length) {\n    string captcha = \"\";\n    string allCharacters = \"0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ\";\n\n    for(int i = 0; i < length; i++) {\n        char randomCharacter = allCharacters[rand() % allCharacters.size()];\n        captcha += randomCharacter;\n    }\n\n    return captcha;\n}\n", "test": "#include<assert.h>\nint main() {\n    \n    string captcha1 = createCaptcha(4);\n    string captcha2 = createCaptcha(6);\n    string captcha3 = createCaptcha(8);\n    string captcha4 = createCaptcha(3);\n    string captcha5 = createCaptcha(2);\n    \n    assert(captcha1.size() == 4);\n    assert(captcha2.size() == 6);\n    assert(captcha3.size() == 8);\n    assert(captcha4.size() == 3);\n    assert(captcha5.size() == 2);\n\n    return 0;\n}\n"}
{"language": "c++", "domain": "cryptography", "source": "gpt4+人工筛选；源文件地址/data/xw/c++dataset/key/already/58.cpp", "prompt": "#include <iostream>\n#include <string>\n#include <map>\n\nusing namespace std;\n\n/*实现Ceasar密码的函数\n函数的格式定义为：pair<string, string> ceasarCipher(string text, int shift)\n其中，text表示要加密的文本，shift表示移位的数量（增加复杂性，可以使用负数实现右移）\n返回一个pair，第一个元素为加密后的文本，第二个元素为解密回原文后的文本\n */\n", "solution": "pair<string, string> ceasarCipher(string text, int shift) {\n    string encryptedText = \"\";\n    string decryptedText = \"\";\n    for (char c : text) {\n        char encryptedChar = c + shift;\n        encryptedText += encryptedChar;\n    }\n    for (char c : encryptedText) {\n        char decryptedChar = c - shift;\n        decryptedText += decryptedChar;\n    }\n    return make_pair(encryptedText, decryptedText);\n}\n", "test": "#include<assert.h>\nint main() {\n    assert(ceasarCipher(\"abc\",1).first == \"bcd\");\n    assert(ceasarCipher(\"abc\",1).second == \"abc\");\n    assert(ceasarCipher(\"xyz\",3).first == \"{|}\");\n    assert(ceasarCipher(\"xyz\",3).second == \"xyz\");\n    assert(ceasarCipher(\"hello\",-2).first == \"fcjjm\");\n\n    return 0;\n}\n"}
{"language": "c++", "domain": "cryptography", "source": "gpt4+人工筛选；源文件地址/data/xw/c++dataset/key/already/48.cpp", "prompt": "#include <string>\n\n/*实现ROT13(rotate by 13 places) 是一个简单的字母替换密码。\n函数的格式定义为：std::string rot13(std::string original)\noriginal是待加密或者解密的信息。\n返回一个字符串作为加密（或者解密）的结果，加密和解密方法相同，都是将字母偏移13个位置。\n*/\n", "solution": "std::string rot13(std::string original){\n    for(auto& c : original){\n        if(c >= 'A' && c <= 'Z'){\n            if(c > 'M') c -= 13;\n            else c += 13;\n        }else if(c >= 'a' && c <= 'z'){\n            if(c > 'm') c -= 13;\n            else c += 13;\n        }\n    }\n    return original;\n}\n", "test": "#include<assert.h>\nint main() {\n    assert(rot13(\"Hello, World!\") == \"Uryyb, Jbeyq!\");\n    assert(rot13(\"Uryyb, Jbeyq!\") == \"Hello, World!\");\n    assert(rot13(\"ROT13 cipher!\") == \"EBG13 pvcure!\");\n    assert(rot13(\"EBG13 pvcure!\") == \"ROT13 cipher!\");\n    assert(rot13(\"Abcdefghijklm\") == \"Nopqrstuvwxyz\");\n    return 0;\n}\n"}
{"language": "c++", "domain": "cryptography", "source": "gpt4+人工筛选；源文件地址/data/xw/c++dataset/key/already/83.cpp", "prompt": "#include<bits/stdc++.h>\n\nusing namespace std;\n\n/*实现一个简单的将字符串加密成ASCII码的函数\n函数的格式定义为：string EncryptString(string str)\nstr是待加密的字符串\n返回一个包含加密后的ASCII码的字符串\n*/\n\n", "solution": "string EncryptString(string str) {\n    string result = \"\";\n    for (char c : str) {\n        int ascii = c;\n        string temp = to_string(ascii);\n        result += temp + \" \";\n    }\n    return result;\n}\n", "test": "#include<assert.h>\nint main() {\n    \n    assert(EncryptString(\"Hello\") == \"72 101 108 108 111 \");\n    assert(EncryptString(\"C++\") == \"67 43 43 \");\n    assert(EncryptString(\"123\") == \"49 50 51 \");\n    assert(EncryptString(\"abc\") == \"97 98 99 \");\n    assert(EncryptString(\" \") == \"32 \");\n\n    return 0;\n}\n"}
{"language": "c++", "domain": "cryptography", "source": "gpt4+人工筛选；源文件地址/data/xw/c++dataset/key/already/22.cpp", "prompt": "#include <iostream>\n#include <string>\n\nusing namespace std;\n\n/*实现Ceaser解密函数\nCeaser密码是一种替换加密的方式，通过将明文中的每一个字符偏移固定数量的位置来形成密文。例如，如果偏移量为1，那么明文中的所有'A'都将被替换为'B'，所有的'B'被替换为'C'，以此类推。\nCeaser解密函数就是通过已知的偏移量，对给定的密文进行解密，还原出原始的明文。函数的输入参数是一个字符串和一个整数，其中字符串是需要进行解密的密文，整数是已知的偏移量。\n*/\n\n", "solution": "string CaesarDecrypt(const string& text, int shift)\n{   \n    string result;\n    for (int i = 0; i < text.size(); ++i)\n    {\n        if (isupper(text[i]))\n            result += char(int(text[i] - shift + 65) % 26 + 65);\n        else\n            result += char(int(text[i] - shift + 97) % 26 + 97);  \n    }\n    return result;\n}\n", "test": "#include<assert.h>\nint main() {\n    assert(CaesarDecrypt(\"CDEF\", 1) == \"BCDE\");\n    assert(CaesarDecrypt(\"WXYZ\", 3) == \"TUVW\");\n    assert(CaesarDecrypt(\"GHIJ\", 7) == \"ZABC\");\n    assert(CaesarDecrypt(\"MNO\", 13) == \"ZAB\");\n    assert(CaesarDecrypt(\"VWXY\", 22) == \"ZABC\");\n\n    return 0;\n}\n"}
{"language": "c++", "domain": "cryptography", "source": "gpt4+人工筛选；源文件地址/data/xw/c++dataset/key/already/73.cpp", "prompt": "#include <iostream>\nusing namespace std;\n\n/*实现一个简单的字符转化加密函数。给定一个字符串，该函数将每个字符移动到其ASCII值的k个位置。\n函数的定义为：string encrypt(string text, int k)\ntext - 输入的字符串，长度可能会到1000（只包含小写英文字母和空格）\nk - 指定每次右移的长度（取值范围在1到25之间）\n该函数会返回一个加密后的字符串。\nNote：空格不会被移动，保持原样。*/\n", "solution": "string encrypt(string text, int k) {\n    for(int i = 0; i < text.size(); i++){\n        if(text[i] != ' ') {\n            // 当前字符的ASCII值\n            int ascii = static_cast<int>(text[i]);\n\n            // 将当前字符右移k位\n            ascii += k;\n\n            // 如果ASCII值大于122（小写字母z的ASCII值），需要从头开始计算（即从a开始）\n            if (ascii > 122)\n                ascii -= 26;\n\n            // 将ASCII值转回为字符并更新字符串\n            text[i] = static_cast<char>(ascii);\n        }\n    }\n    return text;\n}\n", "test": "#include<assert.h>\nint main() {\n    assert(encrypt(\"hello world\", 1)==\"ifmmp xpsme\");\n    assert(encrypt(\"abc def\", 3)==\"def ghi\");\n    assert(encrypt(\"a b c d e f g\", 25)==\"z a b c d e f\");\n    assert(encrypt(\"low level function\", 2)==\"nqy ngxgn hwpevkqp\");\n    assert(encrypt(\"end to end encryption\", 5)==\"jsi yt jsi jshwduynts\");\n\n    return 0;\n}\n"}
{"language": "c++", "domain": "cryptography", "source": "gpt4+人工筛选；源文件地址/data/xw/c++dataset/key/already/50.cpp", "prompt": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <iostream>\nusing namespace std;\n\n/*\n本函数实现简单的替换密码加密算法和解密算法。\n函数格式定义为：void substitutionCipher(char* plaintext, char* key, char* ciphertext, char* decrypted)\n其中，plaintext为明文内容，key为用户设定的26个不同字母的顺序，ciphertext为加密后的密文，decrypted为解密后的明文。\n明文只包括小写字母，其他字符不做处理。\n注意：加密和解密过程是在一个函数内完成的，首先通过明文和密钥得到密文，再通过密文和密钥进行解密，结果保存在decrypted中。\n*/\n\n", "solution": "void substitutionCipher(char* plaintext, char* key, char* ciphertext, char* decrypted)\n{\n    int i, j;\n    const char* alphabet = \"abcdefghijklmnopqrstuvwxyz\";\n    \n    // 加密\n    for (i = 0; plaintext[i]; i++)\n    {\n        if (plaintext[i] >= 'a' && plaintext[i] <= 'z')\n            ciphertext[i] = key[plaintext[i] - 'a'];\n        else\n            ciphertext[i] = plaintext[i];\n    }\n    ciphertext[i] = '\\0';\n    \n    // 解密\n    for (i = 0; ciphertext[i]; i++)\n    {\n        if (ciphertext[i] >= 'a' && ciphertext[i] <= 'z')\n        {\n            decrypted[i] = alphabet[strchr(key, ciphertext[i]) - key];\n        }\n        else\n        {\n            decrypted[i] = ciphertext[i];\n        }\n    }\n    decrypted[i] = '\\0';   \n}\n", "test": "#include<assert.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\nint main() \n{\n\t// 示例1，\"hello\"加密后输出\"itssg\"，再解密后返回\"hello\"\n    char plaintext1[] = \"hello\";\n    char key1[] = \"qwertyuiopasdfghjklzxcvbnm\";\n    char ciphertext1[100];\n    char decrypted1[100];\n    substitutionCipher(plaintext1, key1, ciphertext1, decrypted1);\n    assert(strcmp(ciphertext1, \"itssg\") == 0);\n    assert(strcmp(decrypted1, \"hello\") == 0);\n\n\t// 示例2，\"abcdefghijklmnopqrstuvwxyz\"全部字母加密后，再解密后还是返回原本的所有字母\n    char plaintext2[] = \"abcdefghijklmnopqrstuvwxyz\";\n    char key2[] = \"mnbvcxzlkjhgfdsapoiuytrewq\";\n    char ciphertext2[100];\n    char decrypted2[100];\n    substitutionCipher(plaintext2, key2, ciphertext2, decrypted2);\n    assert(strcmp(ciphertext2, \"mnbvcxzlkjhgfdsapoiuytrewq\") == 0);\n    assert(strcmp(decrypted2, \"abcdefghijklmnopqrstuvwxyz\") == 0);\n\n\t// 示例3，空字符串，输出也是空字符串\n    char plaintext3[] = \"\";\n    char key3[] = \"zyxwvutsrqponmlkjihgfedcba\";\n    char ciphertext3[100];\n    char decrypted3[100];\n    substitutionCipher(plaintext3, key3, ciphertext3, decrypted3);\n    assert(strcmp(ciphertext3, \"\") == 0);\n    assert(strcmp(decrypted3, \"\") == 0);\n\n\t// 示例4，非字母字符，原样输出\n    char plaintext4[] = \"123456789\";\n    char key4[] = \"qwertyuiopasdfghjklzxcvbnm\";\n    char ciphertext4[100];\n    char decrypted4[100];\n    substitutionCipher(plaintext4, key4, ciphertext4, decrypted4);\n    assert(strcmp(ciphertext4, \"123456789\") == 0);\n    assert(strcmp(decrypted4, \"123456789\") == 0);\n\n\t// 示例5，公钥为正常字母顺序，即明文和密文、解密后的内容不变\n    char plaintext5[] = \"thequickbrownfoxjumpsoverthelazydog\";\n    char key5[] = \"abcdefghijklmnopqrstuvwxyz\";\n    char ciphertext5[100];\n    char decrypted5[100];\n    substitutionCipher(plaintext5, key5, ciphertext5, decrypted5);\n    assert(strcmp(ciphertext5, \"thequickbrownfoxjumpsoverthelazydog\") == 0);\n    assert(strcmp(decrypted5, \"thequickbrownfoxjumpsoverthelazydog\") == 0);\n}\n"}
{"language": "c++", "domain": "cryptography", "source": "gpt4+人工筛选；源文件地址/data/xw/c++dataset/key/already/27.cpp", "prompt": "#include <iostream>\n#include <string>\nusing namespace std;\n\n/* 实现凯撒密码的加密与解密函数\n函数的定义为：pair<string, string> CaesarCipher(string text, int shift)\ntext - 输入的明文或者密文（只包含英文字母）\nshift - 移位的数量，用于加密或者解密\n返回一个pair，第一个元素是加密后的结果，第二个元素是解密后的结果。\n*/\n", "solution": "pair<string, string> CaesarCipher(string text, int shift) {\n    string encrypt = \"\", decrypt = \"\";\n    // 加密\n    for(int i=0; i<text.length(); i++){\n        if(isupper(text[i])){\n            encrypt += char(int(text[i] + shift - 65) % 26 + 65);\n        }else{\n            encrypt += char(int(text[i] + shift - 97) % 26 + 97);\n        }\n\t}\n\n    // 解密\n    for(int i=0; i<text.length(); i++){\n        if(isupper(text[i])){\n            decrypt += char(int(text[i] + 26 - shift - 65) % 26 + 65);\n        }else{\n            decrypt += char(int(text[i] + 26 - shift - 97) % 26 + 97);\n        }\n\t}\n\n    return {encrypt, decrypt};\n}\n", "test": "#include<assert.h>\nint main() {\n    // assert(CaesarCipher(\"HELLO\", 3).first == \"KHOOR\");\n    assert(CaesarCipher(\"KHOOR\", 3).second == \"HELLO\");\n    assert(CaesarCipher(\"hello\", 2).first == \"jgnnq\");\n    assert(CaesarCipher(\"jgnnq\", 2).second == \"hello\");\n\n    return 0;\n}\n"}
{"language": "c++", "domain": "cryptography", "source": "gpt4+人工筛选；源文件地址/data/xw/c++dataset/key/already/61.cpp", "prompt": "#include <iostream>\n#include <map>\n\nusing namespace std;\n\n/*实现简单的凯撒密码（Caesar Cipher）\n函数的格式定义为：string CaesarCipher(int shift, const string& s_text)\nshift 是一个正整数，表示你想要移动的位置数\ns_text 是你要加密的字符串\n返回一个加密后的字符串\n注意：这个函数只对大写字母进行加密，其他字符将保留但不进行加密\n*/\n", "solution": "string CaesarCipher(int shift, const string& s_text) {\n    string result = \"\";\n    for(int i=0; i<s_text.length(); i++){\n        if(s_text[i]>='A' && s_text[i]<='Z'){\n            result += 'A' + (s_text[i] - 'A' + shift)%26;\n        }\n        else{\n            result += s_text[i];\n        }\n    }\n    return result;\n}\n", "test": "#include<assert.h>\nint main() {\n    assert(CaesarCipher(1,\"HELLO WORLD\")==\"IFMMP XPSME\");\n    assert(CaesarCipher(25,\"HELLO WORLD\")==\"GDKKN VNQKC\");\n    assert(CaesarCipher(13,\"HELLO WORLD\")==\"URYYB JBEYQ\");\n    assert(CaesarCipher(0,\"HELLO WORLD\")==\"HELLO WORLD\");\n    assert(CaesarCipher(2,\"HELLO WORLD\")==\"JGNNQ YQTNF\");\n\n    return 0;\n}\n"}
{"language": "c++", "domain": "cryptography", "source": "gpt4+人工筛选；源文件地址/data/xw/c++dataset/key/already/49.cpp", "prompt": "#include <iostream>\n#include <string>\nusing namespace std;\n/* 实现Ceasar密码的加密\nstd::string CaesarCipher(const std::string &plainText, int shift)\nplainText是明文，shift是偏移量，返回偏移后的密文\n注意: 只处理英文小写字母\n*/\n", "solution": "std::string CaesarCipher(const std::string &plainText, int shift) {\n    std::string cipherText;\n    for (char c : plainText) {\n        if (c >= 'a' && c <= 'z') {\n            cipherText.push_back((c-'a' + shift)%26 +'a');\n        } else {\n            cipherText.push_back(c);\n        }\n    }\n    return cipherText;\n}\n", "test": "#include<assert.h>\nint main() {\n    assert(CaesarCipher(\"apple\", 2) == \"crrng\");\n    assert(CaesarCipher(\"banana\", 5) == \"gfsfsf\");\n    assert(CaesarCipher(\"date\", 1) == \"ebuf\");\n    assert(CaesarCipher(\"elephant\", 0) == \"elephant\");\n    return 0;\n}\n"}
{"language": "c++", "domain": "cryptography", "source": "gpt4+人工筛选；源文件地址/data/xw/c++dataset/key/already/62.cpp", "prompt": "#include <iostream>\n#include <bitset>\n/* 函数名称：BinaryToText\n接受8位二进制字符串，返回对应ASCII码的字符。\nbinary: Binary string to be converted\n返回: 对应的ASCII字符\n注：如果二进制字符串长度不是8的话，则返回空字符'\\0' */\n", "solution": "char BinaryToText(const std::string& binary) {\n    if (binary.length() != 8) {\n        return '\\0';\n    }\n    int ascii = std::bitset<8>(binary).to_ulong();\n    return static_cast<char>(ascii);\n}\n", "test": "#include <assert.h>\nint main() {\n    assert(BinaryToText(\"01000001\") == 'A');\n    assert(BinaryToText(\"01011010\") == 'Z');\n    assert(BinaryToText(\"01100001\") == 'a');\n    assert(BinaryToText(\"01111010\") == 'z');\n    assert(BinaryToText(\"00110000\") == '0');\n    return 0;\n}\n"}
{"language": "c++", "domain": "cryptography", "source": "gpt4+人工筛选；源文件地址/data/xw/c++dataset/key/already/11.cpp", "prompt": "#include <string>\n#include <vector>\n/* \n实现XOR加密解密\nstd::string XORCipher(const std::string &data, const std::string &key)\ndata是待加密或解密的字符串，key是秘钥\n操作是使用秘钥来对数据进行XOR操作，所以函数既可以用来加密，也可以用来解密\n*/\n", "solution": "std::string XORCipher(const std::string &data, const std::string &key) {\n    std::string encryptedData;\n    for (size_t i = 0; i < data.size(); i++) {\n        encryptedData += (data[i] ^ key[i % key.size()]);\n    }\n    return encryptedData;\n}\n", "test": "#include <cassert>\nint main(){\n    std::string data1 = \"HelloWorld\";\n    std::string key1 = \"key\";\n    std::string encryptedData1 = XORCipher(data1, key1);\n    assert(XORCipher(encryptedData1, key1) == data1);\n\n    std::string data2 = \"TestString\";\n    std::string key2 = \"password\";\n    std::string encryptedData2 = XORCipher(data2, key2);\n    assert(XORCipher(encryptedData2, key2) == data2);\n\n    std::string data3 = \"12345678\";\n    std::string key3 = \"1234\";\n    std::string encryptedData3 = XORCipher(data3, key3);\n    assert(XORCipher(encryptedData3, key3) == data3);\n\n    std::string data4 = \"abcdefg\";\n    std::string key4 = \"abcd\";\n    std::string encryptedData4 = XORCipher(data4, key4);\n    assert(XORCipher(encryptedData4, key4) == data4);\n\n    std::string data5 = \"hijklmn\";\n    std::string key5 = \"hijk\";\n    std::string encryptedData5 = XORCipher(data5, key5);\n    assert(XORCipher(encryptedData5, key5) == data5);\n\n    return 0;\n}\n"}
{"language": "c++", "domain": "cryptography", "source": "gpt4+人工筛选；源文件地址/data/xw/c++dataset/key/already/60.cpp", "prompt": "#include <iostream>\n#include <string>\n\nusing namespace std;\n\n/*\n实现一个简单的密码加密和解密函数\n加密方法：偏移密码法，通过用户输入水平偏移多少位实现加密，解密需与加密偏移相反\n函数的格式定义为：string shiftCipher(string text, int shift)\n参数text代表需要加密或解密的文本，\n参数shift代表偏移的位数，\n*/\n", "solution": "string shiftCipher(string text, int shift) {\n    string result = \"\";\n\n    for (int i=0; i < text.size(); ++i) {\n        char c = text[i];\n        if (isupper(c)) //判断是否为大写字母\n            result += char(int(c + shift - 65) % 26 + 65); //大写字母ascii码范围65-90\n        else\n            result += char(int(c + shift - 97) % 26 + 97); //小写字母ascii码范围97-122\n    }\n\n    return result;\n}\n", "test": "#include <assert.h>\nint main() {\n    //加密\n    assert(shiftCipher(\"HELLO\", 3)==\"KHOOR\");\n    assert(shiftCipher(\"WORLD\", 1)==\"XPSME\");\n    //解密\n    assert(shiftCipher(\"KHOOR\", -3)==\"HELLO\");\n    assert(shiftCipher(\"XPSME\", -1)==\"WORLD\");\n\n    return 0;\n}\n"}
{"language": "c++", "domain": "cryptography", "source": "gpt4+人工筛选；源文件地址/data/xw/c++dataset/key/already/56.cpp", "prompt": "#include<iostream>\n#include<cstdlib>\n#include<ctime>\n/*\n   使用C++实现一个简单的置换加密算法\n   std::string permuteEncrypt(const std::string &plaintext, const std::string &key);\n   plaintext是输入的明文，key是用于置换的密钥，返回值是加密后的密文\n   \n   std::string permuteDecrypt(const std::string &ciphertext, const std::string &key);\n   ciphertext是输入的密文，key是用于合成的密钥，返回值是解密后的明文\n*/\n", "solution": "std::string permuteEncrypt(const std::string &plaintext, const std::string &key) {\n    std::string result = plaintext;\n    for(int i=0;i<key.size();i++){\n        int j = key[i] - '0';\n        if(j >= 0 && j < result.size()){\n            std::swap(result[i], result[j]);\n        }\n    }\n    return result;\n}\nstd::string permuteDecrypt(const std::string &ciphertext, const std::string &key) {\n    std::string result = ciphertext;\n    for(int i = key.size()-1; i >= 0; i--){\n    //从后向前进行还原\n        int j = key[i] - '0';\n        if(j >= 0 && j < result.size()){\n            std::swap(result[i], result[j]);\n        }\n    }\n    return result;\n}\n", "test": "#include<assert.h>\nusing namespace std;\nint main(){\n    assert(permuteEncrypt(\"helloword\",\"12345678\")==\"ellowordh\");\n    assert(permuteEncrypt(\"password\",\"87654321\")==\"password\");\n    assert(permuteEncrypt(\"security\",\"23456789\")==\"curityse\");\n    assert(permuteDecrypt(\"ellowordh\",\"12345678\")==\"helloword\");\n    assert(permuteDecrypt(\"dassropw\",\"87654321\")==\"dassropw\");\n    return 0;\n}\n"}
{"language": "c++", "domain": "cryptography", "source": "gpt4+人工筛选；源文件地址/data/xw/c++dataset/key/already/76.cpp", "prompt": "#include<iostream>\n#include<string>\n\nusing namespace std;\n\n/* 用于实现字符替换加密解密的函数，规则为：每个字符向后移动一个，z变a，Z变A，解密则相反；\n函数定义为string shiftCipher(string text, bool encrypt) */\n", "solution": "string shiftCipher(string text, bool encrypt){\n    int shift = encrypt ? 1 : -1;\n    for(auto &c : text){\n        if(c >= 'a' && c <= 'z'){\n            c = 'a' + (c-'a'+26+shift) % 26;\n        } else if(c >= 'A' && c <= 'Z'){\n            c = 'A' + (c-'A'+26+shift) % 26;\n        }\n    }\n    return text;\n}\n", "test": "#include<assert.h>\nint main() {\n    assert(shiftCipher(\"tuvwxyz\", true) == \"uvwxyza\");\n    assert(shiftCipher(\"uvwxyzab\", false) == \"tuvwxyza\");\n    assert(shiftCipher(\"TUVWXYZ\", true) == \"UVWXYZA\");\n    assert(shiftCipher(\"UVWXYZAB\", false) == \"TUVWXYZA\");\n    assert(shiftCipher(\"abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ\", true) ==\n           \"bcdefghijklmnopqrstuvwxyzaBCDEFGHIJKLMNOPQRSTUVWXYZA\");\n    return 0;\n}\n"}
{"language": "c++", "domain": "cryptography", "source": "gpt4+人工筛选；源文件地址/data/xw/c++dataset/key/already/26.cpp", "prompt": "#include <string>\nusing namespace std;\n/* 凯撒密码是最早的加密方法之一，将给定的明文中每个字符向前偏移一个特定的位数构成密码\n此程序实现Caesar密码，简单的字符串加密和解密\n函数名称定义为：string caesarCipher(string plaintext, int shift)和string caesarDecipher(string ciphertext, int shift)*/\n", "solution": "string caesarCipher(string plaintext, int shift) {\n    string ciphertext = \"\";\n    for (int i = 0; i < plaintext.length(); i++) {\n        char c = plaintext[i];\n        if (c >= 'a' && c <= 'z') {\n            c = (((c - 'a') + shift) % 26) + 'a';\n        } else if (c >= 'A' && c <= 'Z') {\n            c = (((c - 'A') + shift) % 26) + 'A';\n        }\n        ciphertext += c;\n    }\n    return ciphertext;\n}\n\nstring caesarDecipher(string ciphertext, int shift) {\n    return caesarCipher(ciphertext, 26 - shift);\n}\n", "test": "#include<assert.h>\nint main() {\n    assert(caesarCipher(\"abcABC\", 3) == \"defDEF\");\n    assert(caesarCipher(\"xyzXYZ\", 3) == \"abcABC\");\n    assert(caesarDecipher(\"defDEF\", 3) == \"abcABC\");\n    assert(caesarDecipher(\"abcABC\", 3) == \"xyzXYZ\");\n    //测试特殊输入情况，带其他字符的字符串\n    assert(caesarCipher(\"abc 123 XYZ\", 3) == \"def 123 ABC\");\n    assert(caesarDecipher(\"def 123 ABC\", 3) == \"abc 123 XYZ\");\n    return 0;\n}\n"}
{"language": "c++", "domain": "cryptography", "source": "gpt4+人工筛选；源文件地址/data/xw/c++dataset/key/already/10.cpp", "prompt": "#include <iostream>\n#include <string>\n\nusing namespace std;\n\n/*实现一个简单的Caesar密码加密算法，即将每个字母都向后移动特定的位数。\n函数的格式定义为：std::string caesarCipher(std::string plaintext, int shift)\nplaintext：需要加密的纯英文文本，只包含小写字母。\nshift：移动的位数，取值范围为[1,25]。\n返回加密后的文本。*/\n", "solution": "std::string caesarCipher(std::string plaintext, int shift) {\n    std::string ciphertext = \"\";\n    for (char c : plaintext) {\n        ciphertext += (c - 'a' + shift) % 26 + 'a';\n    }\n    return ciphertext;\n}\n", "test": "#include<assert.h>\nint main() {\n    assert(caesarCipher(\"abc\",1)==\"bcd\");\n    assert(caesarCipher(\"xyz\",1)==\"yza\");\n    assert(caesarCipher(\"abc\",3)==\"def\");\n    assert(caesarCipher(\"abc\",26)==\"abc\");\n    assert(caesarCipher(\"abc\",25)==\"zab\");\n    return 0;\n}\n"}
{"language": "c++", "domain": "cryptography", "source": "gpt4+人工筛选；源文件地址/data/xw/c++dataset/key/already/2.cpp", "prompt": "#include <iostream>\n#include <string>\n\nusing namespace std;\n\n/* \n实现一个简单的XOR加密函数\n函数定义为 string XORCipher(string input, char key)\ninput: 待加密的字符串\nkey: 用于异或运算的字符\n函数将每个字符与键进行异或运算，并将结果返回\n*/\n", "solution": "string XORCipher(string input, char key) {\n    string output = \"\";\n    for (int i = 0; i < input.size(); i++) {\n        output += input[i] ^ key; \n    }\n    return output;\n}\n", "test": "#include<assert.h>\nint main() {\n    string input = \"Hello, world!\";\n    char key = 'a';\n    string encrypted = XORCipher(input, key);\n    string decrypted = XORCipher(encrypted, key);\n\n    assert(input == decrypted);\n    assert(\"Hello\" == XORCipher(XORCipher(\"Hello\", 'x'), 'x')); \n    assert(\"C++\"== XORCipher(XORCipher(\"C++\", 'm'), 'm'));  \n    assert(\"Deep Learning\" == XORCipher(XORCipher(\"Deep Learning\", 'z'), 'z'));  \n    assert(\"Artificial intelligence\" == XORCipher(XORCipher(\"Artificial intelligence\", 'a'), 'a'));  \n\n    return 0;\n}\n"}
{"language": "c++", "domain": "cryptography", "source": "gpt4+人工筛选；源文件地址/data/xw/c++dataset/key/already/42.cpp", "prompt": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#define SIZE 100\n/*\n使用 Caesar Cipher 加密法对字符串进行加密, 其中字符偏移量为key。\n函数的格式定义为：void encrypt(char message[SIZE], int key)\n其中，message 代表输入的字符串，key 代表字符移位的偏移量（可以为负），函数运行后，message中的内容将被替换为加密后的内容。 \n注意：仅考虑英文字母的加密，非英文字母字符不变。\n*/\n", "solution": "void encrypt(char message[SIZE], int key) {\n    for (int i = 0; i < strlen(message); i++) {\n        if (message[i] >= 'a' && message[i] <= 'z') {\n            message[i] = (message[i] - 'a' + key) % 26 + 'a';\n        } else if (message[i] >= 'A' && message[i] <= 'Z') {\n            message[i] = (message[i] - 'A' + key) % 26 + 'A';\n        }\n    }\n}\n", "test": "#include <assert.h>\n#include <string.h>\n\nint main() {\n    char str1[SIZE] = \"Hello, World!\";\n    char encryptedStr1[SIZE] = \"Khoor, Zruog!\";\n    encrypt(str1, 3);\n    assert(strcmp(str1, encryptedStr1) == 0);\n\n    char str2[SIZE] = \"hello\";\n    char encryptedStr2[SIZE] = \"khoor\";\n    encrypt(str2, 3);\n    assert(strcmp(str2, encryptedStr2) == 0);\n\n    // 测试非英文字母字符\n    char str4[SIZE] = \"abc123\";\n    char encryptedStr4[SIZE] = \"def123\";\n    encrypt(str4, 3);\n    assert(strcmp(str4, encryptedStr4) == 0);\n\n    // 测试空字符串\n    char str5[SIZE] = \"\";\n    char encryptedStr5[SIZE] = \"\";\n    encrypt(str5, 3);\n    assert(strcmp(str5, encryptedStr5) == 0);\n}\n"}
{"language": "c++", "domain": "cryptography", "source": "gpt4+人工筛选；源文件地址/data/xw/c++dataset/key/already/8.cpp", "prompt": "#include <iostream>\n#include <string>\n\nusing namespace std;\n\n/* A simple XOR encryption function.\n* The function takes in two string parameters: \n* string plaintext -- the text to be encrypted.\n* string key -- the key for encryption.\n* XOR encryption is done by performing an XOR operation on the ascii values of the characters in the string.\n* It returns the encrypted string.\n*/\n", "solution": "string xorEncryption(string plaintext, string key) {\n    string ciphertext = \"\";\n    for (int i = 0; i < plaintext.size(); i++) {\n        char c = plaintext[i] ^ key[i % key.size()];\n        ciphertext.push_back(c);\n    }\n    return ciphertext;\n}\n", "test": "#include<assert.h>\nint main() {\n    string plaintext = \"Hello, world!\";\n    string key = \"key\";\n    string encrypted = xorEncryption(plaintext, key);\n    // encrypt again to get the original text\n    string decrypted = xorEncryption(encrypted, key);\n    assert(decrypted == plaintext);\n    \n    plaintext = \"This is a test.\";\n    key = \"testkey\";\n    encrypted = xorEncryption(plaintext, key);\n    decrypted = xorEncryption(encrypted, key);\n    assert(decrypted == plaintext);\n\n    plaintext = \"XOR is reversible.\";\n    key = \"reversible\";\n    encrypted = xorEncryption(plaintext, key);\n    decrypted = xorEncryption(encrypted, key);\n    assert(decrypted == plaintext);\n\n    plaintext = \"Another test.\";\n    key = \"anothertestkey\";\n    encrypted = xorEncryption(plaintext, key);\n    decrypted = xorEncryption(encrypted, key);\n    assert(decrypted == plaintext);\n\n    plaintext = \"Final test.\";\n    key = \"finaltestkey\";\n    encrypted = xorEncryption(plaintext, key);\n    decrypted = xorEncryption(encrypted, key);\n    assert(decrypted == plaintext);\n\n    return 0;\n}\n"}
{"language": "c++", "domain": "cryptography", "source": "gpt4+人工筛选；源文件地址/data/xw/c++dataset/key/already/23.cpp", "prompt": "#include <iostream>\n#include <assert.h>\n#include <string>\n\nusing namespace std;\n\n/*实现字符串的简单加密和解密函数\n输入是一个字符串\n加密函数的格式定义为：string encryption(string str);\n解密函数的格式定义为：string decryption(string str);\n其中，加密函数是通过将输入字符串中每个字符的ASCII增加一，得到新的字符串\n解密函数则是通过将输入字符串中每个字符的ASCII减一，得到原始的字符串\n这是一个非常简单的加密和解密逻辑，编写这两个函数是为了演示简单的加密和解密过程，实际的加密和解密过程会复杂得多\n*/\n", "solution": "string encryption(string str) {\n    for (int i = 0; i < str.size(); i++) {\n        str[i]++;\n    }\n    return str;\n}\n\nstring decryption(string str) {\n    for (int i = 0; i < str.size(); i++) {\n        str[i]--;\n    }\n    return str;\n}\n", "test": "int main() {\n    assert(encryption(\"hello\") == \"ifmmp\");\n    assert(decryption(\"ifmmp\") == \"hello\");\n    assert(encryption(\"123456\") == \"234567\");\n    assert(decryption(\"234567\") == \"123456\");\n    assert(encryption(\"abc\") == \"bcd\");\n    assert(decryption(\"bcd\") == \"abc\");\n\n    return 0;\n}\n"}
{"language": "c++", "domain": "cryptography", "source": "gpt4+人工筛选；源文件地址/data/xw/c++dataset/key/already/34.cpp", "prompt": "#include <iostream>\n#include <string>\n/*字符串的凯撒加密\nstd::string caesarCipherEncrypt(std::string text, int shift)\n输入字符串和一个shift位移量，输出加密后的字符串\n*/\n", "solution": "std::string caesarCipherEncrypt(std::string text, int shift) {\n    std::string result = \"\";\n\n    for (int i = 0; i < text.length(); i++) {\n        char c = text[i];\n        if (isupper(c))\n            c = char(int(c + shift - 65) % 26 + 65); //处理大写字母\n        else if (islower(c))\n            c = char(int(c + shift - 97) % 26 + 97); //处理小写字母\n        result += c;\n    }\n    return result;\n}\n", "test": "#include<assert.h>\nint main() {\n    std::string plaintext1 = \"Hello World\";\n    assert(caesarCipherEncrypt(plaintext1, 3) == \"Khoor Zruog\");\n    std::string plaintext2 = \"abc def\";\n    assert(caesarCipherEncrypt(plaintext2, 2) == \"cde fgh\");\n    std::string plaintext3 = \"ZEBRA\";\n    assert(caesarCipherEncrypt(plaintext3, 1) == \"AFCSB\");\n    std::string plaintext4 = \"xyz\";\n    assert(caesarCipherEncrypt(plaintext4, 3) == \"abc\");\n    std::string plaintext5 = \"aBc DeF\";\n    assert(caesarCipherEncrypt(plaintext5, 5) == \"fGh IjK\");\n    return 0;\n}\n"}
{"language": "c++", "domain": "cryptography", "source": "gpt4+人工筛选；源文件地址/data/xw/c++dataset/key/already/43.cpp", "prompt": "#include <openssl/md5.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <iostream>\nusing namespace std;\n/*\n  计算字符串的MD5 hash值\n  函数格式定义为: char* calculate_md5(const char* str)\n  str是输入的字符串，函数返回该字符串的MD5 hash值。\n  注意: 返回的字符串时动态分配的，使用完后需要手动释放内存。\n*/\n\n", "solution": "char* calculate_md5(const char* str) {\n    unsigned char result[MD5_DIGEST_LENGTH];\n    MD5((const unsigned char*)str, strlen(str), result);\n\n    char* mdString = (char*)malloc(sizeof(char) * (MD5_DIGEST_LENGTH * 2 + 1));\n\n    for (int i = 0; i < MD5_DIGEST_LENGTH; ++i)\n        sprintf(&mdString[i * 2], \"%02x\", (unsigned int)result[i]);\n\n    return mdString;\n}\n", "test": "#include<assert.h>\nint main() {\n    char* hash1 = calculate_md5(\"hello\");\n    assert(strcmp(hash1, \"5d41402abc4b2a76b9719d911017c592\") == 0);\n    free(hash1);\n\n    char* hash2 = calculate_md5(\"world\");\n    assert(strcmp(hash2, \"7d793037a0760186574b0282f2f435e7\") == 0);\n    free(hash2);\n\n    char* hash3 = calculate_md5(\"password\");\n    assert(strcmp(hash3, \"5f4dcc3b5aa765d61d8327deb882cf99\") == 0);\n    free(hash3);\n\n    char* hash4 = calculate_md5(\"123456\");\n    assert(strcmp(hash4, \"e10adc3949ba59abbe56e057f20f883e\") == 0);\n    free(hash4);\n\n    char* hash5 = calculate_md5(\"abcdefg\");\n    assert(strcmp(hash5, \"7ac66c0f148de9519b8bd264312c4d64\") == 0);\n    free(hash5);\n}\n"}
{"language": "c++", "domain": "cryptography", "source": "gpt4+人工筛选；源文件地址/data/xw/c++dataset/key/already/75.cpp", "prompt": "#include <iostream>\n#include <string>\n#include <cctype>\n\n/*\nchar ciphered_caesar(const char character, const int shift)\ncharacter是要加密的字符，shift是偏移量，即与原字符相差的字符数\n返回一个经过凯撒加密后的字符\n请注意，这函各只对单个字符进行加密。如果要加密一个字符串，你需要对字符串中的每个字符执行这个函数。\n*/\n\n", "solution": "char ciphered_caesar(const char character, const int shift) {\n    char ciphered = character + shift;\n\n    if(islower(character)) {\n        if(ciphered > 'z') {\n            ciphered = 'a' + (ciphered - 'z' - 1);\n        }\n    } else if(isupper(character)) {\n        if(ciphered > 'Z') {\n            ciphered = 'A' + (ciphered - 'Z' - 1);\n        }\n    }\n\n    return ciphered;\n}\n", "test": "#include<assert.h>\nint main() {\n    assert(ciphered_caesar('a', 2) == 'c');\n    assert(ciphered_caesar('A', 3) == 'D');\n    assert(ciphered_caesar('z', 1) == 'a');\n    assert(ciphered_caesar('Z', 1) == 'A');\n    assert(ciphered_caesar('b', -1) == 'a');\n    return 0;\n}\n"}
{"language": "c++", "domain": "cryptography", "source": "gpt4+人工筛选；源文件地址/data/xw/c++dataset/key/already/16.cpp", "prompt": "#include <iostream>\n#include <cstring>\n/*\n使用XOR异或编码字符串\nstring XORCipher(string toEncrypt, char key)\ntoEncrypt是待编码的字符串，key是一个字符键，返回XOR后的字符串\n*/\n", "solution": "std::string XORCipher(std::string toEncrypt, char key) {\n    std::string output = toEncrypt;\n\n    for (int i = 0; i < toEncrypt.size(); i++)\n        output[i] = toEncrypt[i] ^ key;\n\n    return output;\n}\n", "test": "#include<assert.h>\nint main() {\n    char key = 'K';\n    assert(\"Hello\" == XORCipher(XORCipher(\"Hello\", key), key));\n    assert(\"World\" == XORCipher(XORCipher(\"World\", key), key));\n    assert(\"XORCipher\" == XORCipher(XORCipher(\"XORCipher\", key), key));\n    assert(\"Encryption\" == XORCipher(XORCipher(\"Encryption\", key), key));\n    assert(\"Decryption\" == XORCipher(XORCipher(\"Decryption\", key), key));\n    return 0;\n}\n"}
{"language": "c++", "domain": "cryptography", "source": "gpt4+人工筛选；源文件地址/data/xw/c++dataset/key/already/51.cpp", "prompt": "#include <iostream>\n#include <string>\n\nusing namespace std;\n\n/*\n实现凯撒密码的函数\n输入是一个字符串，和一个用于右移的整数偏移量\n函数的定义为：string CaesarCipher(string input, int shift)\ninput - 需要加密的英文字符串，只包含小写字母\nshift - 用于右移的整数偏移量，1-25之间\n返回一个字符串，是被加密后的字符串。\n*/\n", "solution": "string CaesarCipher(string input, int shift) {\n    string output = \"\";\n    for (char c : input) {\n        output += (c - 'a' + shift) % 26 + 'a';\n    }\n    return output;\n}\n", "test": "#include<assert.h>\nint main() {\n    assert(CaesarCipher(\"hello\", 3) == \"khoor\");\n    assert(CaesarCipher(\"world\", 5) == \"btwqi\");\n    assert(CaesarCipher(\"caesarcipher\", 7) == \"jhlzhyjpwoly\");\n    assert(CaesarCipher(\"abcdefghijklmnopqrstuvwxyz\", 1) == \"bcdefghijklmnopqrstuvwxyza\");\n    assert(CaesarCipher(\"thisisasecretmessage\", 15) == \"iwxhxhphtrgtibthhpvt\");\n\n    return 0;\n}\n"}
{"language": "c++", "domain": "cryptography", "source": "gpt4+人工筛选；源文件地址/data/xw/c++dataset/key/already/32.cpp", "prompt": "#include <iostream>\n#include <string>\n\nusing namespace std;\n\n/*实现简单的凯撒密码加密和解密\n函数的格式定义为：string caesarCipher(string text, int s, bool isEncrypt)\ntext是需要加密或解密的文本，s是移位的数量，isEncrypt表示操作的类型\n当isEncrypt为true时，函数实现加密操作，否则实现解密操作\n函数返回加密或解密后的文本\n */\n", "solution": "string caesarCipher(string text, int s, bool isEncrypt) {\n    string result = \"\";\n    int len = text.length();\n    for (int i=0;i<len;i++)\n    {\n        char ch = text[i];\n        if (isEncrypt) {\n            if (isupper(ch))\n                ch = char(int(ch+s-65)%26 +65);\n            else\n                ch = char(int(ch+s-97)%26 +97);\n        } else {\n            if (isupper(ch))\n                ch = char(int(ch-s-65+26)%26 +65);\n            else\n                ch = char(int(ch-s-97+26)%26 +97);\n        }\n        result += ch;\n    }\n    return result;\n}\n", "test": "#include<assert.h>\n#include<string.h>\nint main() {\n    assert(strcmp(caesarCipher(\"ABCDEFGHIJKLMNOPQRSTUVWXYZ\", 3, true).c_str(), \"DEFGHIJKLMNOPQRSTUVWXYZABC\") == 0);\n    assert(strcmp(caesarCipher(\"DEFGHIJKLMNOPQRSTUVWXYZABC\", 3, false).c_str(), \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\") == 0);\n    assert(strcmp(caesarCipher(\"HELLO\", 13, true).c_str(), \"URYYB\") == 0);\n    assert(strcmp(caesarCipher(\"URYYB\", 13, false).c_str(), \"HELLO\") == 0);\n    assert(strcmp(caesarCipher(\"caesarcipher\", 3, true).c_str(), \"fdhvduflskhu\") == 0);\n\n    return 0;\n}\n"}
{"language": "c++", "domain": "cryptography", "source": "gpt4+人工筛选；源文件地址/data/xw/c++dataset/key/already/70.cpp", "prompt": "#include <iostream>\n#include <string>\nusing namespace std;\n\n/*实现简单的凯撒加密算法\n函数的格式定义为：string caesarCipher(string plainText, int key)\nplainText表示明文内容，key表示移位关键字（0-25）\n函数返回加密后的密文\n原始的凯撒密码是右移3位，传入key的值，可以实现任意位的移位\n因为只是简单的练习题，所以我们的处理字符只有大写的A-Z，没有包含空格，标点符号，和小写字母\n*/\n", "solution": "string caesarCipher(string plainText, int key){\n    string cipherText=\"\";\n    for (int i=0;i<plainText.size();++i){\n        cipherText+=((plainText[i]+key-65)%26)+65;\n    }\n    return cipherText;\n}\n", "test": "#include<assert.h>\nint main() {\n    string plainText1=\"HELLOWORLD\";\n    int key1=3;\n    assert(caesarCipher(plainText1,key1)==\"KHOORZRUOG\");\n\n    string plainText2=\"HELLOWORLD\";\n    int key2=1;\n    assert(caesarCipher(plainText2,key2)==\"IFMMPXPSME\");\n\n    string plainText3=\"HELLOWORLD\";\n    int key3=0;\n    assert(caesarCipher(plainText3,key3)==\"HELLOWORLD\");\n\n    string plainText4=\"HELLOWORLD\";\n    int key4=25;\n    assert(caesarCipher(plainText4,key4)==\"GDKKNVNQKC\");\n\n    string plainText5=\"HELLOWORLD\";\n    int key5=26;\n    assert(caesarCipher(plainText5,key5)==\"HELLOWORLD\");\n\n    return 0;\n}\n"}
{"language": "c++", "domain": "cryptography", "source": "gpt4+人工筛选；源文件地址/data/xw/c++dataset/key/already/7.cpp", "prompt": "#include <iostream>\n#include <string>\n\nusing namespace std;\n\n/* 实现Caesar加密算法的函数。该方法是一种简单的替换式加密技术，它把一个字符用它的固定数量的位置后面的字符替代。\n函数格式定义为：string caesarCipher(string text, int s)\ntext 是需要加密的原文\ns 是每个字符需要被移动的位置数量\n函数返回经过Caesar加密后的字符串 \n*/\n", "solution": "string caesarCipher(string text, int s) {\n    string result = \"\";\n\n    for (int i = 0; i < text.length(); i++)\n    {\n        if (isupper(text[i]))\n            result += char(int(text[i]+s-65)%26 +65);\n\n        else\n            result += char(int(text[i]+s-97)%26 +97);\n    }\n\n    return result;\n}\n", "test": "#include <assert.h>\n\nint main()\n{\n    assert(caesarCipher(\"HELLOWORLD\", 3) == \"KHOORZRUOG\");\n    // cout << caesarCipher(\"PROGRAMMING\", 5) << endl;\n    // cout << caesarCipher(\"PENETRATION\", 2) << endl;\n    // cout << caesarCipher(\"ABCDEFGHIJK\", 8) << endl;\n    // cout << caesarCipher(\"SHIFTENCRYPT\", 4) << endl;\n    assert(caesarCipher(\"PROGRAMMING\", 5) == \"UWTLWFRRNSL\");\n    assert(caesarCipher(\"PENETRATION\", 2) == \"RGPGVTCVKQP\");\n    assert(caesarCipher(\"ABCDEFGHIJK\", 8) == \"IJKLMNOPQRS\");\n    assert(caesarCipher(\"SHIFTENCRYPT\", 4) == \"WLMJXIRGVCTX\");\n\n    return 0;\n}\n"}
{"language": "c++", "domain": "cryptography", "source": "gpt4+人工筛选；源文件地址/data/xw/c++dataset/key/already/99.cpp", "prompt": "#include <iostream>\n#include <string>\n/*\n函数实现Caesar Cipher加密算法\nstd::string caesarEncrypt(std::string input, int shift)\ninput是待加密的字符串\nshift是加密使用的偏移量，该值应当是0到26之间的整数\n返回值是加密后的字符串\n*/\n", "solution": "std::string caesarEncrypt(std::string input, int shift) {\n    std::string output = input;\n    for (auto & c : output) {\n        if (isalpha(c)) {\n            char base = islower(c) ? 'a' : 'A';\n            c = static_cast<char>((c - base + shift) % 26 + base);\n        }\n    }\n    return output;\n}\n", "test": "#include <assert.h>\nusing namespace std;\nint main(){\n    assert(caesarEncrypt(\"Hello, World!\", 3) == \"Khoor, Zruog!\");\n    assert(caesarEncrypt(\"abcdefghijklmnopqrstuvwxyz\", 13) == \"nopqrstuvwxyzabcdefghijklm\");\n    assert(caesarEncrypt(\"ABCDEFGHIJKLMNOPQRSTUVWXYZ\", 13) == \"NOPQRSTUVWXYZABCDEFGHIJKLM\");\n    assert(caesarEncrypt(\"The quick brown fox jumps over the lazy dog\", 5) == \"Ymj vznhp gwtbs ktc ozrux tajw ymj qfed itl\");\n    assert(caesarEncrypt(\"Defend the east wall of the castle\", 1) == \"Efgfoe uif fbtu xbmm pg uif dbtumf\");\n    return 0;\n}\n"}
{"language": "c++", "domain": "cryptography", "source": "gpt4+人工筛选；源文件地址/data/xw/c++dataset/key/already/85.cpp", "prompt": "#include <iostream>\n#include <cctype>\n#include <cassert>\n\nusing namespace std;\n\n/*实现凯撒密码的加密和解密函数\n函数的格式定义为：\nstring caesarCipherEncrypt(string text, int shift);\nstring caesarCipherDecrypt(string cipher, int shift);\n其中text是需要加密的明文，cipher是需要解密的密文，shift是加密和解密的位移量\n返回加密和解密后的字符串\n*/\n", "solution": "\nstring caesarCipherEncrypt(string text, int shift){\n    string result = \"\";\n    for(int i=0;i<text.length();++i){\n        if(isupper(text[i]))\n            result += char((text[i]+shift-65)%26+65);\n        else\n            result += char((text[i]+shift-97)%26+97);\n    }\n    return result;\n}\n\nstring caesarCipherDecrypt(string cipher, int shift){\n    string result = \"\";\n    shift = 26 - shift;\n    for(int i=0;i<cipher.length();++i){\n        if(isupper(cipher[i]))\n            result += char((cipher[i]+shift-65)%26+65);\n        else\n            result += char((cipher[i]+shift-97)%26+97);\n    }\n    return result;\n}\n\n", "test": "int main() {\n    assert(caesarCipherEncrypt(\"ABCD\", 2)==\"CDEF\");\n    assert(caesarCipherEncrypt(\"WXYZ\", 3)==\"ZABC\");\n    assert(caesarCipherDecrypt(\"CDEF\", 2)==\"ABCD\");\n    assert(caesarCipherDecrypt(\"ZABC\", 3)==\"WXYZ\");\n    assert(caesarCipherDecrypt(caesarCipherEncrypt(\"HELLO\", 13), 13)==\"HELLO\");\n\n    return 0;\n}\n"}
{"language": "c++", "domain": "cryptography", "source": "gpt4+人工筛选；源文件地址/data/xw/c++dataset/key/already/65.cpp", "prompt": "#include <iostream>\n#include <string>\n/*实现字符串的异或加密\nstring xorEncrypt(string plaintext, string key)\nplaintext是明文，key是密钥，返回加密后的密文\n*/\n", "solution": "std::string xorEncrypt(std::string plaintext, std::string key){\n    std::string ciphertext = \"\";\n    for(int i=0; i<plaintext.size(); i++){\n        ciphertext += plaintext[i] ^ key[i%key.size()];\n    }\n    return ciphertext;\n}\n", "test": "#include<assert.h>\nint main(){\n    std::string plaintext = \"Hello World!\";\n    std::string key = \"key\";\n    std::string encrypted = xorEncrypt(plaintext, key);\n    assert(encrypted != plaintext);\n    std::string decrypted = xorEncrypt(encrypted, key);\n    assert(decrypted == plaintext);\n    return 0;\n}\n"}
{"language": "c++", "domain": "cryptography", "source": "gpt4+人工筛选；源文件地址/data/xw/c++dataset/key/already/93.cpp", "prompt": "#include <iostream>\n#include <vector>\nusing namespace std;\n/*调用矩阵进行置换密码\nvector<char> permutationCipherEncode(const vector<char>& plaintext, const vector<int>& permutation)\nplaintext 是明文字符数组，permutation是置换规则数组（索引1）\n返回根据置换规则调整过的密文字符数组\n*/\n", "solution": "vector<char> permutationCipherEncode(const vector<char>& plaintext, const vector<int>& permutation) {\n    vector<char> ciphertext(plaintext.size());\n    for(size_t i=0; i<permutation.size(); ++i) {\n        ciphertext[i] = plaintext[permutation[i]-1];\n    }\n    return ciphertext;\n}\n", "test": "#include<assert.h>\nint main() {\n    const vector<char> plaintext1 = {'h','e','l','l','o'};\n    const vector<int> permutation1 = {3,4,5,1,2};\n    const vector<char> result1 = {'l', 'l', 'o','h','e'};\n    assert(permutationCipherEncode(plaintext1, permutation1) == result1);\n\n    const vector<char> plaintext2 = {'w','o','r','l','d'};\n    const vector<int> permutation2 = {2,3,4,5,1};\n    const vector<char> result2 = {'o', 'r', 'l', 'd', 'w'};\n    assert(permutationCipherEncode(plaintext2, permutation2) == result2);\n    \n    const vector<char> plaintext3 = {'a','b','c','d','e'};\n    const vector<int> permutation3 = {5,4,3,2,1};\n    const vector<char> result3 = {'e', 'd', 'c', 'b', 'a'};\n    assert(permutationCipherEncode(plaintext3, permutation3) == result3);\n\n    const vector<char> plaintext4 = {'1','2','3','4','5'};\n    const vector<int> permutation4 = {1,3,5,2,4};\n    const vector<char> result4 = {'1', '3', '5', '2', '4'};\n    assert(permutationCipherEncode(plaintext4, permutation4) == result4);\n\n    const vector<char> plaintext5 = {'z','y','x','w','v'};\n    const vector<int> permutation5 = {2,1,5,3,4};\n    const vector<char> result5 = {'y', 'z', 'v', 'x', 'w'};\n    assert(permutationCipherEncode(plaintext5, permutation5) == result5);\n\n    return 0;\n}\n"}
{"language": "c++", "domain": "cryptography", "source": "gpt4+人工筛选；源文件地址/data/xw/c++dataset/key/already/90.cpp", "prompt": "#include <iostream>\n#include <vector>\n/* 使用C++标准库函数实现简单的Caesar密码，就是简单的移位密码。\nvoid CaesarCipher(std::string &s, int offset)\ns是需要加密的字符串，offset是偏移的位数。\n*/\n", "solution": "void CaesarCipher(std::string &s, int offset) {\n    for(char &c : s) {\n        if (c >= 'A' && c <= 'Z') {\n            c = 'A' + (c - 'A' + offset) % 26;\n        } else if (c >= 'a' && c <= 'z') {\n            c = 'a' + (c - 'a' + offset) % 26;\n        }\n    }\n}\n", "test": "#include<assert.h>\n#include<string.h>\nint main() {\n    std::string s1 = \"HelloWorld\";\n    CaesarCipher(s1, 3);\n    assert(s1 == \"KhoorZruog\");\n    std::string s2 = \"ComputerScience\";\n    CaesarCipher(s2, 7);\n    assert(s2 == \"JvtwbalyZjplujl\");\n    std::string s3 = \"Programming\";\n    CaesarCipher(s3, 10);\n    assert(s3 == \"Zbyqbkwwsxq\");\n    std::string s4 = \"Cryptography\";\n    CaesarCipher(s4, 15);\n    assert(s4 == \"Rgneidvgpewn\");\n    std::string s5 = \"Password\";\n    CaesarCipher(s5, 25);\n    assert(s5 == \"Ozrrvnqc\");\n    return 0;\n}\n"}
{"language": "c++", "domain": "cryptography", "source": "gpt4+人工筛选；源文件地址/data/xw/c++dataset/key/already/37.cpp", "prompt": "#include<iostream>\n#include<string>\nusing namespace std;\n/*\nCaesarCipher函数是凯撒密码的实现，接受两个参数，\ns是待加密的字符串，\nk是偏移量，\n函数会返回一个加密后的字符串。\n*/\n", "solution": "string CaesarCipher(string s, int k){\n    string result = \"\";\n    for(int i=0; i<s.length(); i++){\n        if(isupper(s[i])){\n            result += char(int(s[i]+k-65)%26 +65);\n        }\n        else{\n            result += char(int(s[i]+k-97)%26 +97);\n        }\n    }\n    return result;\n}\n", "test": "#include<assert.h>\nint main(){\n    assert(CaesarCipher(\"ABC\", 3)==\"DEF\");//偏移量为3，则A->D,B->E,C->F,返回\"DEF\"\n    assert(CaesarCipher(\"XYZ\", 1)==\"YZA\");//偏移量为1，则X->Y,Y->Z,Z->A,因为Z后面是A,返回\"YZA\"\n    assert(CaesarCipher(\"abc\", 2)==\"cde\");//偏移量为2，则a->c,b->d,c->e，返回\"cde\"\n    assert(CaesarCipher(\"xyz\", 3)==\"abc\");//偏移量为3，则x->a,y->b，z->c，返回\"abc\"\n    assert(CaesarCipher(\"HELLO\", 13)==\"URYYB\");//偏移量为13，则H->U,E->R,L->Y,L->Y,O->B，返回\"URYYB\"\n    return 0;\n}\n"}
{"language": "c++", "domain": "cryptography", "source": "gpt4+人工筛选；源文件地址/data/xw/c++dataset/key/already/52.cpp", "prompt": "#include <iostream>\n#include <string>\nusing namespace std;\n/*实现一个简单的凯撒密码的加密和解密,考虑了大小写字母的问题\nvoid caesarCipher(std::string &str, int shift)\n输入: 待加密或解密的字符串str、位移量shift\n如果shift为正，则加密str；如果shift为负，则解密str。\nshift取余26，实现环状加密\n加密: (字母的ASCII值+shift-字母的ASCII起点值)%26+字母的ASCII起点值\n解密: (字母的ASCII值-shift-字母的ASCII起点值+26)%26+字母的ASCII起点值，解密时先+26消除负数影响\n*/\n", "solution": "void caesarCipher(std::string &str, int shift) {\n    shift %= 26; // 取余数\n    int len = str.length(); // 获得字符串长度\n    for (int i = 0; i < len; i++) {\n        char ch = str[i];\n        // 大写或小写字母\n        if((ch >= 'A' && ch <= 'Z') || (ch >= 'a' && ch <= 'z')) {\n            bool isLowercase = (ch >= 'a' && ch <= 'z');\n            ch -= isLowercase ? 'a' : 'A';\n            if(shift >= 0)\n                ch = (ch + shift) % 26; // 加密\n            else\n                ch = (ch + shift + 26) % 26; // 解密\n            ch += isLowercase ? 'a' : 'A';\n            str[i] = ch;\n        }\n    }\n}\n", "test": "#include<assert.h>\nint main() {\n    std::string str1=\"def\";\n    caesarCipher(str1, 3);\n    assert(str1 == \"ghi\"); // 'def'向右3位\n    \n    std::string str3=\"aaA\";\n    caesarCipher(str3, 25);\n    assert(str3 == \"zzZ\"); // 'aaA'向右25位\n\n    std::string str4=\"bbB\";\n    caesarCipher(str4, 1);\n    assert(str4 == \"ccC\"); // 'bbB'向右1位\n\n    std::string str5=\"CCc\";\n    caesarCipher(str5, -1);\n    assert(str5 == \"BBb\"); // 'CCc'向左1位\n\n    return 0;\n}\n"}
{"language": "c++", "domain": "cryptography", "source": "gpt4+人工筛选；源文件地址/data/xw/c++dataset/key/already/45.cpp", "prompt": "#include <iostream>\n#include <string>\n#include <cassert>\n\nusing namespace std;\n\n/*实现凯撒密码的函数\n输入是一个字符串和一个整数偏移量，要求把所有字符向右移动这个偏移量\n函数的格式定义为：string CaesarCipher(const string& input, int offset);\n返回加密后的字符串\n注意，输入字符串只包含小写英文字母，偏移量是0-25的整数，\n*/\n", "solution": "\nstring CaesarCipher(const string& input, int offset) {\n    string res;\n    for (auto c : input) {\n        // 将 c映射为0-25\n        int x = c - 'a';\n        x = (x + offset) % 26;\n        // 将处理好的 x映射回字母\n        res.push_back('a' + x);\n    }\n    return res;\n}\n\n", "test": "int main() {\n    assert(CaesarCipher(\"abc\",0)==\"abc\");\n    assert(CaesarCipher(\"abc\",1)==\"bcd\");\n    assert(CaesarCipher(\"abc\",3)==\"def\");\n    assert(CaesarCipher(\"abc\",26)==\"abc\");\n    assert(CaesarCipher(\"abc\",25)==\"zab\");\n\n    return 0;\n}\n"}
{"language": "c++", "domain": "cryptography", "source": "gpt4+人工筛选；源文件地址/data/xw/c++dataset/key/already/67.cpp", "prompt": "#include<string>\n/*实现caesar密码的加密解密\n函数的格式定义为：\nstd::string caesarCipher(std::string text, int shift, bool mode)\ntext 是待处理的文本，只包含小写字母\nshift 是移位数目\nmode 是模式，true为加密，false为解密\n\n返回处理之后的字符串\n*/\n", "solution": "std::string caesarCipher(std::string text, int shift, bool mode){\n    std::string result = \"\";\n    int len = text.length();\n    \n    for(int i=0; i<len; i++){\n        if(mode)\n            result += char(int(text[i] + shift - 97) % 26 + 97);\n        else\n            result += char(int(text[i] - shift - 97) % 26 + 97);\n    }\n\n    return result;\n}\n", "test": "#include<assert.h>\nint main() {\n    assert(caesarCipher(\"hello\", 3, true)==\"khoor\");\n    assert(caesarCipher(\"khoor\", 3, false)==\"hello\");\n    assert(caesarCipher(\"abcd\", 1, true)==\"bcde\");\n    assert(caesarCipher(\"bcde\", 1, false)==\"abcd\");\n    assert(caesarCipher(\"xyz\", 2, true)==\"zab\");\n\n    return 0;\n}\n"}
{"language": "c++", "domain": "cryptography", "source": "gpt4+人工筛选；源文件地址/data/xw/c++dataset/key/already/69.cpp", "prompt": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <openssl/md5.h>\n\n/* \n实现MD5加密，传入一个字符串，返回这个字符串的MD5加密结果。\n函数的格式定义为：char* myMD5(const char* input)\ninput是输入的字符串。\n*/\n\n", "solution": "char* myMD5(const char* input) {\n    unsigned char result[MD5_DIGEST_LENGTH];\n    MD5((unsigned char*)input, strlen(input), result);\n    \n    char *output = (char*)malloc(33);\n    for(int i=0; i<MD5_DIGEST_LENGTH; i++)\n        sprintf(output + (i * 2), \"%02x\", result[i]);\n    output[32]='\\0';\n    \n    return output;\n}\n", "test": "#include <assert.h>\n#include <string.h>\nint main() {\n    char* input1 = \"hello\";\n    char* output1 = \"5d41402abc4b2a76b9719d911017c592\";\n    assert(strcmp(myMD5(input1), output1) == 0);\n\n    char* input2 = \"world\";\n    char* output2 = \"7d793037a0760186574b0282f2f435e7\";\n    assert(strcmp(myMD5(input2), output2) == 0);\n\n    char* input3 = \"12345\";\n    char* output3 = \"827ccb0eea8a706c4c34a16891f84e7b\";\n    assert(strcmp(myMD5(input3), output3) == 0);\n\n    char* input4 = \"password\";\n    char* output4 = \"5f4dcc3b5aa765d61d8327deb882cf99\";\n    assert(strcmp(myMD5(input4), output4) == 0);\n\n    char* input5 = \"admin\";\n    char* output5 = \"21232f297a57a5a743894a0e4a801fc3\";\n    assert(strcmp(myMD5(input5), output5) == 0);\n}\n"}
{"language": "c++", "domain": "cryptography", "source": "gpt4+人工筛选；源文件地址/data/xw/c++dataset/key/already/18.cpp", "prompt": "#include<iostream>\n#include <string.h>\n#include<openssl/md5.h>\n/* \n使用openssl库进行MD5加密\n字符串MD5加密函数，加密原始字符串，返回加密后的字符串\nstring MD5Encrypt(const string& src);\nsrc是原始字符串\n*/\n", "solution": "std::string MD5Encrypt(const std::string& src) {\n    MD5_CTX ctx;\n    unsigned char md[MD5_DIGEST_LENGTH];\n    char buf[33]={'\\0'};\n    char tmp[3]={'\\0'};\n  \n    MD5_Init(&ctx);\n    MD5_Update(&ctx, src.c_str(), src.size());\n    MD5_Final(md,&ctx);\n  \n    for(int i=0; i<16; i++) {\n        sprintf(tmp,\"%02x\", md[i]);\n        strcat(buf, tmp);\n    }\n  \n    return std::string(buf);\n}\n", "test": "#include<assert.h>\nint main() {\n    assert(MD5Encrypt(\"password\")==\"5f4dcc3b5aa765d61d8327deb882cf99\");\n    assert(MD5Encrypt(\"123456\")==\"e10adc3949ba59abbe56e057f20f883e\");\n    assert(MD5Encrypt(\"admin\")==\"21232f297a57a5a743894a0e4a801fc3\");\n    assert(MD5Encrypt(\"test\")==\"098f6bcd4621d373cade4e832627b4f6\");\n    assert(MD5Encrypt(\"helloworld\")==\"fc5e038d38a57032085441e7fe7010b0\");\n    return 0;\n}\n"}
{"language": "c++", "domain": "cryptography", "source": "gpt4+人工筛选；源文件地址/data/xw/c++dataset/key/already/13.cpp", "prompt": "#include <iostream>\n#include <string>\n#include <openssl/md5.h>\n#include <iomanip>\nusing namespace std;\n/*实现一个计算MD5 hash的函数\nstd::string calculateMD5(const std::string &input)\ninput是输入字符串，返回结果是input的MD5 hash,结果是32个字符的16进制字符串\n*/\n", "solution": "std::string calculateMD5(const std::string &input) {\n    unsigned char result[MD5_DIGEST_LENGTH];\n    MD5((unsigned char*)input.c_str(), input.length(), result);\n\n    std::stringstream ss;\n    for(int i = 0; i < MD5_DIGEST_LENGTH; ++i)\n        ss << std::hex << std::setw(2) << std::setfill('0') << (int)result[i];\n\n    return ss.str();\n}\n", "test": "#include<assert.h>\nint main() {\n    assert(calculateMD5(\"hello\")==\"5d41402abc4b2a76b9719d911017c592\");\n    assert(calculateMD5(\"world\")==\"7d793037a0760186574b0282f2f435e7\");\n    // cout << calculateMD5(\"world\") << endl;\n    assert(calculateMD5(\"abcd\")==\"e2fc714c4727ee9395f324cd2e7f331f\");\n    assert(calculateMD5(\"123456\")==\"e10adc3949ba59abbe56e057f20f883e\");\n    assert(calculateMD5(\"\")==\"d41d8cd98f00b204e9800998ecf8427e\");\n    return 0;\n}\n"}
{"language": "c++", "domain": "cryptography", "source": "gpt4+人工筛选；源文件地址/data/xw/c++dataset/key/already/38.cpp", "prompt": "#include <iostream>\n#include <string>\n/*实现凯撒密码\nstd::string caesarCipher(const std::string &text, int shift)\ntext为原始文本，shift为位移量。返回文本的凯撒密码。\n*/\n", "solution": "std::string caesarCipher(const std::string &text, int shift) {\n    std::string result = text;\n    char charShift = static_cast<char>(shift);\n    for(auto &c : result) {\n        if (isalpha(c)) {\n            char base = isupper(c) ? 'A' : 'a';\n            c = static_cast<char>((c - base + charShift) % 26 + base);\n        }\n    }\n    return result;\n}\n", "test": "#include<assert.h>\nint main() {\n    std::string text1 = \"Hello World\";\n    assert(caesarCipher(text1, 3) == \"Khoor Zruog\");\n    std::string text2 = \"abcd\";\n    assert(caesarCipher(text2, 2) == \"cdef\");\n    std::string text3 = \"ABCD\";\n    assert(caesarCipher(text3, 2) == \"CDEF\");\n    std::string text5 = \"123@!#\";\n    assert(caesarCipher(text5, 3) == \"123@!#\");\n    return 0;\n}\n"}
{"language": "c++", "domain": "cryptography", "source": "gpt4+人工筛选；源文件地址/data/xw/c++dataset/key/already/41.cpp", "prompt": "#include <iostream>\n#include <string>\nusing namespace std;\n/*\n实现凯撒密码\nstring caesarCipher(string text, int shift)\ntext是要加密的明文，shift是移位数，返回加密后的密文\n*/\n", "solution": "std::string caesarCipher(std::string text, int shift) {\n    for (int i = 0; i < text.length(); i++) {\n        if (text[i] >= 'a' && text[i] <= 'z') {\n            text[i] = (text[i] - 'a' + shift) % 26 + 'a';\n        } else if (text[i] >= 'A' && text[i] <= 'Z') {\n            text[i] = (text[i] - 'A' + shift) % 26 + 'A';\n        }\n    }\n    return text;\n}\n", "test": "#include<assert.h>\nint main() {\n    std::string text1 = \"Hello, World!\";\n    std::string text2 = \"Keep moving forward\";\n    std::string text3 = \"Boston strong!\";\n    assert(caesarCipher(text1, 13) ==\"Uryyb, Jbeyq!\");\n    assert(caesarCipher(text2, 5) ==\"Pjju rtansl ktwbfwi\");\n    assert(caesarCipher(text3, 10) ==\"Lycdyx cdbyxq!\");\n    return 0;\n}\n"}
{"language": "c++", "domain": "cryptography", "source": "gpt4+人工筛选；源文件地址/data/xw/c++dataset/key/already/33.cpp", "prompt": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n/* \n实现凯撒密码的加密\nvoid caesarCipherEncrypt(char *plainText, int shift, char *cipherText)\nplainText是明文字符串，shift是偏移量，cipherText是加密后的密文字符串。偏移量为正，明文字符向右平移，为负则向左平移\n*/\n", "solution": "void caesarCipherEncrypt(char *plainText, int shift, char *cipherText) {\n    int i;\n    for (i = 0; plainText[i] != '\\0'; i++) {\n        char ch = plainText[i];\n        if (ch >= 'a' && ch <= 'z'){\n            ch = ch + shift;\n            if (ch > 'z') {\n                ch = ch - 'z' + 'a' - 1;\n            }\n            else if (ch < 'a') {\n                ch = ch + 'z' - 'a' + 1;\n            }\n            cipherText[i] = ch;\n        }\n        else if (ch >= 'A' && ch <= 'Z'){\n            ch = ch + shift;\n            if (ch > 'Z') {\n                ch = ch - 'Z' + 'A' - 1;\n            }\n            else if (ch < 'A') {\n                ch = ch + 'Z' - 'A' + 1;\n            }\n            cipherText[i] = ch;\n        }\n        else {\n            cipherText[i] = ch;\n        }\n    }\n    cipherText[i] = '\\0';\n}\n", "test": "#include <assert.h>\n#include <string.h>\nint main(){\n    char cipherText[100];\n\n    char *plainText1 = \"HelloWorld\";\n    caesarCipherEncrypt(plainText1, 3, cipherText);\n    assert(strcmp(cipherText, \"KhoorZruog\") == 0);\n\n    char *plainText2 = \"abcdefghijklmnopqrstuvwxyz\";\n    caesarCipherEncrypt(plainText2, -1, cipherText);\n    assert(strcmp(cipherText, \"zabcdefghijklmnopqrstuvwxy\") == 0);\n\n    char *plainText3 = \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\";\n    caesarCipherEncrypt(plainText3, 1, cipherText);\n    assert(strcmp(cipherText, \"BCDEFGHIJKLMNOPQRSTUVWXYZA\") == 0);\n\n    char *plainText4 = \"123456\";\n    caesarCipherEncrypt(plainText4, 2, cipherText);\n    assert(strcmp(cipherText, \"123456\") == 0);\n    \n    char *plainText5 = \" \";\n    caesarCipherEncrypt(plainText5, 2, cipherText);\n    assert(strcmp(cipherText, \" \") == 0);\n    \n    return 0;\n}\n"}
{"language": "c++", "domain": "cryptography", "source": "gpt4+人工筛选；源文件地址/data/xw/c++dataset/key/already/54.cpp", "prompt": "#include<iostream>\n#include<string>\nusing namespace std;\n/* 用于实现简易的凯撒密码加密解密的函数，凯撒密码是一种替换加密的技术，加密解密过程中每个字母在字母表上向后（或向前）按照一个固定数目进行偏移然后替换。\n函数格式定义为：string caesar_cipher(string text, int s, bool isEncode) */\n", "solution": "string caesar_cipher(string text, int s, bool isEncode) {\n    string result = \"\";\n    if(isEncode){\n        for (int i=0;i<text.length();i++) {\n            if (isupper(text[i]))\n                result += char(int(text[i]+s-65)%26 +65);\n            else\n                result += char(int(text[i]+s-97)%26 +97);\n        }\n        return result;\n    }\n    else{\n        string decrypt = \"\";\n        for (int i=0;i<text.length();i++) {\n            if (isupper(text[i]))\n                decrypt += char(int(text[i]-s+65)%26 +65);\n            else\n                decrypt += char(int(text[i]-s+97)%26 +97);\n        }\n        return decrypt;\n    }\n}\n", "test": "#include<assert.h>\nint main() {\n    string text_1 = \"HELLO\";\n    string text_2 = \"WORLD\";\n    string text_3 = \"ABC\";\n    string text_4 = \"DEF\";\n    string text_5 = \"TESTING\";\n    int s = 4;\n    assert(caesar_cipher(text_1, s, true) == \"LIPPS\");\n    assert(caesar_cipher(caesar_cipher(text_1, s, true), s, false) == text_1);\n    assert(caesar_cipher(text_2, s, true) == \"ASVPH\");\n    assert(caesar_cipher(caesar_cipher(text_2, s, true), s, false) == text_2);\n    assert(caesar_cipher(text_3, s, true) == \"EFG\");\n    assert(caesar_cipher(caesar_cipher(text_3, s, true), s, false) == text_3);\n    assert(caesar_cipher(text_4, s, true) == \"HIJ\");\n    assert(caesar_cipher(caesar_cipher(text_4, s, true), s, false) == text_4);\n   \n    assert(caesar_cipher(caesar_cipher(text_5, s, true), s, false) == text_5);\n    \n    return 0;\n} \n"}
{"language": "c++", "domain": "cryptography", "source": "gpt4+人工筛选；源文件地址/data/xw/c++dataset/key/already/92.cpp", "prompt": "#include <iostream>\n#include <string>\nusing namespace std;\n\n/*实现一个简单的置换密码加密解密函数\n函数的格式定义为：string PermutationCipher(string s, int key)\ns为待加密或解密的字符串\nkey为进行加解密的数字密钥，只能为正数且不能大于字符串长度\n若key为正数，进行加密处理，即将字符串中每个字符向后移key个位置，若超过z则回到a开始\n若key为负数，进行解密处理，即将字符串中每个字符向前移key个位置，若小于a则回到z开始\n返回加密或解密后的字符串\n*/\n", "solution": "string PermutationCipher(string s, int key){\n    for(int i = 0; i < s.length(); i++){\n        if('a' <= s[i] && s[i] <= 'z'){\n            s[i] = 'a' + (s[i] - 'a' + key + 26) % 26;\n        }\n        else if('A' <= s[i] && s[i] <= 'Z'){\n            s[i] = 'A' + (s[i] - 'A' + key + 26) % 26;\n        }\n    }\n    return s;\n}\n", "test": "#include<assert.h>\nint main() {\n    assert((PermutationCipher(\"abc\", 3))==\"def\");\n    assert((PermutationCipher(\"xyz\", 3))==\"abc\");\n    assert((PermutationCipher(\"def\", -3))==\"abc\");\n    assert((PermutationCipher(\"abc\", 0))==\"abc\");\n    assert((PermutationCipher(\"abc\", 26))==\"abc\");\n    return 0;\n}\n"}
{"language": "c++", "domain": "cryptography", "source": "gpt4+人工筛选；源文件地址/data/xw/c++dataset/key/already/87.cpp", "prompt": "#include <iostream>\n#include <string>\n#include <map>\nusing namespace std;\n/*使用C++标准库中的map容器实现凯撒密码(Caesar Cipher)加密解密\nstring caesarCipher(string text, int shift, bool isEncrypt)\ntext是需要处理的信息（明文或密文），shift是移位数，isEncrypt为true时执行加密，为false时执行解密\n函数返回处理后的信息（密文或明文）\n*/\n", "solution": "string caesarCipher(string text, int shift, bool isEncrypt){\n    string result = \"\";\n    map<char, int> alphabet;\n    for(int i = 0; i < 26; i++){\n        alphabet[char('a'+i)] = i;\n        alphabet[char('A'+i)] = i;\n    }\n    for(auto i : text){\n        if(isalpha(i)){\n            if(isEncrypt)\n                result += isupper(i) ? char('A' + (alphabet[i] + shift)%26) : char('a' + (alphabet[i] + shift)%26);\n            else\n                result += isupper(i) ? char('A' + (alphabet[i] - shift + 26) % 26) : char('a' + (alphabet[i] - shift + 26) % 26);\n        }\n        else\n            result += i;\n    }\n    return result;\n}\n", "test": "#include<assert.h>\nint main(){\n    assert(caesarCipher(\"Hello Caesar Cipher!\", 3,true) == \"Khoor Fdhvdu Flskhu!\");\n    assert(caesarCipher(\"Khoor Fdhvdu Flskhu!\", 3,false) == \"Hello Caesar Cipher!\");\n    assert(caesarCipher(\"abcde\", 1,true) == \"bcdef\");\n    assert(caesarCipher(\"abcde\", 5,true) == \"fghij\");\n    assert(caesarCipher(\"ABCDEFGHIJKLMNOPQRSTUVWXYZ\", 13,true) == \"NOPQRSTUVWXYZABCDEFGHIJKLM\");\n    return 0;\n}\n"}
